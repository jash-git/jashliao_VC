<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0055)http://forum.eviloctal.com/simple/index.php?t21627.html -->
<HTML><HEAD><TITLE>[转载]抓屏的各种方法 帝国艺术[ C and C++ Programming ] 邪恶八进制信息安全团队官方学术讨论组 - 努力为祖国的信息安全撑起一片蓝天 - EvilOctal Security Team - E.S.T</TITLE>
<META http-equiv=Content-Type content="text/html; charset=gbk">
<META content=邪恶八进制,信息安全,黑客 name=keywords><!--css-->
<STYLE type=text/css>BODY {
	FONT-SIZE: 12px; BACKGROUND: #ffffff; MARGIN: 0px; COLOR: #000000; FONT-FAMILY: Verdana
}
IMG {
	BORDER-RIGHT: 0px; BORDER-TOP: 0px; BORDER-LEFT: 0px; BORDER-BOTTOM: 0px
}
TD {
	FONT-SIZE: 12px
}
TEXTAREA {
	FONT-SIZE: 12px; FONT-FAMILY: Verdana; BACKGROUND-COLOR: #ffffff
}
INPUT {
	FONT-SIZE: 12px; FONT-FAMILY: Verdana; BACKGROUND-COLOR: #ffffff
}
SELECT {
	FONT-SIZE: 12px; FONT-FAMILY: Verdana; BACKGROUND-COLOR: #ffffff
}
DIV.quote {
	BORDER-RIGHT: #e7e3e7 1px dashed; PADDING-RIGHT: 5px; BORDER-TOP: #e7e3e7 1px dashed; PADDING-LEFT: 5px; BACKGROUND: #ffffff; PADDING-BOTTOM: 5px; MARGIN: 5px; BORDER-LEFT: #e7e3e7 1px dashed; LINE-HEIGHT: normal; PADDING-TOP: 5px; BORDER-BOTTOM: #e7e3e7 1px dashed
}
A {
	TEXT-DECORATION: none
}
A:hover {
	COLOR: #ff0000; TEXT-DECORATION: none
}
.smalltxt {
	FONT-SIZE: 12px; FONT-FAMILY: Tahoma, Verdana
}
.tpc_content {
	FONT-SIZE: 13px
}
.i_table {
	BORDER-RIGHT: #e7e3e7 1px solid; BORDER-TOP: #e7e3e7 1px solid; BORDER-LEFT: #e7e3e7 1px solid; BORDER-BOTTOM: #e7e3e7 1px solid
}
.head {
	BACKGROUND-COLOR: #e7e3e7
}
</STYLE>
<!--css-->
<META content="MSHTML 6.00.2900.2180" name=GENERATOR></HEAD>
<BODY vLink=#333333 link=#333333><BR><BR>
<TABLE cellSpacing=1 cellPadding=0 width="98%" align=center bgColor=#e7e3e7>
  <TBODY>
  <TR>
    <TD>
      <TABLE cellSpacing=0 cellPadding=8 width="100%">
        <TBODY>
        <TR>
          <TD bgColor=#ffffff><B><A 
            href="http://forum.eviloctal.com/simple/index.php?">邪恶八进制信息安全团队官方学术讨论组 
            </A>-&gt; <A 
            href="http://forum.eviloctal.com/simple/index.php?f26.html">帝国艺术[ C 
            and C++ Programming ]</A> -&gt; <A 
            href="http://forum.eviloctal.com/simple/index.php?t21627.html">[转载]抓屏的各种方法</A></B> 
          </TD>
          <TD align=right bgColor=#ffffff><B><A 
            href="http://forum.eviloctal.com/login.php">登录</A> -&gt; <A 
            href="http://forum.eviloctal.com/register.php">注册</A> -&gt; <A 
            href="http://forum.eviloctal.com/post.php?action=reply&amp;fid=26&amp;tid=21627">回复主题</A> 
            -&gt; <A 
            href="http://forum.eviloctal.com/post.php?fid=26">发表主题</A></B></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P>
<CENTER></CENTER>
<P></P>
<TABLE class=i_table cellSpacing=1 cellPadding=1 width="98%" align=center>
  <TBODY>
  <TR>
    <TD>
      <TABLE cellSpacing=0 cellPadding=3 width="100%">
        <TBODY>
        <TR class=head>
          <TD><B>sunlion</B></TD>
          <TD class=smalltxt align=right>2006-04-18 10:33</TD></TR>
        <TR bgColor=#ffffff>
          <TD class=tpc_content colSpan=2>源地址:<A 
            href="http://blog.csdn.net/uoyevoli/archive/2005/06/12/393193.aspx" 
            target=_blank>http://blog.csdn.net/uoyevoli/archive/2005/06/12/393193.aspx</A><BR><BR>本文章翻译自P.GopalaKrishna的Various 
            methods for capturing the screen一文，原版地址见下面。本文章版权归原作者所有。<BR>&nbsp; 
            如果转载该译文,请保证文章的完整性，并注明来自<A href="http://www.farproc.com/" 
            target=_blank>http://www.farproc.com/</A><BR>袁晓辉 
            <BR>2005/6/12<BR><BR>原版地址：<A 
            href="http://www.codeproject.com/dialog/screencap.asp#Windows%20Media%20API%20for%20Capturing%20the%20Screen%20:" 
            target=_blank>http://www.codeproject.com/dialog/screencap.asp#Windows%20Media%20API%20for%20Capturing%20the%20Screen%20:</A><BR><BR><BR><BR>本文附带源码1下载 
            39K<BR><BR>本文附带源码2下载 135.5K<BR><BR>本文附带源码3下载 
            59.8K<BR><BR><BR><BR>目录：<BR><BR><BR><BR>l &nbsp; &nbsp; &nbsp; 
            导言<BR><BR>l &nbsp; &nbsp; &nbsp; 用GID函数抓屏<BR><BR>l &nbsp; &nbsp; 
            &nbsp; 用DirectX方式抓屏<BR><BR>l &nbsp; &nbsp; &nbsp; 用Windows Media 
            API抓屏<BR><BR><BR><BR>导言<BR><BR><BR><BR>有时候我们需要编程抓取整个屏幕上的内容，下面我将介绍抓屏是如何实现的。典型地，我们可以用GID和DirectX来完成，另外一个选择是Windows 
            Media 
            API，在这篇文章我会逐一加以分析。在每一种方法里，一旦我们把屏幕的内容保存到了程序定义的内存块或bitmap文件里，我们就可以进一步利用它们来生成动画和电影，这个过程你可以参考“从HBitmap创建电影”一文中，以获得更多的帮助。<BR><BR><BR><BR>用GDI函数抓屏<BR><BR>如果我们不太在意抓屏的效率，并且我们想要的只是一个屏幕快照的话，可以考虑使用GDI方式。这种抓屏机制是以“桌面也是一个窗口，桌面也有一个窗口句柄（HWND）”这个简单的常识为基础的，如果我们得到了桌面的设备上下文（DC），就可以利用blit（复制）它的内容到我们创建的DC中。我们可以用GetDeskWindow（）得到桌面的窗口句柄，从句柄得到DC也是很容易的。具体的实现步骤为：<BR><BR><BR><BR>1. 
            &nbsp; &nbsp; &nbsp; 通过GetDesktopWindow（）函数得到桌面的窗口句柄<BR><BR>2. 
            &nbsp; &nbsp; &nbsp; 用GetDC（）取得桌面窗口的DC<BR><BR>3. &nbsp; &nbsp; 
            &nbsp; 创建和屏幕DC兼容的位图和DC（CreateCompatibleBitmap 
            （）和CreateCompatibleDC（）），并把这个位图选进该DC（SelectObject（））<BR><BR>4. 
            &nbsp; &nbsp; &nbsp; 
            当你准备好抓屏时，就复制桌面窗口DC的内容到兼容DC，你就完成的抓屏过程，兼容位图中就是抓屏时刻的屏幕内容<BR><BR>5. 
            &nbsp; &nbsp; &nbsp; 
            完成后别忘了释放你创建的对象，内存是宝贵的（对别的程序来说）<BR><BR><BR><BR>示例代码：<BR><BR>void 
            CaptureScreen()<BR><BR>{<BR><BR>&nbsp; int nScreenWidth = 
            GetSystemMetrics(SM_CXSCREEN);<BR><BR>&nbsp; int nScreenHeight = 
            GetSystemMetrics(SM_CYSCREEN);<BR><BR>&nbsp; HWND hDesktopWnd = 
            GetDesktopWindow();<BR><BR>&nbsp; HDC hDesktopDC = 
            GetDC(hDesktopWnd);<BR><BR>&nbsp; HDC hCaptureDC = 
            CreateCompatibleDC(hDesktopDC);<BR><BR>&nbsp; HBITMAP hCaptureBitmap 
            =CreateCompatibleBitmap(hDesktopDC,<BR><BR>&nbsp; &nbsp; 
            nScreenWidth, nScreenHeight);<BR><BR>&nbsp; 
            SelectObject(hCaptureDC,hCaptureBitmap);<BR><BR>&nbsp; 
            BitBlt(hCaptureDC,0,0,nScreenWidth,nScreenHeight,hDesktopDC,0,0,SRCCOPY);<BR><BR>&nbsp; 
            SaveCapturedBitmap(hCaptureBitmap); //Place holder - Put your 
            code<BR><BR>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
            &nbsp; &nbsp; //here to save the captured image to 
            disk<BR><BR>&nbsp; ReleaseDC(hDesktopWnd,hDesktopDC);<BR><BR>&nbsp; 
            DeleteDC(hCaptureDC);<BR><BR>&nbsp; 
            DeleteObject(hCaptureBitmap);<BR><BR>}<BR><BR><BR><BR>上面代码段中，GetSystemMetrics（）返回屏幕的宽度（SM_CXSCREEN）和高度（SM_CYSCREEN）。关于如何保存抓到的位图到文件和如何置到剪贴板，请参看附带的源代码，很简单的。示例代码每隔一段时间就通过上述技术抓屏，并把图像序列保存到动画。<BR><BR><BR><BR>DirectX方式<BR><BR>用DreictX进行抓屏也是很简单的，DirectX提供了很优雅的实现。<BR><BR>每个DirectX程序都包含一个被我们称作缓冲的内存区域，其中保存了和该程序有关的显存内容，这在程序中被称作后台缓冲（Back 
            Buffer），有些程序有不止一个的后台缓冲。还有一个缓冲，在默认情况下每个程序都可以访问－前台缓冲。前台缓冲保存了和桌面相关的显存内容，实质上就是屏幕图像。<BR><BR>我们的程序通过访问前台缓冲就可以捕捉到当前屏幕的内容。由DirectX的底层优化机制做保证，我们的抓屏效率是很高的，至少比GDI方式高。<BR><BR>在DirectX程序中访问前台缓冲是很简单的，IDirect3DDevice8接口提供了GetFrontBuffer()方法，它接收一个IDirect3DSurface8对象指针做参数，并复制前台缓冲的内容到该Surface。IDirect3DSurfce8对象可以用IDirect3DDevice8::CreateImageSurface()得到。一旦屏幕内容被保存到了这个surface，我们就可以用D3DXSaveSurfaceToFile()方法直接把内容保存到磁盘bmp文件。示例代码如下：<BR><BR>extern 
            IDirect3DDevice8* g_pd3dDevice;<BR><BR>Void 
            CaptureScreen()<BR><BR>{<BR><BR>&nbsp; IDirect3DSurface8 * 
            pSurface;<BR><BR>&nbsp; 
            g_pd3dDeviceàCreateImageSurface(ScreenWidth,ScreenHeight,<BR><BR>&nbsp; 
            &nbsp; D3DFMT_A8R8G8B8,&amp;pSurface);<BR><BR>&nbsp; 
            g_pd3dDevice-&gt;GetFrontBuffer(pSurface);<BR><BR>&nbsp; 
            D3DXSaveSurfaceToFile("Desktop.bmp",D3DXIFF_BMP,pSurface,<BR><BR>&nbsp; 
            &nbsp; NULL,NULL);<BR><BR>&nbsp; 
            pSurface-&gt;Release();<BR><BR>}<BR><BR>上面，g_pd3dDevice 
            是一个初始化好的IDirect3DDevice对象，这个例子直接把捕捉到的图像保存到文件。然而，有时候我们想访问直接这个图像中的各个位，我们可以使用IDirect3DSurface8::LockRect()，它给我们一个执行surface内存的指针，也就是捕捉到的图像的数据。我们复制这些数据到程序定义的内存中就可以操作它了。看下面的代码：<BR><BR>extern 
            void* pBits;<BR><BR>extern IDirect3DDevice8* 
            g_pd3dDevice;<BR><BR>IDirect3DSurface8 * 
            pSurface;<BR><BR>g_pd3dDeviceàCreateImageSurface(ScreenWidth,ScreenHeight,<BR><BR>&nbsp; 
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
            D3DFMT_A8R8G8B8,&amp;pSurface);<BR><BR>g_pd3dDevice-&gt;GetFrontBuffer(pSurface);<BR><BR>D3DLOCKED_RECT 
            lockedRect;<BR><BR>pSurfaceàLockRect(&amp;lockedRect,NULL,<BR><BR>&nbsp; 
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
            D3DLOCK_NO_DIRTY_UPDATE|D3DLOCK_NOSYSLOCK|<BR><BR>&nbsp; &nbsp; 
            &nbsp; &nbsp; &nbsp; &nbsp; D3DLOCK_READONLY)));<BR><BR>for( int i=0 
            ; i &lt; ScreenHeight ; i++)<BR><BR>{<BR><BR>&nbsp; memcpy( (BYTE*) 
            pBits + i * ScreenWidth * BITSPERPIXEL / 8 ,<BR><BR>&nbsp; &nbsp; 
            (BYTE*) lockedRect.pBits + i* lockedRect.Pitch ,<BR><BR>&nbsp; 
            &nbsp; ScreenWidth * BITSPERPIXEL / 
            8);<BR><BR>}<BR><BR>g_pSurface-&gt;UnlockRect();<BR><BR>pSurface-&gt;Release();<BR><BR><BR><BR>上面的pBits是一个void*，请保证为先为它分配组足够的内存空间。BITSPERPIXEL一般用32位色即可，它也取决于你的显示器当前配置。一个需要注意的是，surface的宽度和被捕捉的屏幕宽度不一样。由于内存对齐的原因(按WORD对齐的内存通常在访问时效率较高)，surface在每行结尾处可能会有多余的bits以使它对齐到word边界上。lockedRect.Pitch给我们提供了两个连续行的开端之间的字节数。也就是说我们在读取一行时要向后移动指针Pitch字节而不是Width字节。你可以用下面的代码反序复制surface：<BR><BR>for( 
            int i=0 ; i &lt; ScreenHeight ; i++)<BR><BR>{<BR><BR>&nbsp; 
            memcpy((BYTE*) pBits +( ScreenHeight - i - 1) *<BR><BR>&nbsp; &nbsp; 
            ScreenWidth * BITSPERPIXEL/8 ,<BR><BR>&nbsp; &nbsp; (BYTE*) 
            lockedRect.pBits + i* lockedRect.Pitch ,<BR><BR>&nbsp; &nbsp; 
            ScreenWidth* 
            BITSPERPIXEL/8);<BR><BR>}<BR><BR>这对于从top-down位图到bottom-up位图很有用。<BR><BR><BR><BR>我们还可以使用IDirect3DSurface9的 
            GetDC()方法取得DirectX 
            surface的GDI兼容DC，然后复制它的内容到我们的兼容DC。如果你用的是DirectX9，试试吧。<BR><BR><BR><BR>最后，需要注意的一点，文档提到：FrontBuffer是一个比较慢的操作，设计就是如此，所以在效率很关键的程序中应避免使用。已经警告你了！本文附带的源代码用这种技术定时捕捉屏幕，并保存为动画。<BR><BR><BR><BR>用Windows 
            Media API抓屏<BR><BR>Windows Media 9.0 支持用Windows Media Encoder 9 
            API来抓屏。它有一个编码器叫Windows Media Video 9 Screen codec，特别为抓屏优化过。Windows 
            Media Encoder 
            API提供了一个IWMEncoder2接口可以用来高效地捕捉屏幕图像。<BR><BR><BR><BR>用这种技术进行抓屏也很简单，首先我们用CoCreateInstance()创建一个IWMEncoder2对象：<BR><BR>IWMEncoder2* 
            g_pEncoder=NULL;<BR><BR>CoCreateInstance(CLSID_WMEncoder,NULL,CLSCTX_INPROC_SERVER,<BR><BR>&nbsp; 
            &nbsp; 
            IID_IWMEncoder2,(void**)&amp;g_pEncoder);<BR><BR>这个Encoder对象包含了捕捉屏幕的所需的全部操作，然而为了正确地工作，编码器对象的行为取决于被称作profile的设置。一个profile只是一个包含了所有控制编码操作设置的文件，我们可以根据被捕捉的数据的特性在运行时创建包含自定义设置的profile。为了在你的抓屏程序中使用profile，我们基于Windows 
            Media Video 9 Screen 
            codec来创建自定义的profile。自定义的profile对象从IWMEncProfile2开始就被支持了。我们可以用CoCreateInstance来创建自定义profile<BR><BR>IWMEncProfile2* 
            g_pProfile=NULL;<BR><BR>CoCreateInstance(CLSID_WMEncProfile2,NULL,CLSCTX_INPROC_SERVER,<BR><BR>&nbsp; 
            &nbsp; 
            IID_IWMEncProfile2,(void**)&amp;g_pProfile);<BR><BR>我需要在profile里指定编码器的听众（audience）。每个profile可以包含多个听众配置，它们是IWMEncAudienceObj接口对象。这里我们为profile使用一个听众。我们可以通过IWMEncProfile::AddAudience()为我们的profile创建听众，这个函数返回一个IWMEncAudienceObj指针，可以用来配置视频编码器(IWMEncAudienceObj::put_VideoCodec())，视频帧对象(IWMEncAudienceObj::put_VideoHeight() 
            和IWMEncAudienceObj::put_VideoWidth())我们用下面的代码来配置视频编码器：<BR><BR>extern 
            IWMEncAudienceObj* pAudience;<BR><BR>#define VIDEOCODEC 
            MAKEFOURCC('M','S','S','2')<BR><BR>&nbsp; //MSS2 is the fourcc for 
            the screen codec<BR><BR><BR><BR>long 
            lCodecIndex=-1;<BR><BR>g_pProfile-&gt;GetCodecIndexFromFourCC(WMENC_VIDEO,VIDEOCODEC,<BR><BR>&nbsp; 
            &amp;lCodecIndex); //Get the Index of the 
            Codec<BR><BR>pAudience-&gt;put_VideoCodec(0,lCodecIndex);<BR><BR><BR><BR>fourcc是针对每个编码器的唯一的标识，Windows 
            Media Video 9 Screen 
            codec的fourcc为MSS2。IWMEncAudienceObj::put_VideoCodec()接受profile索引来组织一个profile，索引可以用IWMEncProfile::GetCodecIndexFromFourCC()取得。<BR><BR><BR><BR>一旦我们配置完毕一个profile对象，我们就可以用IWMEncSourceGroup 
            :: 
            put_Profile()选择这个profile到我们的编码器。一个源组（SourceGruop）是一组视频流来源或音频流来源，或html来源。每个编码器可以使用许多源组，并从中取得输入数据。由于我们的程序仅仅使用视频流中是视频来源。这个视频来源需要用IWMEncVideoSource2::SetInput(BSTR) 
            Screen Device来配置为输入来源：<BR><BR>extern IWMEncVideoSource2* 
            pSrcVid;<BR><BR>pSrcVid-&gt;SetInput(CComBSTR("ScreenCap://ScreenCapture1");<BR><BR><BR><BR>目的输出可以用IWMEncFile::put_LocalFileName()配置为保存到视频文件（wmv文件）。IWMEncFile对象可以用IWMEncoder::get_File()得到：<BR><BR>IWMEncFile* 
            pOutFile=NULL;<BR><BR>g_pEncoder-&gt;get_File(&amp;pOutFile);<BR><BR>pOutFile-&gt;put_LocalFileName(CComBSTR(szOutputFileName);<BR><BR><BR><BR>现在，一旦编码器对象的一切所需配置都完成后，我们就可以用IWMEncoder::Start()开始抓屏。IWMEncoder::Stop() 
            和 
            IWMEncoder::Pause可以用来停止和暂停捕捉。<BR><BR>这些适用于全屏捕捉，我们也可以通过调整输入视频来源流的属性来选择一个区域进行捕捉。我们可以用IWmEnVideoSource2的IPropertyBag 
            接口来实现：<BR><BR>#define WMSCRNCAP_WINDOWLEFT 
            CComBSTR("Left")<BR><BR>#define WMSCRNCAP_WINDOWTOP 
            CComBSTR("Top")<BR><BR>#define WMSCRNCAP_WINDOWRIGHT 
            CComBSTR("Right")<BR><BR>#define WMSCRNCAP_WINDOWBOTTOM 
            CComBSTR("Bottom")<BR><BR>#define WMSCRNCAP_FLASHRECT 
            CComBSTR("FlashRect")<BR><BR>#define WMSCRNCAP_ENTIRESCREEN 
            CComBSTR("Screen")<BR><BR>#define WMSCRNCAP_WINDOWTITLE 
            CComBSTR("WindowTitle")<BR><BR>extern IWMEncVideoSource2* 
            pSrcVid;<BR><BR>int nLeft, nRight, nTop, 
            nBottom;<BR><BR>pSrcVid-&gt;QueryInterface(IID_IPropertyBag,(void**)&amp;pPropertyBag);<BR><BR>CComVariant 
            varValue = 
            false;<BR><BR>pPropertyBag-&gt;Write(WMSCRNCAP_ENTIRESCREEN,&amp;varValue);<BR><BR>varValue 
            = nLeft;<BR><BR>pPropertyBag-&gt;Write( WMSCRNCAP_WINDOWLEFT, 
            &amp;varValue );<BR><BR>varValue = 
            nRight;<BR><BR>pPropertyBag-&gt;Write( WMSCRNCAP_WINDOWRIGHT, 
            &amp;varValue );<BR><BR>varValue = 
            nTop;<BR><BR>pPropertyBag-&gt;Write( WMSCRNCAP_WINDOWTOP, 
            &amp;varValue );<BR><BR>varValue = 
            nBottom;<BR><BR>pPropertyBag-&gt;Write( WMSCRNCAP_WINDOWBOTTOM, 
            &amp;varValue 
            );<BR><BR><BR><BR>本文附带的源码实现此中技术的抓屏。除去生成的动画质量很好外，一个有意思的地方是鼠标指针也被抓到了（GDI和DirectX默认是不抓取鼠标指针的）。<BR><BR><BR><BR>注意，为了适用WindowMedia9.0 
            API，你的电脑必须安装Windows Media9.0 SDK，你可以用下面地址下载：<BR><BR>&nbsp; * <A 
            href="http://msdn.microsoft.com/library/default.asp?url=/downloads/list/winmedia.asp" 
            target=_blank>http://msdn.microsoft.com/library/default.asp?url=/downloads/list/winmedia.asp</A><BR><BR>最终用户必须安装Windows 
            Media Encoder 9 系列才能运行你的程序。在发布基于Windows Media Encoder 
            SDK的程序时，Windows Media Encoder软件也必须附带上去，要么在你的软件安装时自动安装Windows Media 
            Encoder要么让用户自己下载安装。<BR><BR><BR><BR>Windows Encoder 
            9.0可以从下面地址下载：<BR><BR><A 
            href="http://www.microsoft.com/windows/windowsmedia/" 
            target=_blank>http://www.microsoft.com/windows/windowsmedia/</A> 
            9series/encoder/default.aspx<BR><BR><BR><BR>结论<BR><BR>上面讨论的各种方法都是基于一个目标－抓取屏幕的内容。然而适用不同的技术，得到的结果也不一样。如果我们需要的只是偶尔的抓屏，GDI方式是个好的选择，因为它简单。然而如果你想得到更专业的结果，可以使用Windows 
            Media。一个可能没有意义的要点是，这些技术捕捉到的内容的质量很大程度上决于你的系统设置，比如进制硬件加速会大大提高抓屏的质量和程序的运行效率。</TD></TR></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><BR><BR>
<CENTER><B>查看完整版本: [-- <A href="http://forum.eviloctal.com/read.php?tid=21627" 
target=_blank>[转载]抓屏的各种方法</A> --] [-- <A 
href="http://forum.eviloctal.com/simple/index.php?t21627.html#">top</A> 
--]</B></CENTER>
<SCRIPT language=JavaScript>
function CopyCode(obj){
	var js = document.body.createTextRange();
	js.moveToElementText(obj);
	js.select(); 
	js.execCommand("Copy");
}
</SCRIPT>
<BR><BR>
<CENTER><SMALL><FONT color=#999999>Powered by <A title=本站电子公告服务专项审批已经同步完成 
href="http://www.eviloctal.com/" target=_blank><B>EvilOctal Security 
Team</B></A> Code &copy; 2003-06 <A 
href="http://www.phpwind.com/?prog=check&amp;c_bbsurl=www.eviloctal.com" 
target=_blank><B>PHPWind Board</B></A> <A 
href="http://www.phpwind.net/index.php?u=12499" target=_blank><B 
style="COLOR: #ff9900">v4.3.2</B></A><BR>Time 0.033462 second(s),query:3 Time is 
now:, Gzip enabled<BR><BR>You can <A 
href="http://www.eviloctal.com/about.html">contact us</A></FONT></SMALL> 
</CENTER><BR></BODY></HTML>
