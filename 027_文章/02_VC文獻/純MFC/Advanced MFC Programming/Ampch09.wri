{\rtf1\ansi\ansicpg1252\deff0\deftab720{\fonttbl{\f0\fswiss MS Sans Serif;}{\f1\froman\fcharset2 Symbol;}{\f2\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;}
\deflang1033\pard\plain\f2\fs20 Chapter 9 Font
\par 
\par Font is another very important GDI object, every application deals with font. Usually a system contains some default fonts that can be used by all the applications. Besides these default fonts, we can also install fonts provided by the thirty party. For word processing applications, using font is a complex issue. There are many things we need to take care. For example, when creating this type of applications, we need to think about the following issues: how to display a font with different styles; how to change the text alignment; how to add special effects to characters.
\par 
\par 9.1\tab Outputting Text Using Different Fonts
\par 
\par When we implement a font dialog box, all the available fonts contained in the system will be listed in it. We can select font size, font name, special styles, and text color.
\par 
\par Like other GDI objects such as pen and brush, we need to create font with specific styles and select it into a DC in order to use it for outputting text. In MFC, the class that can be used to implement font is CFont. To create a font, we can call either CFont::CreateFont(...) or CFont::CreateFontIndirect(...), whose formats are listed as follows: 
\par 
\par (Code omitted)
\par 
\par The first function has many parameters and the second one needs only a LOGFONT type pointer. The results of the two member functions are exactly the same, every style we need to specify for a font in the first function has a corresponding member in structure LOGFONT:
\par 
\par typedef struct tagLOGFONT\{
\par    LONG lfHeight; 
\par    LONG lfWidth; 
\par    LONG lfEscapement; 
\par    LONG lfOrientation; 
\par    LONG lfWeight; 
\par    BYTE lfItalic; 
\par    BYTE lfUnderline; 
\par    BYTE lfStrikeOut; 
\par    BYTE lfCharSet; 
\par    BYTE lfOutPrecision; 
\par    BYTE lfClipPrecision; 
\par    BYTE lfQuality; 
\par    BYTE lfPitchAndFamily; 
\par    TCHAR lfFaceName[LF_FACESIZE]; 
\par \} LOGFONT;
\par 
\par Here, member lfFaceName specifies the font name; lfHeight and lfWidth specify font size; lfWeight, lfItalic, lfUnderline and lfStrikeOut specify font styles. Besides these styles, there are two other styles that can be specified: lfEscapement and lfOrientation.
\par 
\par Under Windows 95, lfEscapement and lfOrientation must be assigned the same value when a font is being created. If they are non-zero, the text will have an angle with respect to the horizontal border of the window when it is displayed (Figure 9-1). To display text this way, we must assign the angle to both lfEscapement and lfOrientation when creating the font, the unit of the angle is one tenth of a degree. Please note that only True Type fonts can have such orientation.
\par 
\par After a font is created, it can be selected into DC for outputting text. After the text output is over, it must be selected out of the DC. This procedure is exactly the same with other GDI objects.
\par 
\par Sample 9.1\\GDI demonstrates how to create and use a font with specified styles. It is a standard SDI application generated by Application Wizard. In the sample, the user can choose any available font in the system and set its styles (bold, italic, underline, etc). The face name of the font will be displayed in the client window using the selected font, and the user can also set the escapement of the font.
\par 
\par Two variables are added to class CGDIDoc: CGDIDoc::m_fontDraw and CGDIDoc::m_colorFont. The first variable is declared as a CFont type variable, it will be used to create the font. The second variable is declared as a COLORREF type variable, it will be used to store the color of the text.
\par 
\par Besides font color, we also need to consider the background color of the text. A text can be displayed with either a transparent or opaque background. In the latter case, we can set the background to different colors. In order to display text in different styles, another Boolean type variable CGDIDoc:: m_bTransparentBgd is declared, it will be used to indicate if the background is transparent or opaque.
\par 
\par The following is the modified class CGDIDoc:
\par 
\par (Code omitted)
\par 
\par Besides the three new member variables, there are also three new member functions added to the class. These functions allow the information stored in CGDIDoc to be accessible outside the class, they are CGDIDoc ::GetCurrentFont(), CGDIDoc::GetFontColor() and CGDIDoc::GetBgdStyle().
\par 
\par The above variables are initialized in the constructor of class CGDIDoc:
\par 
\par (Code omitted)
\par 
\par When a DC is created, it selects the default font, pen, brush and other GDI objects. So here we create a DC that does not belong to any window, and call function CDC::GetCurrentFont() to obtain its currently selected font (which is the default font). Then function CFont::GetLogFont(...) is called to retrieve the font information, which is stored in a LOGFONT type object. With this object, we can create a system default font by calling function CFont::CreateFontIndirect(...). By default, the font color is set to black and the text background mode is set to transparent.
\par 
\par We need to provide a way of letting user modify the font styles. This can be easily implemented by using a font common dialog box. In the sample, two commands are added to the application: Font | Select and Font | Escapement and Orientation, whose IDs are ID_FONT_SELECT and ID_FONT_STYLE respectively. Also, message handlers are added through using Class Wizard, the corresponding functions are CGDIDoc::OnFontStyle() and CGDIDoc::OnFontSelect(). 
\par 
\par Function CGDIDoc::OnFontSelect() lets the user select a font, set its styles, and specify the text color. It is impelemented as follows:
\par 
\par (Code omitted)
\par 
\par A font common dialog is implemented to let the user pick up a font. If a font is selected, function CFontDialog::GetCurrentFont(...) is called to retrieve the information of the font, which is stored in a LOGFONT type object. Because member m_fontDraw is already initialized, we need to delete the old font before creating a new one. The font is created by calling function CFont::CreateFontIndirect(...). After this the color of the font is retrieved by calling function CFontDialog::GetColor(), and stored in the variable CGDIDoc::m_colorFont. Finally function CDocument::UpdateAllViews(...) is called to update the client window of the application.
\par 
\par Since font common dialog box does not contain escapement and orientation choices, we have to implement an extra dialog box to let the user set them. In the sample, dialog template IDD_DIALOG_STYLE is added for this purpose. Within this template, besides the default "OK" and "Cancel" buttons, there are two other controls included in the dialog box: edit box IDC_EDIT_ESP, which allows the user to set escapement angle; check box IDC_CHECK, which allows the user to select text background style (transparent or opaque). A new class CStyleDlg is added for this dialog template, within which two variables m_lEsp (long type) and m_bBgdStyle (Boolean type) are declared. Both of them are added through using Class Wizard, and are associated with controls IDC_EDIT_ESP and IDC_CHECK respectively.
\par 
\par Command Font | Escapement and Orientation is implemented as follows:
\par 
\par (Code omitted)
\par 
\par First function CFont::GetLogFont(...) is called to retrieve the information of the current font, which is then stored in a LOGFONT type object. Before the dialog box is invoked, its members CStyleDlg::m_lEsp and CStyleDlg::m_bBgdStyle are initialized so that the current font's escapement angle and background style will be displayed in the dialog box. After function CDialog::DoModal() is called, the new value of CStyleDlg::m_lEsp is stored back to members lfEscapement and lfOrientation of structure LOGFONT, and the new value of CStyleDlg::m_bBgdStyle is stored  to variable CGDIDoc::m_bTransparentBgd. Then the old font is deleted and the new font is created. Finally, function CGDIDoc::UpdateAllViews(...) is called to update the client window.
\par 
\par When we call function CDocument::UpdateAllViews(...), the associated view's member function OnDraw(...) will be called automatically. So we need to modify this function to display the font specified by variable CGDIDoc::m_fontDraw. The following is the implementation of function CGDIView::OnDraw():
\par 
\par (Code omitted)
\par 
\par First, function CGDIDoc::GetCurrentFont() is called to retrieve the currently selected font from the document, then function CFont::GetLogFont(...) is called to retrieve the information of this font (the face name of the font will be used as the output string). Next, the font is selected into the target DC. Also, CGDIDoc::GetFontColor() is called to retrieve the current font color, and CDC::SetTextColor(...) is called to set the text foreground color. Then, CGDIDoc::GetBgdStyle(...) is called to see if the text should be drawn with an opaque or transparent background, and CDC::SetBkMode(...) is called to set the background style. Next, the text background color is set to the inverse of the foreground color by calling function CDC::SetBkColor(...) (If text background style is transparent, this operation has no effect). Finally, function CDC::TextOut(...) is called to display font's face name in the client window, and the font is selected out of the DC.
\par 
\par The default font displayed in the client window should be "System", which is not a True Type font. To see how a text can be displayed with different escapement angles, we need to choose a True Type font such as "Arial". Please note that the unit of the escapement angle is on tenth of a degree, so if we want to display the text vertically, escapement angle should be set to 900.
\par 
\par 9.2\tab Enumerating Fonts in the System
\par 
\par Font Types
\par 
\par There are three type of fonts in Windows( system: raster font, vector font and True Type font. The difference among them is how the character glyph is stored for each type of fonts. For raster fonts, the glyph is simply a bitmap; for vector fonts, the glyph is a collection of end points that define the line segments; for true type fonts, the glyph is a collection of line and curve commands. The raster fonts can not be drawn in a scaled size, they are device dependent (the size of the output depends on the resolution of the device). The vector fonts and true Type Fonts are device independent because they are scalable, however, drawing True Type fonts is faster than drawing vector fonts. This is because the glyph of True Type fonts contains commands and hints.
\par 
\par Enumerating Font Family
\par 
\par We can find out all the font families installed in a system by calling API function ::EnumFontFamilies(...), which has the following format:
\par 
\par int EnumFontFamilies
\par (
\par     HDC hdc, LPCTSTR lpszFamily, FONTENUMPROC lpEnumFontFamProc, LPARAM lParam
\par );
\par 
\par The first parameter hdc is the handle to a device context, which can be obtained from any window. 
\par 
\par The second parameter lpszFamily specifies the font family name that will be enumerated, it could be any of "Decorative", "Dontcare", "Modern", "Roman", "Script" and "Swiss". To enumerate all fonts in the system, we just need to pass NULL to it.
\par 
\par The third parameter is a pointer to callback function, which will be used to implement the actual enumeration. This function must be provided by the programmer.
\par 
\par The final parameter lParam is a user-defined parameter that allows us to send information to the callback function.
\par 
\par The callback function must have the following format:
\par 
\par int CALLBACK EnumFontFamProc
\par (
\par     ENUMLOGFONT FAR *lpelf, NEWTEXTMETRIC FAR *lpntm, int FontType, LPARAM lParam
\par );
\par 
\par Each time a new font family is enumerated, this function is called by the system. So the function will be called for all the available font types (e.g. if there are three types of fonts in the system, this funciton will be called three times by the system). The font's information is stored in an ENUMLOGFONT type object that is pointed by lpelf, and the font type is specified by FontType parameter. We can check RASTER_FONTTYPE or TRUETYPE_FONTTYPE bit of FontType to judge if the font is a raster font or a true type font. The final parameter lParam will be used to store the information that is passed through the user defined parameter (lParam in the function ::EnumFontFamilies(...)).
\par 
\par Sample 9.2\\GDI demonstrates how to enumerate all the valid fonts in the system. It is a standard SDI application generated by Application Wizard. The application will display all the available fonts in the client window after it is executed. Because there are many types of fonts, the view class of this application is derived from CScrollView (This can be set in the final step of Application Wizard).
\par 
\par First, an int type array is declared in class CGDIView:
\par 
\par class CGDIView : public CScrollView
\par \{
\par protected:
\par     int m_nFontCount[3];
\par ......
\par \}
\par 
\par The first element of this array will be used to record the number of raster fonts in the system, the second and the third elements will be used to store the number of vector and true type fonts respectively. The array is initialized in the constructor as follows:
\par 
\par CGDIView::CGDIView()
\par \{
\par     m_nFontCount[0]=m_nFontCount[1]=m_nFontCount[2]=0;
\par \}
\par 
\par We need to create the callback function in order to implement the enumeration. In the sample, a global function ::EnumFontFamProc(...) is declared as follows (This function can also be declared as a static member function):
\par 
\par int CALLBACK EnumFontFamProc(LPLOGFONT, LPNEWTEXTMETRIC, DWORD, LPVOID);
\par 
\par This function is implemented as follows:
\par 
\par (Code omitted)
\par 
\par We will use user-defined parameter lParam in the function ::EnumFontFamilies(...) to pass the address of CGDIView::m_nFontCount into the callback function, so that we can fill the font's information into this array when the enumeration is undergoing. In the callback function, the address of CGDIView:: m_nFontCount is received by parameter pFontCount, which is then cast to an integer type pointer. The font type is retrieved by examining parameter FontType, if the font is a raster font, the first element of CGDIView:: m_nFontCount will be incremented; if the font is a true type font, the third element will be incremented; in the rest case, the font must be a vector font, and the second element will be incremented.
\par 
\par The best place to implement the font enumeration is in function CView::OnInitialUpdate(), when the view is first created. In the sample, a client DC is created and function ::EnumFontFamilies(...) is called. When doing this, we pass the address of CGDIView::m_nFontCount as a user-defined parameter:
\par 
\par (Code omitted)
\par 
\par Still, we need to display the result in function CView::OnDraw(...). In the sample, this function is implemented as follows:
\par 
\par (Code omitted)
\par 
\par We just display three lines of text indicating how many fonts are contained in the system for each different font family.
\par 
\par Enumerating Font
\par 
\par Apart from the above information (how many fonts there are for each font family), we may further want to know the exact properties of every font type (i.e., face name). To implement this, we need to allocate enough memory to store the information of all fonts. Here, the size of this buffer depends on the number of fonts whose properties are to be retrieved. Since each font need a LOGFONT structure to store all its information, we can use the following formulae to calculate the required buffer size:
\par 
\par (sizeof structure LOGFONT) * (number of fonts)
\par 
\par For this purpose, in the sample, another two variables are declared in class CGDIView as follows:
\par 
\par class CGDIView : public CScrollView
\par \{
\par protected:
\par ......
\par     LPLOGFONT m_lpLf[3];
\par     CFont *m_ptrFont;
\par ......
\par \}
\par 
\par Array m_lpLf will be used to store LOGFONT information, and m_ptrFont will be used to store CFont type variables. The variables are initialized in the constructor as follows:
\par 
\par CGDIView::CGDIView()
\par \{
\par ......
\par     m_lpLf[0]=m_lpLf[1]=m_lpLf[2]=NULL;
\par     m_ptrFont=NULL;
\par \}
\par 
\par We need to provide another callback function to retrieve the actual information for each font type. In the sample, this callback function is declared and implemented as follows:
\par 
\par int CALLBACK EnumFontProc(LPLOGFONT, LPNEWTEXTMETRIC, DWORD, LPVOID);
\par 
\par (Code omitted)
\par 
\par Three static variables are declared here to act as the counters for each type of fonts. When this function is called, the information of the font is copied from lplf to the buffers allocated in CGDIView:: OnInitialUpdate(), whose address is passed through user-defined parameter.
\par 
\par In function CGDIView::OnInitialUpdate(), after the font families are enumerated, we need to allocate enough memory, implement the enumeration again for every single type of font:
\par 
\par (Code omitted)
\par 
\par After obtaining the information for each type of font, we create a font using this information by calling function CFont::CreateFontIndirect(...). The addresses of these font objects are stored in array CGDIView::m_ptrFont.
\par 
\par In function CGDIView::OnDraw(...), the face names of all fonts are output to the client window:
\par 
\par (Code omitted)
\par 
\par For each font family, all the font face names are listed. Three loops are used for this purpose. Within each loop, one of the enumerated font is selected into the target DC, and function CDC::TextOut(...) is called to output the font's face name to the window. To avoid text from overlapping one another, a local variable nYPos is used as the vertical orgin of the output text, which will increment each time after a line of text is output to the window.
\par 
\par Because the memory is allocated at the initialization stage, we need to free it when the application exits. In the sample, WM_DESTROY message handler is added to class CGDIView through using Class Wizard, and the corresponding member function is implemented as follows:
\par 
\par (Code omitted)
\par 
\par The application is now ready to enumerate all the available fonts in the system.
\par 
\par 9.3\tab Output Text Using CDC::ExtTextOut(...)
\par 
\par Function CDC::ExtTextOut(...)
\par 
\par Usually we use function CDC::TextOut(...) to output text. There is another powerful function CDC:: ExtTextOut(...), which allows us to output the text to a specified rectange. We can use either transparent or opaque drawing mode. In the latter case, we can also specify a background color. Besides this, we can set the distances between neighboring characters of the text. One version of function CDC::ExtTextOut(...) has the following format:
\par 
\par BOOL CDC::ExtTextOut
\par (
\par     int x, int y,
\par     UINT nOptions, LPCRECT lpRect, const CString &str, LPINT lpDxWidths
\par );
\par 
\par Like CDC::TextOut(...), the first two parameters x and y specify the position of the output text. The third parameter nOptions indicates the drawing mode, it could be any type of combination between ETO_CLIPPED and ETO_OPAQUE flags (Either flag bit can be set or not set, altogether there are four possibilities). Style ETO_CLIPPED allows us to output text within a specified rectangle, and restrict the drawing within the rectangle even if the size of the text is bigger than the rectangle. In this case, all interior part of the rectangle not occupied by the text is treated as background. The third parameter is a CString type value that specifies the actual text we want to output. The last parameter is a pointer to an array of integers, which specify the distances between origins of two adjacent characters. This gives us the control of placing each character within a text string to a specified place. If we pass NULL to this parameter, the default spacing method will be applied.
\par 
\par A very typical use of this function is to implement a progress bar with percentage displayed in it (Figure 9-2). The progress bar is divided into two parts. For one part the text color is white and the background color is blue, for the other part the text color is blue and the background color is white.
\par 
\par New Class
\par 
\par Sample 9.3\\GDI demonstrates how to implement this percentage bar. It is a standard SDI application generated from Application Wizard.
\par 
\par First a new class CPercent is added to the application through using Class Wizard, this class will be used to implement the percentage bar. Here, the base class is selected as CStatic.
\par 
\par The purpose of choosing CStatic as the base class is that by doing this, we can easily use subclass method to change a static control contained in dialog box to a percentage bar. Of course, we can choose other type of controls such as CButton to change a button to a percentage bar.
\par 
\par Two variables m_nRange and m_nCurPos along with two functions are added to class CPercent. Also, WM_PAINT message handler is added to the class through using Class Wizard, and the corresponding member funtion is OnPaint(). The following is this new class:
\par 
\par (Code omitted)
\par 
\par Variable m_nRange indicates the range of the percentage bar, and m_nCurPos indicates the current position. They are initialized in the constructor:
\par 
\par CPercent::CPercent()
\par \{
\par     m_nRange=100;
\par     m_nCurPos=0;
\par \}
\par 
\par Funtions CPercent::SetPercentage(...) and CPercent::SetPosition(...) allow us to change the value of m_nCurPos, and CPercent::SetRange(...) allows us to change the total range.
\par 
\par Within function CPercent::OnPaint(), we will draw the percentage bar using the values of m_nRange and m_nCurPos.
\par 
\par We need to check if m_nRange is zero. If so, we can not draw the percentage bar. If not, we need to first find out the size of the window (the static control window) within which the percentage bar will be drawn. This information is stored in a local variable rect. Next, we create the text string and store it in another local variable szStr, whose format is "XXX%" (XXX represents a number between 0 and 100). To place the text in the center of the rectangle, we need to know its dimension.
\par 
\par To retrieve the dimension of a text string, we need to call function CDC::GetTextExtent(...) and pass the actual string to it. The function will return a CSize type value that specifies the dimension of this text.
\par 
\par The percentage bar is divided into two portions. On the left side of the rectangle, the text color is white and the background color is blue. The following portion of function CPercent::OnPaint() shows how to create text string, set foreground and background colors, and retrieve the dimension of the text:
\par 
\par (Code omitted)
\par 
\par Next, the dimension of the left side rectange of the percentage bar is stored in local variable rectHalf. Then function CDC::ExtTextOut(...) is called to draw the left part of the percentage bar (Mode ETO_CLIPPED is used here, it will restrict the drawing within the rectangle). Because ETO_OPAQUE flag is also used, the text will be drawn with white color and the rest part of rectangle (specified by rectHalf) will all be painted blue:
\par 
\par (Code omitted)
\par 
\par Then we swap the text and background colors, store the right side rectangle in variable rectHalf, and call CDC::ExtTextOut(...) again to draw the rest part of the percentage bar:
\par 
\par (Code omitted)
\par 
\par The last two statements resume the original text color and background color for the device context.
\par 
\par Implementing Percentage Bar
\par 
\par It is very simple to use class CPercent to implement subclass for a static control contained in a dialog box. In the sample, a dialog template IDD_DIALOG is added to the application, it contains an "OK" button and a picture control whose ID is IDC_STATIC_PROG. The control has a modal frame whose color is set to "Gray", this will let the percentage bar have a 3-D effect. The above two styles can be set in the "Picture Properties" property sheet (See Figure 9-3 and Figure 9-4).
\par 
\par Class CProgDlg is added to the application for template IDD_DIALOG. In the class, a CPercent type variable m_perBar along with an integer type variable m_nPercent are declared:
\par 
\par class CProgDlg : public CDialog
\par \{
\par ......
\par protected:
\par     CPercent m_perBar;
\par     int m_nPercent;
\par ......
\par \}
\par 
\par Variable m_perBar will be used to implement percentange bar, and m_nPercent will be used to record the current position of the percentage bar.
\par 
\par Variable m_nPercent is initialized in the constructor:
\par 
\par (Code omitted)
\par 
\par In the sample, WM_INITDIALOG message handler is added to the application through using Class Wizard, and funtion CProgDlg::OnInitDialog() is implemented as follows:
\par 
\par (Code omitted)
\par 
\par Control IDC_STATIC_PROG is changed to a progress bar through implementing subclass, then a timer is started to generate events that will be handled to advance the percentage bar.
\par 
\par To handle time out events, in the sample, a WM_TIMER message handler is added throgh using Class Wizard. The corresponding member function CProgDlg::OnTimer(...) is implemented as follows:
\par 
\par (Code omitted)
\par 
\par If timer times out, we advance the percentage bar one step forward (1%); if the percentage bar reaches 100%, we reset it to 0%.
\par 
\par We must destroy timer when the application exits. The best place of doing this is when we receive WM_DESTROY message. This message handler can also be added through using Class Wizard. In the sample, the corresponding member function is implemented as follows:
\par 
\par void CProgDlg::OnDestroy() 
\par \{
\par     CDialog::OnDestroy();
\par     KillTimer(TIMER_ID);
\par \}
\par 
\par For the purpose of testing the percentage bar, a new command Dialog | Progress is added to the application, whose command ID is ID_DIALOG_PROGRESS. A WM_COMMAND message handler is added to class CGDIDoc for this command, and the corresponding member function CGDIDoc::OnDialogProgress() is implemneted as follows:
\par 
\par void CGDIDoc::OnDialogProgress() 
\par \{
\par     CProgDlg dlg;
\par 
\par     dlg.DoModal();
\par \}
\par 
\par After all these implementations, we can execute command Dialog | Progress to test the percentage bar.
\par 
\par 9.4\tab One-Line Text Editor, Step 1: Displaying a Static String
\par 
\par From now on we are going to implement a very simple one-line text editor: it will display only one line text that can be edited through using mouse and keyboard. We will implement many features of a standard editor such as font selection, changing text styles. The sample application in this section does not introduce any new concept, it is the base of later sections.
\par 
\par Sample 9.4\\GDI is a standard SDI application generated by Application Wizard. Because the horizontal size of the text string may be bigger than that of the client window as the user input more and more characters, we need to add scroll bars to the application. In order to do this, we can choose CScrollView as the base class of the client window in the final step of Application Wizard.
\par 
\par The sample does nothing but displaying a static text in the client window. Other features of text editor will be implemented in later sections.
\par 
\par Two variables m_szText and m_ftDraw along with two member functions are declared in class CGDIDoc:
\par 
\par (Code omitted)
\par 
\par Variable m_szText will be used to store the text string, and m_ftDraw will be used to store the font used for text drawing. Functions CGDIDoc::GetText() and CGDIDoc::GetFont() provide a way of accessing the two member variables outside class CGDIDoc.
\par 
\par Because we still do not have an interactive input environment, in the constructor, variable m_szText is initialized to a fixed string:
\par 
\par CGDIDoc::CGDIDoc()
\par \{
\par     m_szText="This is just a test string";
\par \}
\par 
\par In the sample, function CGDIDoc::OnNewDocument() is modified as follows:
\par 
\par (Code omitted)
\par 
\par This function will be called when the document is initialized. Within the function, variable m_ftDraw is used to create a default font. Since the document is always created before the view, creating the font in this function will guarantee that m_ftDraw will be a valid font when the view is created. This procedure can also be done in the constructor.
\par 
\par To let the user select different types of fonts, a new command Dialog | Font is added to application's mainframe menu IDR_MAINFRAME. The resource ID of this command is ID_DIALOG_FONT and the corresponding message handler is CGDIDoc::OnDialogFont(), which is implemented as follows:
\par 
\par (Code omitted)
\par 
\par After a new font is selected by the user, we delete the old font and create a new one, then call function CDocument::UpdateAllViews(...) to update the client window.
\par 
\par On the view side, we need to modify function CGDIView::OnDraw(...). In this function, the text string and the font are retrieved from the document, and are used to draw text in the client window:
\par 
\par (Code omitted)
\par 
\par With the above implementation, the application will display a static string. Although we still can not input any character, the font for drawing the text can be changed through executing Dialog | Font command.
\par 
\par 9.5\tab One Line Text Editor, Step 2: Adding Caret
\par 
\par Caret Functions
\par 
\par Caret is a very important feature for text editor, it indicates the current editing position. This makes the interface more user friendly. Because there are many types of fonts in the system, and for each font, the width of different characters may vary, we need to make careful calculation before moving the caret to the next position.
\par 
\par Every class derived from the CWnd supports caret, the steps of implementing caret are as follows: 1) Create a caret with specific style. 2) Show the caret. 3) Destroy the caret before the window is destroyed.
\par 
\par The following three member functions can be used to create a caret:
\par 
\par void CWnd::CreateSolidCaret(int nWidth, int nHeight);
\par void CWnd::CreateGrayCaret(int nWidth, int nHeight);
\par void CWnd::CreateCaret(CBitmap *pBitmap);
\par 
\par The first member function allows us to create a solid caret, here parameters nWidth and nHeight specify the dimension of the caret. Similarly, the second function can be used to create a gray caret. The last function can create a caret from a bitmap so that the caret can have a custom pattern.
\par 
\par After the caret is created, we can call function CWnd::ShowCaret() to display the caret or call function CWnd::HideCaret() to hide the caret.
\par 
\par The difficult thing on managing caret is to set its position. Because every character may have a different width, when the user presses arrow keys, we can not advance the caret with fixed distance each time. We must move the caret forward or backward according to the width of the character located before (or after) the caret. In order to do this, we can either calculate the new caret position each time, or we can store the starting position of each character in a table and obtain the caret position from it whenever the caret needs to be moved. In the sample, the latter solution is used.
\par 
\par Sample
\par 
\par Sample 9.5\\GDI demonstrates how to implemnt caret. It is based on sample 9.4\\GDI.
\par 
\par First, some new variables and functions are added to class CGDIDoc for caret implementation:
\par 
\par (Code omitted)
\par 
\par Two variables m_nCaretIndex and m_nCaretVerSize are added. The first variable is the index indicating the position of the caret. The second variable is the caret's vertical size. This is necessary because for fonts with different sizes, we need to create different carets, whose vertical size should be the same with the current font's height.
\par 
\par Five functions are added to the class, among them, function CGDIDoc::GetCaretVerSize() provides us a way of obtaining the current caret's vertical size in class CGDIView; and function CGDIDoc:: GetCaretPosition() converts the caret index to a position within the client window (The function returns a POINT type value). It is implemented as follows:
\par 
\par (Code omitted)
\par 
\par The caret position is calculated through using function CDC::GetTextExtent(...), which will return the vertical and a horizontal size of a text string. We need a DC to select the current font in order to calculate the text dimension. In the sample, first a DC that does not belong to any window is created, then the current font is selected into this DC, and function CString::Left() is called to obtain a sub-string whose last character is located at the current caret position. The horizontal size obtained from function CDC:: GetTextExtent(...) for the sub-string is the caret's horizontal position. Because we have only one line text, the vertical position of the caret is always 0.
\par 
\par This function may be called within the member functions of CGDIView to retrieve the current caret position. The other two functions, CGDIDoc::ForwardCaret() and CGDIDoc::BackwardCaret() can be called to move the caret forward or backward. They are implemented as follows:
\par 
\par (Code omitted)
\par 
\par Instead of calculating the actual position of the caret, we just increment or decrement the caret index. The range of this index is from 0 to the total number of characters (If there are five characters, we have six possible positions for displaying the caret). If the index goes beyond the limit, we set it back to the boundary value.
\par 
\par At the end of above two functions, function CGDIDoc::GetCGDIView() is called to access class CGDIView, then CGDIView::RedrawCaret() is called to update the caret. This will cause the caret to be displayed in a new position. To access a view from the document, we need to call function CDocument:: GetFirstViewPosition() and then call CDocument::GetNextView(...) repeatedly until we get the correct view. For an SDI application, we need to call this function only once. However, some applications may have more than one view attached to the document (Like an MDI application). In this case, we need to use RUNTIME_CLASS macro to judge if the class is the one we are looking for. In the sample, CGDIDoc:: GetCGDIView() is implemented as a general function, it can also be used in an MDI application to obtain a specific view from the document. The following is its implementation:
\par 
\par (Code omitted)
\par 
\par We will implement function CGDIView::RedrawCaret() later.
\par 
\par In the sample, member variable m_nCaretIndex is initialized in the constructor along with m_szText:
\par 
\par CGDIDoc::CGDIDoc()
\par \{
\par     m_szText="This is just a test string";
\par     m_nCaretIndex=0;
\par \}
\par 
\par Also, when the document is first created or when a new font is selected, we need to update the value of m_nCaretVerSize, so functions CGDIDoc::OnNewDocument() and CGDIDoc::OnDialogFont() are updated as follows:
\par 
\par Old version of CGDIDoc::OnNewDocument():
\par 
\par (Code omitted)
\par 
\par New version of CGDIDoc::OnNewDocument():
\par 
\par (Code omitted)
\par 
\par Old version of CGDIDoc::OnDialogFont():
\par 
\par (Code omitted)
\par 
\par New version of CGDIDoc::OnDialogFont():
\par 
\par (Code omitted)
\par 
\par Function CDC::GetOutputTextMetrics(...) is called to obtain the information of the selected font. It will return a lot of information about the font such as its height, average width. This information is stored in a TEXTMETRIC type object, and the font's height can be retrieved from its tmHeight member.
\par 
\par In the above function, CGDIView::CreateNewCaret(...) is called to create a new caret. We will implement this function in the next step. As we will see, passing TRUE to this function will cause the old caret to be destroyed automatically.
\par 
\par In class CGDIView, two new functions are declared (They are called from CGDIDoc::ForwardCaret(), CGDIDoc::BackwardCaret(), CGDIDoc::OnDialogFont()):
\par 
\par (Code omitted)
\par 
\par Function CGDIView::RedrawCaret() will erase the current caret and draw it at the new position. Function CGDIView::CreateNewCaret() will create a new caret and destroy the old one if necessary. The following code fragment shows their implementations:
\par 
\par (Code omitted)
\par 
\par In both functions, we retrieve the caret position from the document. Before moving the caret, we first call function CWnd::HideCaret() to hide the caret. After setting the new position, we call CWnd::ShowCaret() to show the caret again. Also, function CWnd::CreateSolidCaret(...) is called to create the caret, since we pass 0 to its horizontal dimension, the horizontal size of the caret will be set to the default size. The vertical size is retrieved from the document.
\par 
\par We need to create the caret once the view is created, so the default function CGDIView:: OnInitialUpdate() is modified as follows:
\par 
\par (Code omitted)
\par 
\par Here we just call function CGDIView::CreateNewCaret(...) and pass a FALSE value to its parameter because there is no caret needs to be destroyed.
\par 
\par Now we must respond to the events of left arrow and right arrow key strokes. As we know, when a key is pressed, the system will send WM_KEYDOWN message to the application, with the key code stored in WPARAM parameter. Under Windows(, all keys are defined as virtual keys, so there is no need for us to check the actual code sent from the keyboard. In order to know which key was pressed, we can examine WPARAM parameter after WM_KEYDOWN message is received. Here, the virtual key code of the left arrow key and right arrow key are VK_LEFT and VK_RIGHT respectively.
\par 
\par In the sample, WM_KEYDOWN message handler is added to class CGDIView through using Class Wizard, and the corresponding function CGDIView::OnKeyDown(...) is implemented as follows:
\par 
\par (Code omitted)
\par 
\par In this function, WPARAM parameter is mapped to nChar parameter. If the key stroke is from left arrow key, we call CGDIDoc::BackwardCaret() to move the caret leftward. If the key stroke is from right arrow key, we call CGDIDoc::ForwardCaret() to move the caret rightward.
\par 
\par 9.6\tab One Line Text Editor, Step 3: Enabling Input
\par 
\par Sample 9.6\\GDI is based on sample 9.5\\GDI, it allows the user to input characters.
\par 
\par New Member Functions
\par 
\par We need to trap keyboard stroking events in order to let the user input characters. Since our data is stored in the document, we need to first provide some member functions that can be called from the view to let the new characters be added. For this purpose, two new functions are declared in class CGDIDoc:
\par 
\par (Code omitted)
\par 
\par Function CGDIDoc::AddChar(...) allows us to insert characters to the string at the position indicated by  the caret, and function CGDIDoc::DeleteChar(...) allows us to delete the character before or after the caret. Let's first take a look at the implementation of function CGDIDoc::AddChar(...):
\par 
\par (Code omitted)
\par 
\par We divide the text string into two parts, the first part is the sub-string before the caret, and the second part is the sub-string after the caret. The new characters are inserted between the two sub-strings. Parameter uChar indicates the new character, and uRepCnt specifies how many characters will be added. After the character is added, we update the view and move the caret forward.
\par 
\par For function CGDIDoc::DeleteChar(...), it can be used for two situations: one corresponds to "BACK SPACE" key stroke, the other corresponds to "DELETE" key stroke. If parameter bBefore is true, the character before the current caret should be deleted. Otherwise, the character after it needs to be deleted. The following is the implementation of function CGDIDoc::DeleteChar(...):
\par 
\par (Code omitted)
\par 
\par To delete the character before the current caret, we divide the text into two sub-strings, delete the last character of the first sub-string, and re-combine them. Then we update the view, and move caret one character left. When deleting the character after the caret, we do not need to change the position of the caret.
\par 
\par Message WM_CHAR
\par 
\par Now we need to use the above two member functions. In the sample, message WM_CHAR is handled to implement keyboard input. The difference between WM_CHAR and WM_KEYDOWN messages is that WM_CHAR is sent only for printable characters along with the following five keys: ESCAPE, TAB, BACK SPACE and ENTER. Message WM_KEYDOWN will be sent for all types of key strokes.
\par 
\par In the sample, the message handler of WM_CHAR is CGDIView::OnChar(...), it is implemented as follows in the sample:
\par 
\par (Code omitted)
\par 
\par We neglect the ENTER, TAB and ESCAPE key strokes. For BACK SPACE key stroke, we delete the character before the current caret. For all other cases, we insert character at the current caret position.
\par 
\par The DELETE key stroke can not be detected by this message handler, we need to trap and handle it in function CGDIView::OnKeyDown(...):
\par 
\par (Code omitted)
\par 
\par Of course the printable key strokes will also be detected by this message handler. However, if we handle character input in this function, we need to first check if the character is printable. This will make the program a little bit complex.
\par 
\par 9.7\tab One Line Text Editor, Step 4: Caret Moving & Cursor Shape
\par 
\par Sample 9.7\\GDI is based on sample 9.6\\GDI.
\par 
\par New Functions
\par 
\par Besides moving the caret before or after one character at a time, we sometimes need to move the caret to the next or the previous word. This will give the user a faster way of putting the caret at the appropriate position. The method of moving caret to the next or previous word is almost the same with moving it to the next or previous character, the only difference between them is how to calculate the new caret position. Because words are separated by blanks, if we want to move caret one word leftward or rightward, we can just find the previous or next blank, calculate the distance, then move the caret to the new position.
\par 
\par Also, we may want to let the user use HOME key and END key to move the caret to the beginning or the end of the text. Still, almost every text editor supports changing the caret position with a single mouse clicking.
\par 
\par The following new functions are declared in class CGDIDoc to implement above-mentioned functionalities:
\par 
\par (Code omitted)
\par 
\par As implied by the function names, CGDIDoc::HomeCaret() will move the caret to the beginning of the text, CGDIDoc::EndCaret() will move the caret to the end of the text. The implementation of these two functions is very simple, all we need to do is setting m_nCaretIndex to a proper value then updating the caret:
\par 
\par (Code omitted)
\par 
\par For other two functions CGDIDoc::ForwardCaretToBlank() and CGDIDoc::BackwardCaretToBlank(), we need to find out the position of the nearest blank, and set the value of m_nCaretIndex to it:
\par 
\par (Code omitted)
\par 
\par Within the two functions, a local variable szSub is used to store the sub-string before or after the caret, and function CString::Find(...) or CString::ReverseFind(...) is called to find the position of the nearest blank. In case the blank is not found, we need to move the caret to the beginning or end of the text. If it is found, we just increment or decrement m_nCaretIndex by an appropriate value.
\par 
\par On the view side, we need to move the caret when any of the following keys is pressed together with CTRL: HOME, END, Left and Right ARROW. These keystroke events can be trapped by handling WM_KEYDOWN message. To detect if the CTRL key is held down, we can call API function ::GetKeyState(...) to check the key state.
\par 
\par Function ::GetKeyState(...) can be used to check the current state of any key. We need to pass the virtual key code (such as VK_CONTROL, VK_SHIFT...) to this function when making the call. The returned value is a SHORT type integer. The high order of this value indicates if the key is held down, the lower order indicates if the key is toggled, which is applicable to keys such as CAPS LOCK, NUM LOCK or INSERT.
\par 
\par Moving Caret Using Keyboard
\par 
\par Function CGDIView::OnKeyDown(...) is modified as follows to add the new features to the application:
\par 
\par (Code omitted)
\par 
\par Changes are made to VK_LEFT and VK_RIGHT cases. First we call ::GetKeyState(...) using virtual key code VK_CONTROL and extract the high order byte from the return value. If it is non-zero, function CGDIDoc:: BackwardCaretToBlank() or CGDIDoc::ForwardCaretToBlank() is called to move the caret to the nearest blank. Other wise we move the caret one character leftward or rightward.
\par 
\par In case the key is VK_END or VK_HOME, we call function CGDIDoc::EndCaret() or CGDIDoc ::HomeCaret() to move the caret to the beginning or end of the text.
\par 
\par Moving Caret Using Mouse
\par 
\par Moving the caret by mouse clicking is a little bit complex. Because all we can obtain from the message parameter is the mouse's current position, we need to convert it to a caret index before moving the caret. To do so, we need to go over all the starting positions of characters, calculate the absolute distance between each character and the current mouse cursor. The index that results in the smallest distance will be used as the new caret index. In the sample, function CGDIDoc::SetCaret(...) is declared for this purpose, which converts geometrical coordinates to caret index and move the caret to the new place. The following is its implementation:
\par 
\par (Code omitted)
\par 
\par In order to find out all the possible caret positions, we need to obtain the dimension of different sub- strings. For example, the caret positions of text "abcde" can be calculated from the dimensions of following sub-strings: "a", "ab", "abc", "abcd", "abcde". In the above function, first a DC that does not belong to any window is created, then the current font is selected into this DC, and function CDC::GetTextExtent(...) is called to obtain the dimension of each sub-string. Because we have only one line text, only the horizontal size is meaningful to us.
\par 
\par A loop is implemented to do the comparison. For the nth loop, we create a sub-string that contains text's first character to nth character, obtain its dimension, and calculate the distance from the position of the last character of the sub-string to the current position of mouse cursor. After the loop finishes, we choose the smallest distance and set m_nCaretIndex to the corresponding caret index.
\par 
\par Cursor Shape
\par 
\par For a text editor, when the mouse is over its editable area, usually the mouse cursor should be changed to an insertion cursor. This indicates that the user can input text at this time. This feature can also be implemented in our sample application.
\par 
\par To set mouse cursor's shape, we need to call API function ::SetCursor(...). The input parameter to this function is an HCURSOR type handle.
\par 
\par A cursor can be prepared as a resource and then be loaded before being used. After the cursor is loaded, we can pass its handle to function ::SetCursor(...) to change the current cursor shape. Besides the cursor prepared by the user, there also exist some standard cursors that can be loaded directly.
\par 
\par We can call function CWinApp::LoadCursor(...) to load a user-defined cursor, and call function CWinApp::LoadStandardCursor(...) to load a standard cursor. The following table lists some of the standard cursors:
\par 
\par (Table omitted)
\par 
\par In the sample, an HCURSOR type variable is declared in class CGDIView, and the insertion cursor is loaded in function CGDIView::OnInitialUpdate():
\par 
\par class CGDIView : public CScrollView
\par \{
\par protected:
\par     HCURSOR m_hCur;
\par ......
\par \}
\par 
\par void CGDIView::OnInitialUpdate()
\par \{
\par ......
\par     m_hCur=AfxGetApp()->LoadStandardCursor(IDC_IBEAM);
\par \}
\par 
\par We need to respond to WM_SETCURSOR message in order to change the cursor shape. By handling this message, we have a chance to customize the default cursor when it is within the client window of the application. Upon receiving this message, we can check if the mouse position is over the editable text. If so, we need to change the cursor by calling API function ::SetCursor(...). In this case, we need to return a TRUE value and should not call the default message handler. If the cursor should not be changed, we need to call the default message handler to let the cursor be set as usual.
\par 
\par To check out if the cursor is over editable text, we need to know the text dimension all the time. In the previous steps, we already have a variable CGDIDoc::m_nCaretVerSize that is used to store the vertical size of the caret (also the text), so here we just need another variable to store the horizontal size of the text. In the sample, a new variable n_nTextHorSize is declared in class CGDIDoc for this purpose:
\par 
\par (Code omitted)
\par 
\par Besides the new variable, function CGDIDoc::GetTextHorSize() is also added, which lets us access the value of CGDIDoc::m_nTextHorSize outside class CGDIDoc.
\par 
\par We need to set the value of m_nTextHorSize when the document is first initialized and when the font size is changed (In the following two functions, m_nTextHorSize is assigned a new value):
\par 
\par (Code omitted)
\par 
\par Message handler of WM_SETCURSOR can be added through using Class Wizard. The corresponding function CGDIView::OnSetCursor(...) is implemented as follows:
\par 
\par (Code omitted)
\par 
\par We call ::GetCursorPos(...) and CWnd::ScreenToClient(...) to retrieve the current cursor position in the client window's coordinate system. Then functions CGDIDoc::GetTextHorSize() and CGDIDoc:: GetCaretVerSize() are called to retrieve the dimension of the text. If the mouse cursor is within this rectangle, we call ::SetCursor(...) to change it to insertion cursor. In this case, we must return a TRUE value to avoid this message from being further processed (by default the mouse cursor will be set to arrow cursor).
\par 
\par Handling WM_LBUTTONDOWN to Move Caret
\par 
\par The caret can be moved when the current mouse cursor is an insertion cursor. To implement this, we need to call function CGDIDoc::SetCaret(...) after receiving WM_LBUTTONDOWN message. In the sample, this message handler is added through using Class Wizard, and the corresponding function CGDIView:: OnLButtonDown(...) is implemented as follows:
\par 
\par (Code omitted)
\par 
\par In this function, first we check if the mouse cursor is the insertion cursor. If not, it means that the mouse is not over the text string. If so, we call function CGDIDoc::SetCaret(...) and pass current mouse position to it. This will cause the caret to move to the new position.
\par 
\par 9.8\tab One Line Text Editor, Step 5: Selection
\par 
\par Sample 9.8\\GDI is based on sample 9.7\\GDI.
\par 
\par Highlighting the Selected Text
\par 
\par The next feature we will add is to let the user select text using mouse. If this is implemented, it is easy for us to add cut, copy and paste functionalities.
\par 
\par To add the selection feature, we need two new text indices: one indicates the beginning of the selection, one indicates the end of the selection. In the sample, two variables along with two functions are added to class CGDIView for this purpose:
\par 
\par (Code omitted)
\par 
\par Here, variables m_nSelIndexBgn, m_nSelIndexEnd, functions CGDIDoc::GetSelIndexBgn() and CGDIDoc::GetSelIndexEnd() are added to the class. Before the selection is made, there may exist two situations: the text is currently being selected or there is no character being selected. To distiguish between the two situations, let's define that if any of m_nSelIndexBgn and m_nselIndexEnd is -1, or their values are the same, it indicates that there is no text being selected. The two variables are initialized in the constructor as follows:
\par 
\par (Code omitted)
\par 
\par In CGDIView::OnDraw(...), we need to retrieve the values of m_nSelIndexBgn and m_nSelIndexEnd, swap forground and background colors for the selected text when outputting text string to the client window. The following is the modified function CGDIView::OnDraw(...):
\par 
\par (Code omitted)
\par 
\par Two local variables nSelIndexBgn and nSelIndexEnd are declared here, they are used to store the values of CGDIDoc::m_nSelIndexBgn and CGDIDoc::m_nSelIndexEnd retrieved from the document. If the value of CGDIDoc::m_nSelIndexEnd is less than the value of CGDIDoc::m_nSelIndexBgn (In this case, the selection is made from right to left), we need to swap their values. 
\par 
\par If there is no currently selected text, we simply call CDC::TextOut(...) as usual to output the plain text. Otherwise we swap the two indices if m_nSelIndexEnd is less than m_nSelIndexBgn, and set the text alignment by calling function CDC::SetTextAlign(...) using TA_UPDATECP flag. This will cause the output origin to be updated to the end of the text after each CDC::TextOut(...) call. If we do not set this alignment, the coordinates passed to function CDC::TextOut(...) indicate a position relative to the upper-left corner of the window. With TA_UPDATECP alignment style, when we call function CDC::TextOut(...), the coordinates passed to this function will be interpreted as a position relative to the new origin (which is the end of the text that is output by function CDC::TextOut(...) last time). This is very useful if we want to output several segments of strings. In the sample, the old alignment flag is stored in variable uTextAlign, and is restored after the text is output.
\par 
\par We divide the text string into three segments: the first segment starts from the beginning of the text and ends at the beginning of the selection. We output this sub-string using normal text and background colors. The second segment is the selected portion, before drawing this sub-string we need to swap the text and background colors so that the selected part will be drawn highlighted. The rest part is the third sub-string, which is also drawn using the normal text and background colors. Each time function CDC::TextOut(...) is called, the output coordinates are specified as (0, 0). If the alignment flag is not set to TA_UPDATECP, the three segments will all be drawn starting from the same origin.
\par 
\par Setting Selection Indices
\par 
\par Now we can change the values of CGDIDoc::m_nSelIndexBgn and CGDIDoc::m_nSelIndexEnd to highlight any portion of the text string. From user's point of view, this should happen when the mouse is clicked and dragged over the text. In order to implement this, we need to respond to WM_LBUTTONDWON, WM_LBUTTONUP and WM_MOUSEMOVE messages.
\par 
\par When left button is pressed down, we need to first reset the values of CGDIDoc::m_nSelIndexBgn and CGDIDoc::m_nSelIndexEnd to -1, because we need to unselect any currently highlighted text. Then we can update the value of CGDIDoc::m_nSelIndexBgn to the current caret index. When mouse moves with the left button held down, we need to set the value of CGDIDoc::m_nSelIndexEnd to the current caret index (the caret will move with the mouse cursor). The same thing needs to be done when mouse's left button is released. For these purposes, a new function ResetSelection() is declared in class CGDIDoc, which will be called to reset the selection indices. Also, function CGDIDoc::SetCaret(...) is modified. The following is a portion of the updated class CGDIDoc:
\par 
\par (Code omitted)
\par 
\par Function CGDIDoc::ResetSelection() is implemented inline, it just resets the values of m_nSelIndexBgn and m_nSelIndexEnd to -1, then updates the view window. The following shows the modified portion of function CGDIDoc::SetCaret(...):
\par 
\par (Code omitted)
\par 
\par We want to use this function to set both m_nSelIndexBgn and m_nSelIndexEnd, so that it can be called in response to any of the three mouse messages. If the value of m_nSelIndexBgn is -1, it means there is no currently selected text. In this case, we need to update m_nSelIndexBgn (This is the situation that the left button of the mouse is pressed down). In other cases (If m_nSelIndexBgn is not -1, the function must be called in response to mouse moving or left button up event), we need to update the value of m_nSelIndexEnd, then update the client window.
\par 
\par Handling Mouse Events
\par 
\par First function CGDIView::OnLButtonDown(...) is modified as follows:
\par 
\par Old Version:
\par 
\par (Code omitted)
\par 
\par New Version:
\par 
\par (Code omitted)
\par 
\par The only thing added to this function is resetting the selection indices stored in the document. Other changes are implemented in the updated function CGDIView::SetCaret(...).
\par 
\par Two other message handlers for WM_LBUTTONUP and WM_MOUSEMOVE are added through using Class Wizard. The corresponding functions are CGDIView::OnLButtonUp(...) and CGDIView::OnMouseMove(...) respectively.
\par 
\par Function CGDIView::OnMouseMove(...) is implemented as follows:
\par 
\par (Code omitted)
\par 
\par We find out if the left button is held down when the mouse is moving by checking MK_LBUTTON bit of parameter nFlags. If so, function CGDIDoc::SetCaret(...) is called to set the selection and update the client window. Function CGDIView::OnLButtonUp(...) is implemented exactly the same except that we don't need to check the status of left button here:
\par 
\par (Code omitted)
\par 
\par With the above knowledge, it is very easy for us to implement selection by using left/right ARROW key when SHIFT key is held down. To implement this, we need to check SHIFT key's status when either left or right ARROW key is pressed. If it is held, we can update the selection indices and redraw the client window.
\par 
\par 9.9\tab One Line Text Editor, Step 6: Cut, Copy and Paste
\par 
\par Global Memory
\par 
\par Cut, copy and paste are supported almost by every application. They provide a way to exchange data among different applications. We must use globally shared data to implement clipboard data transfer. Once we send some data to the clipboard, it becomes public and can be accessed by all the programs. Any process in the system can clear the clipboard.
\par 
\par Because of this, we must allocate global memory to store our data in the clipboard. In Windows( programming, the following API functions can be used to manage global memory:
\par 
\par HGLOBAL ::GlobalAlloc(UINT uFlags, DWORD dwBytes);
\par LPVOID ::GlobalLock(HGLOBAL hMem);
\par HGLOBAL ::GlobalReAlloc(HGLOBAL hMem, DWORD dwBytes, UINT uFlags);
\par BOOL ::GlobalUnlock(HGLOBAL hMem);
\par HGLOBAL ::GlobalFree(HGLOBAL hMem);
\par 
\par Global memory is also managed through using handle. Unlike memory allocated using new key word, function ::GlobalAlloc(...) returns an HGLOBAL type handle to the allocated memory block if we allocate non-fixed global memory.
\par 
\par Generally, before accessing a non-fixed block of global memory, we must lock it by calling function ::GlobalLock(...), which will return the address of the memory block. After reading from or writing to this memory block, we need to call function ::GlobalUnlock(...) to unlock the memory again. We can free a block of global memory by calling function ::GlobalFree(...) (We can not free a block of memory when it is being locked). 
\par 
\par We can also allocate fixed global memory, in which case the address of the memory will be returned by function ::GlobalAlloc(...) directly, and we do not need lock or unlock operation in order to access the memory.
\par 
\par Parameter nFlags of function ::GlobalAlloc(...) specifies how the memory will be allocated. There are many possible choices. For example, we can make the memory movable or fixed, and fill all the buffers with zero. The following is a list of some commonly used flags:
\par 
\par (Table omitted)
\par 
\par The most commonly used flag is GHND, which specifies that the memory block should be movable and all buffers should be initialized to zeros. For the clipboard usage, we also need to specify flag GMEM_SHARE, which will enhance the performance of clipboard operation.
\par 
\par Actually, in Win32 programming, the memory block allocated by one process can not be shared by other processes. Flag GMEM_SHARE exists just for the backward compatibility purpose. For a general application, we can not allocate a block of memory using flag GMEM_SHARE and share it with other applications. In Win32, this flag is solely used for clipboard and DDE (see chapter 15) implementation.
\par 
\par The memory size that will be allocated is specified by dwBytes parameter of function ::GlobalAlloc(...).
\par 
\par Apart from these functions, there is another set of functions whose functionality is exactly the same, the only difference is that they have a different set of function names:
\par 
\par HLOCAL ::LocalAlloc(UINT uFlags, UINT uBytes);
\par LPVOID ::LocalLock(HLOCAL hMem);
\par HLOCAL ::LocalReAlloc(HLOCAL hMem, UINT uBytes, UINT uFlags);
\par BOOL ::LocalUnlock(HLOCAL hMem);
\par HLOCAL ::LocalFree(HLOCAL hMem);
\par 
\par Everything is exactly the same except that all the "Global" keywords are changed to "Local" here. These functions are originated from the old Win16 programming, which uses 16-bit memory mode. In that case the memory can be allocated either from the local heap or global heap. In Win32 programming, there is only one heap, so two sets of functions become exactly the same. They exist just for the compatibility purpose. We can use either of them in our program. We can even call ::GlobalAlloc(...) to allocate memory and release it using ::LocalFree(...).
\par 
\par Clipboard Funcitons
\par 
\par To copy our own data to the clipboard, we need to first prepare the data. The following lists the necessary steps for allocating memory blcok and fill it with our data: 1) Allocate enough buffers by calling function ::GlobalAlloc(...). 2) Lock the memory by calling function ::GlobalLock(...), which will return a pointer that can be used to access the memory buffers. 3) Fill these buffers with data. 4) Call ::GlobalUnlock(...) to unlock the memory.
\par 
\par We need to use a series of functions in order to put the data to the clipboard: 1) First we need to call function CWnd::OpenClipboard(...), which will let the clipboard be owned by our application (Only the window that owns the clipboard can modify the data contained in the clipboard, any other application is forbidden to access the clipboard during this period). 2) Before putting any data to the clipboard, we must call ::EmptyClipboard() to clear any existing data. 3) We can call ::SetClipboardData() to put new data to the clipboard. 4) Finally we need to call ::CloseClipboard() to close the clipboard, this will let the clipboard be accessible to other windows. 
\par 
\par When calling function ::SetClipboardData(...), besides passing the handle of the global memory, we also need to specify the data format. There are many standard clipboard data formats such as CF_TEXT, CF_DIB, which represent text data and bitmap data respectively. We can also define our own data format by calling function ::RegisterClipboardFormat(...).
\par 
\par To copy data from the clipboard, we need to open the clipboard first, then call function ::GetClipboardData(), which will return a global memory handle. With this handle, we can call ::GlobalLock(...) to lock the memory, copy the data from the global memory to our own buffers, call ::GlobalUnlock(...) to unlock the memory, and close the clipboard. We can not free the global memory obtained from the clipboard because after the clipboard is closed, some other applications may also want to access it.
\par 
\par Deleting Selected Text
\par 
\par Sample 9.9\\GDI is based on sample 9.8\\GDI, it allows the user to cut or copy the selected text to the clipboard, and paste the data from clipboard.
\par 
\par When we cut data to the clipboard, we also need to delete the selected text. So first a new function DeleteSelection() is declared in class CGDIDoc, it can be called to delete the currently selected text:
\par 
\par class CGDIDoc : public CDocument
\par \{
\par ......
\par public:
\par ......
\par     BOOL DeleteSelection();
\par ......
\par \}
\par 
\par Function CGDIDoc::DeleteSelection() is implemented as follows:
\par 
\par (Code omitted)
\par 
\par When there is no currently selected text, the function does nothing. Otherwise we proceed to delete the selected text.
\par 
\par Because the ending selection index may be less than the beginning selection index, first we set the value of local variable nSel to the smaller selection index, and set the number of selected characters to another local variable nNum. Then the unselected text is combined together, and the caret index is adjusted. Next the caret and the client window are updated. Finally, both selection indices are set to -1, this indicates that currently there is no text being selected.
\par 
\par We can call this function when DELETE key is pressed to delete the selected text, also we can call it when the selected text is being cut to the clipboard. In the sample, function CGDIDoc::DeleteChar() is modified as follows:
\par 
\par (Code omitted)
\par 
\par Since this member function may be called when either BACK SPACE or DELETE key is pressed, we need to delete the selected text in both cases. If deleting the selected text is successful, the function will return. Otherwise it means there is no currently selected text, so we go on to delete a single character.
\par 
\par Message Handlers for Cut, Copy Paste Commands
\par 
\par In the sample, both WM_COMMAND and UPDATE_COMMAND_UI message hanlders are added for command ID_EDIT_CUT, ID_EDIT_COPY and ID_EDIT_PASTE in class CGDIDoc. We need to enable commands Edit | Copy and Edit | Cut if there is selected text. So functions CGDIDoc::OnUpdateEditCopy(...) and CGDIDoc::OnUpdateEditCut(...) are implemented as follows:
\par 
\par (Code omitted)
\par 
\par Two functions are implemented exactly the same. For function CGDIDoc::OnUpdateEditPaste(...), we need to check if there is data available in the clipboard, if so, the command will be enabled. This checking can be implemented by calling function ::IsClipboardFormatAvailable(...) with appropriate data format passed to it. The function will return FALSE if there is no data present in the clipboard for the specified data format. The following is the implementation of funcition CGDIDoc::OnUpdateEditPaste(...):
\par 
\par (Code omitted)
\par 
\par Command Edit | Copy is implemented as follows:
\par 
\par (Code omitted)
\par 
\par First, we assign the smaller of the two selection indicies to variable nSel, and the number of selected characters to variable nNum. Then we copy the selected text to a CString type variable szStr. Next, we allocate a memory block, lock it, copy the string from szStr to the new buffers. Then we unlock the memory, open the clipboard, clear it, and copy the data to the clipboard. Finally we close the clipboard.
\par The implmentation of Edit | Cut command is almost the same except that we must delete the selected text after copying the data to the clipboard. So function CGDIDoc::OnEditCut() is implemented as follows:
\par 
\par (Code omitted)
\par 
\par For Edit | Paste command, everything is the reverse. We need to open the clipboard, obtain data from the clipboard, lock the global memory, copy the data to local buffers, unlock the global memory, and insert the new string to the text at the current caret position. The following is the implementation of this command:
\par 
\par (Code omitted)
\par 
\par Now the application can exchange data with another application that supports clipboard.
\par 
\par 9.10\tab One Line Text Editor, Step 7: Getting Rid of Flickering
\par 
\par The editor is almost finished except for one annoying feature: every time the user inputs a character, makes selection or moves the caret, the text will flicker. This is because whenever the text is being updated, we call function CDocument::OnUpdateAllViews(...) to cause the whose view window to be updated. By default, before the client window is redrawn, it will be erased using white color. This is the cause of flickering. To get rid of it, we need to update only the area that has changed (instead of updating the whole window).
\par 
\par Function CDocument::UpdateAllViews(...)
\par Function CDocument::UpdateAllViews(...) has three parameters, two of which have default values:
\par 
\par void CDocument::UpdateAllViews(CView *pSender, LPARAM lHint=0L, CObject *pHint=NULL);
\par 
\par By default, the update message will be sent to view, this will cause function CView::OnUpdate(...) to be called:
\par 
\par void CView::OnUpdate(CView *pSender, LPARAM lHint, CObject *pHint);
\par 
\par All parameters passed to CDocument::UpdateAllViews(...) will be passed to this function. This provides us a way to know what part of the client window needs to be updated. The updating hint can be passed through either parameter lHint or pHint.
\par 
\par By default, CView::OnUpdate(...) will update the whole client area. If we want only a portion of the client window to be updated, we need to bypass the default implementation. Within the overridden funciton, we can use the hint to form a rectangle indicating the area needs to be updated, and use it to call function CWnd::InvalidateRect(...).
\par 
\par Function CWnd::InvalidateRect(...) will cause only the specified rectangular area to be updated.
\par 
\par Defining Hints
\par 
\par Our next task is to divide the updating events into different categories and calculate the rectangle for each situation. The following is a list of situations when only a portion of the client window needs to be updated:
\par 
\par (Table omitted)
\par 
\par The last two situations are a little complicated. When the user makes selections, the newly selected area may be smaller or larger than the old selected area. In either case, we only need to update the changed area to avoid flickering (Figure 9-5).
\par 
\par Because of this, we need to add new variables to remember the old selection indices. In the sample, two new variables and some functions are declared in class CGDIDoc as follows:
\par 
\par (Code omitted)
\par 
\par Variables m_nSelIndexBgnOld and m_nSelIndexEndOld are used to remember the old selection indices, functions GetSelIndexBgnOld() and GetSelIndexEndOld() are used to obtain their values outside class CGDIDoc. Because we also need to know the value of m_nCaretIndex when updating the client window, another function GetCaretIndex() is also added for retrieving its value.
\par 
\par The value of m_nSelIndexEndOld is initialized in the constructor:
\par 
\par CGDIDoc::CGDIDoc()
\par \{
\par ......
\par     m_nSelIndexEndOld=-1;
\par \}
\par 
\par In the sample, some macros are defined as follows to indicate different updating situations when function CDocument::UpdateAllViews(...) is called:
\par 
\par #define HINT_DELCHAR_AFTER\tab \tab \tab 100
\par #define HINT_DELCHAR_BEFORE\tab \tab 101
\par #define HINT_DELETE_SELECTION\tab \tab 102
\par #define HINT_PASTE\tab \tab \tab \tab 103
\par #define HINT_SELECTION\tab \tab \tab 104
\par #define HINT_UNSELECTION\tab \tab \tab 105
\par #define HINT_INPUT\tab \tab \tab \tab 106
\par 
\par Calling Function CDocument::UpdateAllViews(...)
\par 
\par We must modify all the function calls to CDocument::UpdateAllViews(...). The following shows the modifications made to function CGDIDoc::SetCaret(...):
\par 
\par Old Version:
\par 
\par (Code omitted)
\par 
\par New Version:
\par 
\par (Code omitted)
\par 
\par In this function, the value of m_nSelIndexEnd is first assigned to m_nSelIndexEndOld before it is updated. Flag HINT_SELECTION will cause the difference between the newly selected area and the old one to be updated. The area can be calculated from the four selection indices.
\par 
\par The following shows the modifications made to function CGDIDoc::AddChar(...):
\par 
\par Old Version:
\par 
\par (Code omitted)
\par 
\par New Version:
\par 
\par (Code omitted)
\par 
\par Flag HINT_INPUT will cause all the characters after the caret to be updated.
\par 
\par The following shows the modifications made to funciton CGDIDoc::DeleteChar(...):
\par 
\par Old Version:
\par 
\par (Code omitted)
\par 
\par New Version:
\par 
\par (Code omitted)
\par 
\par Flag HINT_DELCHAR_AFTER will cause all the characters after the caret to be updated, and HINT_DELCHAR_BEFORE will cause the character before the caret along with all the characters after the caret to be updated.
\par 
\par The following shows the modifications made to function CGDIDoc::DeleteSelection():
\par 
\par Old Version:
\par 
\par (Code omitted)
\par 
\par New Version:
\par 
\par (Code omitted)
\par 
\par Flag HINT_DELETE_SELECTON will cause the selected text and the characters after the selection to be updated.
\par 
\par The following shows the modifications made to function CGDIDoc::OnEditPaste():
\par 
\par Old Version:
\par 
\par (Code omitted)
\par 
\par New Version:
\par 
\par (Code omitted)
\par 
\par Flag HINT_PASTE will cause all the characters after the caret to be updated.
\par 
\par The following shows the modifications made to inline function CGDIDoc::ResetSelection():
\par 
\par Old Version:
\par 
\par (Code omitted)
\par 
\par New Version:
\par 
\par (Code omitted)
\par 
\par Flag HINT_UNSELECTION will cause only the selected area to be updated. Because both m_nSelIndexBgn and m_nSelIndexEnd should be set to -1 to indicate that there is no selected text anymore, we need to use two other variables (m_nSelIndexBgnOld and m_nSelIndexEndOld) to store the old selection indices.
\par 
\par Overriding CView::OnUpdate(...)
\par 
\par On the view side, function OnUpdate(...) can be added through using Class Wizard. In this function, we need to know the current values of CGDIDoc::m_nSelIndexBgn, CGDIDoc::m_nSelIndexEnd, CGDIDoc:: m_nSelIndexBgnOld, CGDIDoc::m_nSelIndexEndOld and CGDIDoc::m_nCaretIndex in order to decide which part of the text should be updated. We also need to obtain the current font and text string in order to calculate the actual rectangle for implementing update.
\par 
\par If parameter lHint is NULL, it means that all client area needs to be updated. In this case, we call the default implementation of this function and return. The following is a portion of funciton CGDIView:: OnUpdate(...) which implements this:
\par 
\par (Code omitted)
\par 
\par If parameter lHint is non-null, we need to obtain the current font, text string and selection indices from the document, and calculate the area that should be updated. Here variable rect stores a rectangle that covers all of the text (within the window).
\par 
\par In the case when hint is one of HINT_DELCHAR_AFTER, HINT_PASTE and HINT_INPUT, we need to update all the characters after the caret:
\par 
\par (Code omitted)
\par 
\par The caret index is retrieved from the document and stored to variable nIndex. Then the sub-string before the caret is extracted and stored to variable szText. Its dimension is calculated by calling function CDC::GetTextExtent(...), and the left border of rect is changed so that it covers only the characters after the caret. Finally, function CWnd::InvalidateRect(...) is called and rect is passed to one of its parameters.
\par 
\par If the hint is HINT_DELCHAR_BEFORE, we need to update the character before the caret and all the characters after the caret:
\par 
\par (Code omitted)
\par 
\par If the hint is HINT_DELETE_SELECTION, we need to update the selected text as well as the characters after the selection:
\par 
\par (Code omitted)
\par 
\par If the hint is HINT_UNSELECTION, we need to update only the selected text. Since both CGDIDoc:: m_nSelIndexBgn and CGDIDoc::m_nSelIndexEnd are -1 now, we must use CGDIDoc::m_nSelIndexBgnOld and CGDIDoc::m_nSelIndexEndOld to calculate the rectangle:
\par 
\par (Code omitted)
\par 
\par If the hint is HINT_SELECTION, we must check if CGDIDoc::nSelIndexEndOld is -1 or not. If it is -1, it means that the area needed to be updated is between CGDIDoc::nSelIndexBgn and CGDIDoc::nSelIndexEnd; if not, the area needed to be updated is between CGDIDoc::nSelIndexEnd and CGDIDoc::nSelIndexEndOld (See Figure 9-6):
\par 
\par (Code omitted)
\par 
\par If we pass FALSE to the second parameter of CWnd::InvalidateRect(...), the client area will be updated without being erased. This can further reduce flickering.
\par 
\par Summary:
\par 
\par 1)  Font can be created from structure LOGFONT. We need to provide the following information when creating a special font: face name, font size (height and width). To add special effects to the text, we need to know if the font is bolded, italic, underlined or strikeout. Also, we can change character's orientation by setting font's escapement.
\par 
\par 2)  All the fonts contained in the system can be enumerated by calling function ::EnumFontFamilies(...). We need to provide a callback function to receive information for each type of font.
\par 
\par 3)  Function CDC::ExtTextOut(...) can output a text string within a specified rectangle, the area outside the rectangle will not be affected no matter what the text size is. When we call this function, all the area not covered by the text within the rectangle is treated as the background of the text.
\par 
\par 4)  To implement caret within a window, first we need to create the caret by using one of the following functions: CWnd::CreateSolidCaret(...), CWnd::CreateGrayCaret(...), CWnd::CreateCaret(...). Then we can show or hide the caret by calling either function CWnd::ShowCaret() or CWnd::HideCaret().
\par 
\par 5)  Keyboard input events can be trapped by handling WM_KEYDOWN or WM_CHAR message.
\par 
\par 6)  Mouse cursor can be changed by handling message WM_SETCURSOR. We can load a user designed cursor resource by calling function CWinApp::LoadCursor(...). We can also load a standard cursor by calling function CWinApp::LoadStandardCursor(...).
\par 
\par 7)  If we call function CDC::SetTextAlign(...) using TA_UPDATECP flag, the window origin will be updated to the end of the text each time funciton CDC::TextOut(...) is called.
\par 
\par 8)  To use global memory, we need to call ::GlobalAlloc(...) to allocate the buffers, call ::GlobalLock(...) to lock the memory before accessing it, call ::GlobalUnlock(...) to stop accessing the memory, and call ::GlobalFree(...) to release the memory.
\par 
\par 9)  To access the clipboard, we need to call CWnd::OpenClipboard(...) to open the clipboard, call ::EmptyClipboard() to clear any existing data, call ::SetClipboardData() to put data to the clipboard, and call ::CloseClipboard() to close the clipboard. To get data from the clipboard, after opening it, we need to call function ::GetClipboardData() to obtain a global memory handle, which can be used for accessing the data contained in the clipboard.
\par 
\par 10)  We can pass hints to function CDocument::UpdateAllViews(...) to indicate different updating situations. The hint can be received in function CView::OnUpdate(...). If we want only a portion of the client window to be updated, we can specify the area with a CRect type variable and use it to call function CWnd::InvalidateRect(...) instead of default function CWnd::Invalidate(...).
\par 
\par }
 