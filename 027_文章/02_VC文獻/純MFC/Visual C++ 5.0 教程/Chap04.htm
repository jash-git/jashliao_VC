<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb_2312-80">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>第四章 基于对话框的应用程序</TITLE>
<META NAME="Template" CONTENT="D:\Office95\Template\Manuscripts\32开图书模板.dot">
</HEAD>
<BODY>

<FONT FACE="黑体" LANG="ZH-CN" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc425696867">第四章</FONT><FONT FACE="Arial" SIZE=5> </FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=5>基于对话框的应用程序</A></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">从本章我们将学习如何使用</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进行真正意义上的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序设计。对于编程者来说，最简单的实用程序应该是本章所要讲述的基于对话框的应用程序。当然，我们已在前面的章节中介绍了基于包括用户区的一般窗口的最简单的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>程序，相比本章将要讲述的程序来说，它们还要更简单一些。但是要记住，在前面讲述的这些应用程序中，我们没有实现任何实际的功能。事实上，在这些应用程序中，实现一些哪怕是很简单的功能也需要很多的代码量。举一个例子，如果我们需要在用户区绘制图形或文本的话，就需要为</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息</FONT><FONT SIZE=3>WM_PAINT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编写消息处理函数。一个实用的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序的</FONT><FONT SIZE=3>WM_PAINT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的消息处理过程常常会很庞大和很复杂。而对于在这章将要讲述的基于对话框的应用程序来说，整个应用程序都是由一个或多个对话框</FONT><FONT SIZE=3>(dialog box)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>组成，对话框只是作为其它一些行为标准化了的窗口</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>我们叫它们控件</FONT><FONT SIZE=3>(control))</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的容器，其行为也是标准化了的。这样，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就可以为这些行为标准化了的窗口实现很多默认的操作，而不需要我们进行更多的干预。比如对于一个文本框，我们只需要预先设定文本框的文字及其它一些属性，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就可以知道在不同的情况下这个文本框应该进行什么样的操作，因为它的行为，如编辑和选定文本等，都已经是标准化了的。虽然各种各样的控件各有各的特点，但是，对于一类控件来说，它们的行为在某种意义是一致的。（从这个意义上来说，这是面向对象程序设计的很大程度上的优点所在。）</P>
<P ALIGN="JUSTIFY">使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编写的对话框应用程序和使用</FONT><FONT SIZE=3>SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编写的对话框应用程序在结构上有着很大的不同。对于使用</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的程序员来说，我们有充分的理由使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来编写这些应用程序，因此，我们在这里将不讲述如何使用</FONT><FONT SIZE=3>SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编写的基于对话框的应用程序。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">本章涉及的内容包括：</P>

<UL>
<P ALIGN="JUSTIFY"><LI>使用</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>生成基于对话框的框架应用程序</LI></P>
<P ALIGN="JUSTIFY"><LI>由</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生的应用程序类</LI></P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY"><LI>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的消息映射机制及其实现</LI></P>
<P ALIGN="JUSTIFY"><LI>对话框及由</FONT><FONT SIZE=3>CDialog</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生的对话框类</LI></P></UL>

</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER"><A NAME="_Toc425696868">第一节</FONT><FONT SIZE=4> </FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>使用</FONT><FONT SIZE=4>AppWizard</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>生成应用程序框架</A></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在编写</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序时，我们通常使用</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来生成应用程序框架，然后再在此框架的基础上来添加特定于应用程序的功能的实现。在计算机术语中，</FONT><FONT SIZE=3>Wizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>通常被译作向导</FONT><FONT SIZE=3>(AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>即应用程序向导</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，它是这样的一种程序：你只需要回答一系列的与你所需完成的操作有关的问题，</FONT><FONT SIZE=3>Wizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就会自动的完成其余的步骤，而这些步骤如果通过手工来完成的话，将可能会耗费相当长的时间和精力（但同时我们也要向你指出，</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所能够帮助你完成的，也只是一个应用程序的框架。它所建立的，在绝大部分是我们在</FONT><FONT SIZE=3>Windows </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>下程序设计中所需要完成的例行化的工作）。在</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，一种被称作</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的向导，通过向你询问一些关于所需编写的应用程序各项特性的问题，即可按照程序员的要求生成相应的框架文件，这些框架文件本身就构成了一个完整的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序，它实现了绝大多数同类型的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所<B>共有</B>的一些特性和功能。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>我们还想说明的一点是：</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>能够帮助我们建立起一个应用程序的框架，但绝大多数的应用程序的代码还需要我们亲自编写。我们还从来没有看到仅仅通过</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的代码就生成了一个成功的程序。明白这一点是很重要的：</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>所做的，只不过是我们在程序设计过程中所需要的最没有创意的那一部分事情。</LI></P></UL>
<DIR>
<DIR>

<P ALIGN="JUSTIFY">真正应该引起我们更多的重视的，是</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的可视化的界面生成。要知道，在可视化编程出现以前，为了一个简单的框架，程序员不得不重复干一些相当烦琐的工作：仅仅是为了安排好一个对话框中的控件的位置，他们就不得不先在稿纸上试着画布局图，写入程序，运行，再修改，再运行。。。。你可以想见，这是一件多么烦琐乏味的工作！</P>
<P ALIGN="JUSTIFY">最后我们想提醒你，如果你不需要一个标准的</FONT><FONT SIZE=3>Windows </FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>程序界面或者不需要</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>所提供的文档</FONT><FONT SIZE=3>/</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>视结构，使用</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>并不一定是一个明智的选择。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">　</P></DIR>
</DIR>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image231.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image231.gif" WIDTH=481 HEIGHT=312></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>4. 1 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>新建工程</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">使用</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是一件简单和愉快的事情，并且，明白</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所能完成的和所不能完成的内容会在编程时少走很多的弯路，因此，我们将在下面的过程中详细的讲述如何使用</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>创建基于对话框的应用程序：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">1.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>选择文件菜单下的</FONT><FONT SIZE=3>New</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>命令（出于排版方面的一些考虑，我们将参考图形进行了一定程度的处理</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，如图</FONT><FONT SIZE=3>4.1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">2.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从</FONT><FONT SIZE=3>New</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对话框中选择</FONT><FONT SIZE=3>Project</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>选项卡。在</FONT><FONT SIZE=3>Project name</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处输入工程名，一般来说，工程的命名在一定程度上是任意的，这里我们假定工程名为</FONT><FONT SIZE=3>DialogDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，在</FONT><FONT SIZE=3>Location</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处输入保存工程的文件夹。然后在左边的列表中确信选择了</FONT><FONT SIZE=3>MFC AppWizard (exe)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，在</FONT><FONT SIZE=3>Platform</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>列表中确信选择了</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。完成之后单击</FONT><FONT SIZE=3>OK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进入下一步。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">3.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>随后弹出如图</FONT><FONT SIZE=3>4.2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示的对话框。在该对话框中选择应用程序类型为</FONT><FONT SIZE=3>Dialog based</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，即基于对话框的应用程序。还可以在下面的下拉列表框中选择应用程序资源所使用的语言。这里我们选择了简体中文，即“中文</FONT><FONT SIZE=3>[</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中国</FONT><FONT SIZE=3>](APPWZCHS.DLL)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”。这样，</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为应用程序自动创建的所有资源都将是中文的。单击</FONT><FONT SIZE=3>Next</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进入下一步。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image232.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image232.gif" WIDTH=452 HEIGHT=303></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>4. 2 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>使用</FONT><FONT SIZE=1>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>创建基于对话框的应用程序：第一步</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>在默认情况下，安装</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>时并没有安装支持远东语言的动态链接库，这些语言包括简体中文、繁体中文、日文和韩文等，对这些语言的支持需要相应的双字节的操作系统。因此，在如图</FONT><FONT SIZE=3>4.2</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>所示的</FONT><FONT SIZE=3>MFC AppWizard</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>对话框中将不会看到这些语言的选择项。为了添加对这些语言的支持，我们必须手动的将它们添加</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的安装目录下。这些语言的支持文件在</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>安装光盘上的\</FONT><FONT SIZE=3>DevStudio\SharedIDE\Bin\IDE</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>目录下，不同的语言所对应的动态链接库的</FONT><FONT SIZE=3>.DLL</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>文件名如表</FONT><FONT SIZE=3>4.1</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>所示。</LI></P></UL>

<P ALIGN="JUSTIFY">　</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>4. 1 </FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>不同的远东语言所对应的支持文件</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=241>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">语言</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">支持该语言的动态链接库</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">中文</FONT><FONT SIZE=1>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>简体</FONT><FONT SIZE=1>)</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">APPWZCHS.DLL</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">中文</FONT><FONT SIZE=1>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>繁体</FONT><FONT SIZE=1>)</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">APPWZCHT.DLL</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">日文</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">APPWZJPN.DLL</FONT></TD>
</TR>
<TR><TD WIDTH="34%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">韩文</FONT></TD>
<TD WIDTH="66%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">APPWZKOR.DLL</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P><DIR>
<DIR>

<P ALIGN="JUSTIFY">如果在你的</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中还没有添加对上面的这些语言的支持文件，可以将它们从光盘上的\</FONT><FONT SIZE=3>DevStudio\SharedIDE\Bin\IDE</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>目录中将它们复制到对应的</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>安装目录下，举个例子说，如果你的</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>被安装到</FONT><FONT SIZE=3>D:\Program Files\DevStudio</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>目录下，对应的目录将是</FONT><FONT SIZE=3>D:\Program Files\Devstudio\SharedIDE \Bin\IDE</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。然后再在操作系统中安装对应的代码页。在很多情况下，我们还需要重新启动</FONT><FONT SIZE=3>Developer Studio</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>或操作系统。</P></DIR>
</DIR>


<UL>
<P ALIGN="JUSTIFY"><LI>如果应用程序使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的动态链接，还必须有相对应的</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>资源动态链接库的本地化版本，它们位于</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>系统目录下，且具有</FONT><FONT SIZE=3>MFC40LOC.DLL</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的文件名。可以将</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>安装光盘上的</FONT><FONT SIZE=3>MFC\include\L.XXX\MFC40XXX.DLL </FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>目录下的对应</FONT><FONT SIZE=3>DLL</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>文件复制到</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的系统目录下，然后将其改名为</FONT><FONT SIZE=3>MFC40LOC.DLL</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。详细的内容可以参考帮助中的</FONT><FONT SIZE=3>Microsoft Foundation Class Reference\MFC Technical Notes</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>节点下的文章</FONT><FONT SIZE=3>TN056</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>TN057</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。</LI></P>
<P ALIGN="JUSTIFY"><LI>如果你使用的是</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的专业版或企业版，还可以在应用程序中使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的静态链接。这时，需要在</FONT><FONT SIZE=3>MFC\[src|include]\L.XXX\*.rc</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>目录下有正确的本地化的</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>资源文件。这些文件可以在</FONT><FONT SIZE=3>Visual Studio</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的第一章安装光盘上的对应目录中找到。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">4.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在如图</FONT><FONT SIZE=3>4.3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示的对话框中为应用程序选择合适的特性。该对话框中各选项的含义如下：</P></FONT>
<P ALIGN="RIGHT"><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=538>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=3><P ALIGN="JUSTIFY">About box</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>：</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">如果选择了该选项，</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>将为一个被称为“关于”对话框的消息框生成代码，该消息框用来显示应用程序的版本号和版权信息等。绝大多数的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序都具有一个关于对话框，图</FONT><FONT SIZE=3>4.4</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是</FONT><FONT SIZE=3>Microsoft Word 95</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的“关于”对话框。在默认情况下，使用</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>创建的应用程序，都具有一个“关于”对话框。</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=3><P ALIGN="JUSTIFY">Context-sensitive help</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>：</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">该选项决定是否让</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为应用程序创建上下文相关的帮助文件。需要注意的是，对帮助的支持需要帮助编译器</FONT><FONT SIZE=3>(help compiler)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，如果在你的</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中没有安装帮助编译器的话，可以重新运行</FONT><FONT SIZE=3>Setup</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>程序来安装它。</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=3><P ALIGN="JUSTIFY">3D controls</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>：</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">决定是否在应用程序中使用具有三维阴影的用户界面。使用了三维外观的应用程序界面看起来象那些在</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的早期版本</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如</FONT><FONT SIZE=3>Windows 3.x)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>下运行的程序的外观。默认情况下，使用</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>创建的应用程序都具有三维外观。</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=3><P ALIGN="JUSTIFY">Automation</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>：</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">决定应用程序是否可以操作由其它程序实现的对象，也就是说是否可以将程序作为自动化客户</FONT><FONT SIZE=3>(Automation client)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image233.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image233.gif" WIDTH=397 HEIGHT=298></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>4. 3 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>使用</FONT><FONT SIZE=1>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>创建基于对话框的应用程序：第二步</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image234.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image234.gif" WIDTH=345 HEIGHT=243></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>4. 4 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>应用程序中的“关于”对话框</P></FONT>
<P ALIGN="RIGHT"><TABLE CELLSPACING=0 BORDER=0 CELLPADDING=7 WIDTH=538>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT SIZE=3><P ALIGN="JUSTIFY">ActiveX controls</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>：</FONT></TD>
<TD WIDTH="76%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">决定你的应用程序是否使用</FONT><FONT SIZE=3>ActiveX</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>控件。如果在创建应用程序框架时没有选择该选项，则必须在</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数中添加对</FONT><FONT SIZE=3>AfxEnableControlContainer</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的调用来向工程中插入</FONT><FONT SIZE=3>ActiveX</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>控件。在默认情况下，使用</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>创建的应用程序可以使用</FONT><FONT SIZE=3>ActiveX</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>控件。</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT SIZE=3><P ALIGN="JUSTIFY">Windows sockets</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>：</FONT></TD>
<TD WIDTH="76%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">该选项决定应用程序是否支持</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>套接字。</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>套接字允许应用程序之间通过基于</FONT><FONT SIZE=3>TCP/IP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的网络进行通信。</FONT></TD>
</TR>
</TABLE>
</P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在图</FONT><FONT SIZE=3>4.3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示对话框的最下部可以输入对话框所用的标题。在默认情况下</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>将工程名作为对话框的标题。</P>
<P ALIGN="JUSTIFY">设置完成后单击</FONT><FONT SIZE=3>Next</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>继续。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">5.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在如图</FONT><FONT SIZE=3>4.5</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示的对话框中决定是否让</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为所创建的源文件添加上注释和使用哪一种链接方式。可以使用两种方式链接到</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，一种方式是使用动态链接库</FONT><FONT SIZE=3>DLL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，即选择</FONT><FONT SIZE=3>As a shared DLL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>；第二种方式是像过去所常用的方式那样，使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的静态链接，即选择</FONT><FONT SIZE=3>As a statically linked library</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。两种方式各有优缺点，使用</FONT><FONT SIZE=3>DLL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以有效的应用程序执行文件的大小，但在运行时必须保证应用程序能够找到所需的动态链接库。使用静态链接的应用程序不需要额外的动态链接库的支持，而且可以在性能上获得少许的提高，但是，使用静态链接的应用程序的可执行文件可能会大上很多倍。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image235.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image235.gif" WIDTH=397 HEIGHT=303></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>4. 5 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>使用</FONT><FONT SIZE=1>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>创建基于对话框的应用程序：第三步</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">6.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在图</FONT><FONT SIZE=3>4.6</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示的对话框中更改</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>创建的类的类名、基类及实现该类的头文件和实现文件。要注意的是，并不是所有的类的所有项都可以更改，如果某一项所对应的文本框中的内容的显示变为灰色，则表示该项内容不可以修改。如图</FONT><FONT SIZE=3>4.6</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示的对话框，我们不可能更改类</FONT><FONT SIZE=3>CDialogDemoApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的基类、头文件和实现文件，但是我们却可以更改它的类名。修改完成之后，单击</FONT><FONT SIZE=3>Finish</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。这时，</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>弹出如图</FONT><FONT SIZE=3>4.7</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示的对话框，该对话框给出了对你在前几步中所做的设置的总结，如果一切正确无误的话，单击</FONT><FONT SIZE=3>OK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>接受，这里</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>根据你的设定定制应用程序的各个代码文件和资源文件，这些文件将在本章的后面部分中进行讲述。反之，如果在前面的某一步中的设置有误，则可以单击</FONT><FONT SIZE=3>Cancel</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，然后重新运行</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image236.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image236.gif" WIDTH=397 HEIGHT=303></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>4. 6 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>使用</FONT><FONT SIZE=1>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>创建基于对话框的应用程序：第四步</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image237.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image237.gif" WIDTH=356 HEIGHT=330></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>4. 7</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>在单击了</FONT><FONT SIZE=3>Finish</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>按钮之前，你可以使用</FONT><FONT SIZE=3>Back</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>按钮和</FONT><FONT SIZE=3>Next</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>按钮在</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的各个步骤之间进行切换，并更改不合适的设置，但是，一旦单击了</FONT><FONT SIZE=3>Finish</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>之后，除了直接手动的修改源文件或是推翻重来以外，一切行为都是不可逆的。因此，在使用</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>之后还需添加某些特性往往需要很多额外的工作，因此，如果是编写新的应用程序的话，我们建议在创建应用程序之前先进行完整的构思，以便于在使用</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>时充分发挥其作用，争取让它完成更多的工作，以减轻编写</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>应用程序的复杂程度。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">　</P>
</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER"><A NAME="_Toc425696869">第二节</FONT><FONT SIZE=4> </FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>应用程序类</A></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在创建应用程序框架时，</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>同时生成了一个说明文件</FONT><FONT SIZE=3>ReadMe.txt</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。该说明文件是英文的，为了便于读者阅读，我们在下面给出的工程</FONT><FONT SIZE=3>DialogDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的说明文件</FONT><FONT SIZE=3>ReadMe.txt</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>已被翻译为中文。基于同样的考虑，在本书中给出示例程序时，对于所有的程序注释，我们一律使用中文；对于由</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等生成的程序注释，也一律翻译为中文。注意对于不同的工程，其说明文件的内容也是不同的，但它们都具有大致相同的结构。</P>
<P ALIGN="JUSTIFY">工程</FONT><FONT SIZE=3>DialogDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的说明文件</FONT><FONT SIZE=3>ReadMe.txt</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>========================================================================</P>
<P>       MICROSOFT FOUNDATION CLASS LIBRARY : DialogDemo</P>
<P>========================================================================</P>

<P>　</P>
<P>AppWizard 已为您创建了应用程序 DialogDemo。 该应用程序不仅演示了 Microsoft</P>
<P>Foundation Class 的基本使用，而且还可以作为您编写应用程序的起点。</P>

<P>本文件包括了对构成应用程序 DialogDemo 的每一个文件的总结。</P>

<P>DialogDemo.h</P>
<P>    该文件是应用程序的主要头文件。它包括了其它工程特定的头文件(包括 Resource.h)</P>
<P>    和声明 CDialogDemoApp 应用程序类。</P>

<P>DialogDemo.cpp</P>
<P>    该文件是工程的主要应用程序源文件，它包括了应用程序类 CDialogDemoApp 的实现。</P>

<P>DialogDemo.rc</P>
<P>    该文件是程序所使用的所有 Microsoft Windows 资源的列表。它包括保存在目录 RES</P>
<P>    下的图标、位图和光标。该文件可以在 Microsoft Developer Studio 中直接编辑。</P>

<P>res\DialogDemo.ico</P>
<P>    应用程序图标所使用的图标文件。该图标被包括在文件 DialogDemo.rc 中。</P>

<P>res\DialogDemo.rc2</P>
<P>    该文件包括的资源不被 Microsoft Developer Studio 编辑。你可以将不可以被资源</P>
<P>    编辑器编辑的资源放入此文件。</P>

<P>DialogDemo.clw</P>
<P>    ClassWizard 使用该文件所包括的消息来编辑已有的类或添加新类。ClassWizard 还</P>
<P>    使用该文件来保存在创建和编辑消息映射和对话框数据映射以及创建成员函数原型时</P>
<P>    所需的信息。</P>

<P>　</P>
<P>/////////////////////////////////////////////////////////////////////////////</P>

<P>AppWizard 创建了一个对话框类：</P>

<P>DialogDemoDlg.h, DialogDemoDlg.cpp - 对话框</P>
<P>    这些文件包括了类 CDialogDemoDlg。该类定义了应用程序主对话框的行为。对话框</P>
<P>    的模板包括在 DialogDemo.rc 中，可以使用 Microsoft Developer Studio 来编辑</P>
<P>    该文件。</P>

<P>　</P>
<P>/////////////////////////////////////////////////////////////////////////////</P>
<P>其它标准文件：</P>

<P>StdAfx.h, StdAfx.cpp</P>
<P>    这些文件用于创建预编译头文件(PCH)，该文件名为 DialogDemo.pch，预编译类型</P>
<P>    文件名为 StdAfx.obj。</P>

<P>Resource.h</P>
<P>    定义新资源 ID 的标准头文件。Microsoft Developer Studio 读取和更新该文件。</P>

<P>/////////////////////////////////////////////////////////////////////////////</P>
<P>其它注意事项：</P>

<P>AppWizard 使用 "TODO:" 来指出需要添加或定制源代码的地方。</P>

<P>如果你的应用程序使用了 MFC 的共享动态链接库，并且你的应用程序使用了与操作系统</P>
<P>当前语言不同的语言，那么你需要将相应的本地化资源文件 MFC40xxx.DLL 从 Microsoft</P>
<P>Visual C++ CD-ROM 上复制到 system 或 system32 目录下，并将其改名为 MFCLOC.DLL。</P>
<P>("xxx"代表指定语言的缩写，如 MFC40DEU.DLL 包括了已被翻译为德文的资源。)如果你</P>
<P>没有进行这个步骤，应用程序的一些用户界面元素仍将保持为操作系统的语言。</P>

<P>/////////////////////////////////////////////////////////////////////////////</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面我们从头文件</FONT><FONT SIZE=3>StdAfx.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>入手，来分析该应用程序。头文件</FONT><FONT SIZE=3>StdAfx.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的列表清单如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>// stdafx.h : 本包含文件包含了标准系统包含文件，以及经常使用的工程特定的包含</P>
<P>//            文件，在很多情况下，我们并不需要修改这些文件。</P>
<P>//</P>

<P>#if !defined(AFX_STDAFX_H__7ABABF8C_0C8C_11D2_BC21_0000B4810A31__INCLUDED_)</P>
<P>#define AFX_STDAFX_H__7ABABF8C_0C8C_11D2_BC21_0000B4810A31__INCLUDED_</P>

<P>#if _MSC_VER &gt;= 1000</P>
<P>#pragma once</P>
<P>#endif // _MSC_VER &gt;= 1000</P>

<P>#define VC_EXTRALEAN&#9;&#9;// 从 Windows 头文件中排除很少用到的那一部分</P>

<P>#include &lt;afxwin.h&gt;         // MFC 核心和标准部件</P>
<P>#include &lt;afxext.h&gt;         // MFC 扩展</P>
<P>#include &lt;afxdisp.h&gt;        // MFC OLE 自动化类</P>
<P>#ifndef _AFX_NO_AFXCMN_SUPPORT</P>
<P>#include &lt;afxcmn.h&gt;&#9;&#9;&#9;// MFC 对 Windows 公用控件的支持</P>
<P>#endif // _AFX_NO_AFXCMN_SUPPORT</P>

<P>　</P>
<P>//{{AFX_INSERT_LOCATION}}</P>
<P>// Microsoft Developer Studio 将在上一行之前最接近的地方添加附加的声明</P>

<P>#endif // !defined(AFX_STDAFX_H__7ABABF8C_0C8C_11D2_BC21_0000B4810A31__INCLUDED_)</P>
<P>与头文件相对应的实现文件为StdAfx.cpp文件，该文件只有一行代码，如下面的清单所示：</P>
<P>// stdafx.cpp : 包含标准包含文件的源文件</P>
<P>//&#9;DialogDemo.pch 为预编译头文件</P>
<P>//&#9;stdafx.obj 中包含了预编译类型信息</P>

<P>#include "stdafx.h"</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">StdAfx.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>文件是</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>工程的预编译头文件，将一些常用的并且很少需要修改的头文件放入</FONT><FONT SIZE=3>StdAfx.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中可以有效的提高</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的编译速度。</P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>StdAfx.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>头文件中定义的标识符</FONT><FONT SIZE=3>VC_EXTRALEAN</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>将从</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>包含文件中排除了一些不常用的头文件，从而提高应用程序的编译速度，但是，如果应用程序中需要使用在被排除的这些头文件中声明的函数，必须额外的添加这些对这些头文件的包含，否则将会导致编译出错。</P>
<P ALIGN="JUSTIFY">对其它包含头文件的说明请参见</FONT><FONT SIZE=3>StdAfx.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>头文件清单中的注释。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在头文件</FONT><FONT SIZE=3>Resource.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中包含了对程序和资源中所用到的常量的定义，其清单如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>//{{NO_DEPENDENCIES}}</P>
<P>// Microsoft Visual C++ 生成包含文件.</P>
<P>// 由 DIALOGDEMO.RC 使用</P>
<P>//</P>
<P>#define IDR_MAINFRAME&#9;&#9;&#9;&#9;&#9;128</P>
<P>#define IDM_ABOUTBOX&#9;&#9;&#9;&#9;&#9;0x0010</P>
<P>#define IDD_ABOUTBOX&#9;&#9;&#9;&#9;&#9;100</P>
<P>#define IDS_ABOUTBOX&#9;&#9;&#9;&#9;&#9;101</P>
<P>#define IDD_DIALOGDEMO_DIALOG&#9;&#9;&#9;&#9;102</P>

<P>// 新对象的下一个默认值</P>
<P>// </P>
<P>#ifdef APSTUDIO_INVOKED</P>
<P>#ifndef APSTUDIO_READONLY_SYMBOLS</P>

<P>#define _APS_NEXT_RESOURCE_VALUE        129</P>
<P>#define _APS_NEXT_COMMAND_VALUE         32771</P>
<P>#define _APS_NEXT_CONTROL_VALUE         1000</P>
<P>#define _APS_NEXT_SYMED_VALUE           101</P>
<P>#endif</P>
<P>#endif</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面我们再来分析一下头文件</FONT><FONT SIZE=3>DialogDemo.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>// DialogDemo.h : 应用程序 DIALOGDEMO 的主要头文件</P>
<P>//</P>

<P>#if !defined(AFX_DIALOGDEMO_H__7ABABF88_0C8C_11D2_BC21_0000B4810A31__INCLUDED_)</P>
<P>#define AFX_DIALOGDEMO_H__7ABABF88_0C8C_11D2_BC21_0000B4810A31__INCLUDED_</P>

<P>#if _MSC_VER &gt;= 1000</P>
<P>#pragma once</P>
<P>#endif // _MSC_VER &gt;= 1000</P>

<P>#ifndef __AFXWIN_H__</P>
<P>&#9;#error include 'stdafx.h' before including this file for PCH</P>
<P>#endif</P>

<P>#include "resource.h"&#9;&#9;// 主要符号</P>

<P>/////////////////////////////////////////////////////////////////////////////</P>
<P>// CDialogDemoApp:</P>
<P>// 在 DialogDemo.cpp　中包括了该类的实现</P>
<P>//</P>

<P>class CDialogDemoApp : public CWinApp</P>
<P>{</P>
<P>public:</P>
<P>&#9;CDialogDemoApp();</P>

<P>// 重载</P>
<P>&#9;// ClassWizard 生成的虚函数重载</P>
<P>&#9;//{{AFX_VIRTUAL(CDialogDemoApp)</P>
<P>&#9;public:</P>
<P>&#9;virtual BOOL InitInstance();</P>
<P>&#9;//}}AFX_VIRTUAL</P>

<P>// 实现</P>

<P>&#9;//{{AFX_MSG(CDialogDemoApp)</P>
<P>&#9;&#9;// 注意 - ClassWizard 将在这里添加或删除成员函数</P>
<P>&#9;&#9;//    不要编辑你在这里所看到的这些生成代码块！</P>
<P>&#9;//}}AFX_MSG</P>
<P>&#9;DECLARE_MESSAGE_MAP()</P>
<P>};</P>

<P>　</P>
<P>/////////////////////////////////////////////////////////////////////////////</P>

<P>//{{AFX_INSERT_LOCATION}}</P>
<P>// Microsoft Developer Studio 将在紧接着上一行之前的地方插入附加的声明。</P>

<P>#endif // !defined(AFX_DIALOGDEMO_H__7ABABF88_0C8C_11D2_BC21_0000B4810A31__INCLUDED_)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在头文件</FONT><FONT SIZE=3>DialogDemo.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中定义了应用程序类</FONT><FONT SIZE=3>CDialogDemoApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。在</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，应用程序类封装了一个</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序的初始化、运行和终止。每一个</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序都必须包括一个从</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生的应用程序类，在应用程序</FONT><FONT SIZE=3>DialogDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，这个类就是</FONT><FONT SIZE=3>CDialogDemoApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。这个对象在窗口被创建之前进行构造。类</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从类</FONT><FONT SIZE=3>CWinThread</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生，它代表了应用程序的主执行线程，正如我们在前面的章节中所讲述的那样，一个应用程序可以有多个执行线程。在</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的最近看到版本中，已为类</FONT><FONT SIZE=3>CWinThread</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Run</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>ExitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>OnIdle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>提供了默认的实现。由于我们在讨论</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>时更侧重于它作为应用程序对象所扮演的角色，而不是作为主线程，因此，我们在讨论前面提到的四个成员函数的时候，可以把它们想象为在类</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>定义的成员函数，即立足于应用程序对象的角度来看待和分析它们的行为，而不是立足于一个单独的线程的角度。</P>
<P ALIGN="JUSTIFY">应用程序类构成了应用程序的主执行线程。使用</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数可以创建新的执行线程。这些线程仍可以使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>库，详细的信息请参考本书关于进程和线程的有关章节。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">同其它的任何</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用一样，框架应用程序仍然具有一个</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数。但是，在由</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>生成的应用程序框架中，我们却找不到对</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数的声明或定义。在</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序中，</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数是由类库提供的，它在应用程序启动时被调用。</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数执行如注册窗口类之类的标准服务。接着，它调用应用程序对象的成员函数来初始化并且运行应用程序。通过重载</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数所调用的类</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数可以自定义</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数通过调用应用程序对象的</FONT><FONT SIZE=3>InitApplication</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数来初始化应用程序，通过调用</FONT><FONT SIZE=3>Run</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数运行应用程序的消息循环，最后在程序结束时调用程序程序的</FONT><FONT SIZE=3>ExitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数。其中</FONT><FONT SIZE=3>Run</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数一般由</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>提供，而</FONT><FONT SIZE=3>InitApplication</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>ExitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>一般需要程序员创建或进行重载。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>由于在</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>环境下，每一个应用程序的实例都是独立的，它们有着自己的虚拟地址空间，因此，在目前版本的</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中，成员函数</FONT><FONT SIZE=3>CWinApp::InitApplication</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>已被废弃，原来在</FONT><FONT SIZE=3>InitApplication</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中进行的初始化操作应该移到</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中进行。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">由</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>生成的基于对话框的框架应用程序提供了对</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的默认重载，也正是在该成员函数中提供了基于对话框的应用程序的特点。在</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，无论是基于对话框的应用程序，还是基于文档</FONT><FONT SIZE=3>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>视结构的应用程序，它们的应用程序对象都是从</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生而来的，它们之间的功能的巨大差异，往往就是通过对类</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数进行不同的重载来体现的。</P>
<P ALIGN="JUSTIFY">在每一个同一应用程序的实例被启动时，</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数调用一次</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数。原有的</FONT><FONT SIZE=3>InitApplication</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不再有意义，每一个应用程序的实例都被认为是独立的，对应用程序的初始化同对实例的初始化没有本质区别。对于</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数，我们这时只需知道它在当应用程序进行初始化的时候由</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数调用。关于基于对话框的应用程序的</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数的典型实现，我们将在本章后面的内容中专门讲述。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">类</FONT><FONT SIZE=3>CDialogDemoApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实现包含在文件</FONT><FONT SIZE=3>DialogDemo.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，其清单如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>// DialogDemo.cpp : 为应用程序定义类的行为</P>
<P>//</P>

<P>#include "stdafx.h"</P>
<P>#include "DialogDemo.h"</P>
<P>#include "DialogDemoDlg.h"</P>

<P>#ifdef _DEBUG</P>
<P>#define new DEBUG_NEW</P>
<P>#undef THIS_FILE</P>
<P>static char THIS_FILE[] = __FILE__;</P>
<P>#endif</P>

<P>/////////////////////////////////////////////////////////////////////////////</P>
<P>// CDialogDemoApp</P>

<P>BEGIN_MESSAGE_MAP(CDialogDemoApp, CWinApp)</P>
<P>&#9;//{{AFX_MSG_MAP(CDialogDemoApp)</P>
<P>&#9;&#9;// 注意 - ClassWizard 将在此添加或删除映射宏。</P>
<P>&#9;&#9;//    不要删除你在这里看到的这些生成代码块！</P>
<P>&#9;//}}AFX_MSG</P>
<P>&#9;ON_COMMAND(ID_HELP, CWinApp::OnHelp)</P>
<P>END_MESSAGE_MAP()</P>

<P>/////////////////////////////////////////////////////////////////////////////</P>
<P>// CDialogDemoApp 构造</P>

<P>CDialogDemoApp::CDialogDemoApp()</P>
<P>{</P>
<P>&#9;// TODO: 在这里添加构造代码，</P>
<P>&#9;// 将所有重要的初始化放入 InitInstance</P>
<P>}</P>

<P>/////////////////////////////////////////////////////////////////////////////</P>
<P>// 唯一的 CDialogDemoApp 对象</P>

<P>CDialogDemoApp theApp;</P>

<P>/////////////////////////////////////////////////////////////////////////////</P>
<P>// CDialogDemoApp 初始化</P>

<P>BOOL CDialogDemoApp::InitInstance()</P>
<P>{</P>
<P>&#9;AfxEnableControlContainer();</P>

<P>&#9;// 标准初始化</P>
<P>&#9;// 如果你不需要使用这些特性，并且希望减小最终可执行文件的大小，你可以删除</P>
<P>&#9;//  下面的特定的初始化过程中不需要的部分。</P>

<P>#ifdef _AFXDLL</P>
<P>&#9;Enable3dControls();&#9;&#9;&#9;// 当通过共享 DLL 使用 MFC 时调用</P>
<P>#else</P>
<P>&#9;Enable3dControlsStatic();&#9;// 当通过静态链接到 MFC 时调用</P>
<P>#endif</P>

<P>&#9;CDialogDemoDlg dlg;</P>
<P>&#9;m_pMainWnd = &amp;dlg;</P>
<P>&#9;int nResponse = dlg.DoModal();</P>
<P>&#9;if (nResponse == IDOK)</P>
<P>&#9;{</P>
<P>&#9;&#9;// TODO: 在这里添加当使用 OK 关闭对话框时的处理代码</P>
<P>&#9;}</P>
<P>&#9;else if (nResponse == IDCANCEL)</P>
<P>&#9;{</P>
<P>&#9;&#9;// TODO: 在这里添加当使用 Cancel 关闭对话框时的处理代码</P>
<P>&#9;}</P>

<P>&#9;// 由于对话框已被关闭，返回 FALSE 并退出应用程序，而不需要启动应用程序</P>
<P>    // 消息泵。</P>
<P>&#9;return FALSE;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">上面的源代码为类</FONT><FONT SIZE=3>CDialogDemoApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>提供了一个空的构造函数和一个对</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的默认重载。我们把讨论的重点放在</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数上。在</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数的一开始，先调用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>全局函数</FONT><FONT SIZE=3>AfxEnableControlContainer</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，该函数为应用程序提供了对</FONT><FONT SIZE=3>OLE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>控件</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>新的术语称作</FONT><FONT SIZE=3>ActiveX</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>控件</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的支持。</P>
<P ALIGN="JUSTIFY">接着，</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数调用类</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>Enable3dControls</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>Enable3dControlsStatic</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>以允许对话框和窗口可以使用具有三维外观的控件。这两个成员函数加载</FONT><FONT SIZE=3>CTL3D32.DLL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>并且注册应用程序。</FONT><FONT SIZE=3>Enable3dControls</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Enable3dControlsStatic</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的区别在于一个在链接到</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>动态链接库时使用，而另一个在使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的静态链接时使用。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>自动为以下窗口类提供</FONT><FONT SIZE=3>3D</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>控件效果：</P>

<UL>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY"><LI>CDialog</LI></P>
<P ALIGN="JUSTIFY"><LI>CDialogBar</LI></P>
<P ALIGN="JUSTIFY"><LI>CFormView</LI></P>
<P ALIGN="JUSTIFY"><LI>CPropertyPage</LI></P>
<P ALIGN="JUSTIFY"><LI>CPropertySheet</LI></P>
<P ALIGN="JUSTIFY"><LI>CControlBar</LI></P>
<P ALIGN="JUSTIFY"><LI>CToolBar</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">如果你所希望得到</FONT><FONT SIZE=3>3D</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>效果的控件属于以上类型之一的话，你只需调用</FONT><FONT SIZE=3>Enable3dControls</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>Enable3dControlsStatic</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>即可。反之则必须直接调用相应的</FONT><FONT SIZE=3>CTL3D32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">然后在</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中定义了类型为</FONT><FONT SIZE=3>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的对象</FONT><FONT SIZE=3>dlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，然后将其指针赋予类型为</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员变量</FONT><FONT SIZE=3>m_pMainWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。成员变量</FONT><FONT SIZE=3>m_pMainWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用来保存指向线程主窗口对象的指针，当由</FONT><FONT SIZE=3>m_pMainWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>引用的窗口被关闭时，该线程由</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>自动终止。当应用程序的主线程被终止时，该应用程序相应的也被终止。如果该成员的值为</FONT><FONT SIZE=3>NULL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，则应用程序的</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象的主窗口被用来判断线程何时终止。成员</FONT><FONT SIZE=3>m_pMainWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>具有共有访问权限。对于工作者线程而言，该数据成员的值从其父线程继承。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">接着</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>调用了对象</FONT><FONT SIZE=3>dlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>DoModal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，该成员函数以模态方式调用对话框并在结束时返回对话框的结果。在对话框激活时，该成员函数处理所有与用户的交互，也就是说，对于模态对话框，用户不可以在对话框关闭之前与其它窗口进行交互。</P>
<P ALIGN="JUSTIFY">如果用户单击了对话框中的</FONT><FONT SIZE=3>OK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>Cancel</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>按钮，相应的消息处理函数，如</FONT><FONT SIZE=3>OnOK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>OnCancel</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被调用以试图关闭对话框。</FONT><FONT SIZE=3>OnOK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数的默认行为为验证和更新对话框数据并以结果</FONT><FONT SIZE=3>IDOK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关闭对话框，</FONT><FONT SIZE=3>OnCancel</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的默认行为为以结果</FONT><FONT SIZE=3>IDCANCEL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关闭对话框并不更机关报所有对话框数据。通过重载这些消息处理函数可以改变它们的行为。</P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>DoModal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回时，对话框将被关闭，理所当然的，基于该对话框的应用程序也应该被关闭，因此在</FONT><FONT SIZE=3>InitInstance</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的最后使用了语句</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>return FALSE;</P>
</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER"><A NAME="_Toc425696870">第三节</FONT><FONT SIZE=4> MFC</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>应用程序的消息循环</A></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的对应用程序的类的定义和声明还包括了</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的消息循环</FONT><FONT SIZE=3>(message loop)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，下面我们来详细的描述</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序的消息循环。框架应用程序处理</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息的方式同其它</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序是类似的，只不过它提供了一些方法来使得这个过程更加的方便，更加的易于维护和更好的包装。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>为便于读者理解，在此我们给出一个</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>对对话框控制的支持的树图</FONT><FONT SIZE=3>(</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>如图</FONT><FONT SIZE=3>4.8</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>所示</FONT><FONT SIZE=3>)</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在类</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT SIZE=3>Run</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数中的消息循环获取各种事件所产生的排队消息</FONT><FONT SIZE=3>(queued message)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，应用程序消息循环的框架实现是将它们分发到合适的窗口。</P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，每一个单独的消息都由一个专门的函数进行处理，这种称作消息处理函数</FONT><FONT SIZE=3>(message-handler function</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>message handler</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>handler)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的专门函数以类的成员函数的方式进行定义。处理命令消息的函数还常被称作命令处理函数</FONT><FONT SIZE=3>(command handler)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序是消息驱动的，因此编写消息处理函数就成了编写框架应用程序的工作中的一个很大的组成部分。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image238.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image238.gif" WIDTH=163 HEIGHT=318></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>4. 8 MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>中对话框控件类的树状结构图</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">每一个有能力获取消息或命令的框架类都有它自己的消息映射</FONT><FONT SIZE=3>(message map)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，框架使用消息映射来建立消息和命令到它们的处理函数之间的链接。所有从类</FONT><FONT SIZE=3>CCmdTarget</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生的类都可以有它自己的消息映射。尽管我们常常区别消息和命令两个术语，但这里所说的消息映射同时对它们进行处理。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面我们来看一下消息是如何发送和获取的。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">很多消息来自于用户和程序之间的交互：当用户使用鼠标单击了菜单项或工具条按钮或按下了快捷键时，即产生了命令。同样由用户产生的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息还可以来自移动窗口或改变窗口的大小。此外，当程序启动或终止、窗口获得或失去焦点等等事件发生时，相应的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息也将被发送。控件作为一种特殊形式的窗口，相应的控件通知消息也在类似的情形下产生。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">Run</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数用来获取消息并将它们发送到合适的窗口，很多的命令消息被发送到应用程序的主窗口，由类库预先定义的</FONT><FONT SIZE=3>WindowProc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数获得这些消息，然后根据所获得的消息的类型来以不同的方式对它们进行处理。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">最初接受消息的必须是一个窗口对象。</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息通常直接由该窗口对象进行处理。而命令消息一般由应用程序的主框架窗口开始，按照命令路径描述的命令目标链进行处理。</P>
<P ALIGN="JUSTIFY">当一个命令目标链获得消息或命令时，它将搜索它的消息映射以寻找匹配项。如果该消息的一个处理函数存在，该处理函数将被调用。</P>
<P ALIGN="JUSTIFY">与命令不同，对于标准</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息，它们并不经过命令目标链，通常由该消息的目标窗口进行处理，这个目标窗口可能是主框架窗口，也可能是一个</FONT><FONT SIZE=3>MDI</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>子窗口、一个标准控件、对话框、视或其它形式的子窗口。</P>
<P ALIGN="JUSTIFY">在运行时，每一个</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>窗口都与一个窗口对象建立关联，该窗口对象由直接的或间接的由类</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生，并且有着它自己的消息映射和处理函数。框架使用这个消息映射来将到来的消息映射到它们的处理函数。</P>
<P ALIGN="JUSTIFY">对于命令，我们所需做的只是建立命令到它们的处理函数之间的链接，通常使用</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来完成这一步工作，然后编写绝大多数的命令处理程序。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息通常发送到主框架窗口，但是命令消息将可能传送到其它的对象，框架通过一个命令目标对象的标准顺序来传递命令，这些命令目标对象至少有一个可能</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>并不是一定</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>包含该命令的处理函数。每一个命令目标对象检查它的消息映射以查看是否有一个命令处理函数来处理到来的消息。</P>
<P ALIGN="JUSTIFY">不同的命令目标类在不同的时候检查它们自己的消息映射。典型的，一个类将命令传送给其它一些类，这使得这些类具有最先处理该消息的机会。如果这些类中没有一个处理了该命令，最初的那个类将检查它的消息映射，然后，如果它也没有提供相应的处理函数，它可能会将该命令传送给更多的命令目标。表</FONT><FONT SIZE=3>4.2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>描述了构成这一顺序的结构。通常的顺序是先传送给当前激活子命令目标对象，再传送给自身，最后传送给其它的命令目标。</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>4. 2 </FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>标准命令传送路径</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=332>
<TR><TD WIDTH="42%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">该类型的对象获取某一命令时……</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">它将按下面的顺序给自身和其它命令目标对象处理该命令的机会</FONT></TD>
</TR>
<TR><TD WIDTH="42%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">MDI</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>框架窗口<BR>
</FONT><FONT SIZE=1>(CMDIFrameWnd)</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">1. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>当前激活</FONT><FONT SIZE=1>CMDIChildWnd<BR>
2. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>当前框架窗口自身<BR>
</FONT><FONT SIZE=1>3. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>应用程序</FONT><FONT SIZE=1>(CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>对象</FONT><FONT SIZE=1>)</FONT></TD>
</TR>
<TR><TD WIDTH="42%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">文档框架窗口<BR>
</FONT><FONT SIZE=1>(CframeWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>，</FONT><FONT SIZE=1>CMDIChildWnd)</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">1. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>当前激活视<BR>
</FONT><FONT SIZE=1>2. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>当前框架窗口<BR>
</FONT><FONT SIZE=1>3. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>应用程序</FONT><FONT SIZE=1>(CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>对象</FONT><FONT SIZE=1>)</FONT></TD>
</TR>
<TR><TD WIDTH="42%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">视</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">1. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>当前视<BR>
</FONT><FONT SIZE=1>2. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>与视相关联的文档</FONT></TD>
</TR>
<TR><TD WIDTH="42%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">文档</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">1. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>当前文档<BR>
</FONT><FONT SIZE=1>2. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>与文档相关联的文档模板</FONT></TD>
</TR>
<TR><TD WIDTH="42%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">对话框</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">1. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>当前对话框<BR>
</FONT><FONT SIZE=1>2. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>拥有当前对话框的窗口<BR>
</FONT><FONT SIZE=1>3. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>应用程序</FONT><FONT SIZE=1>(CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>对象</FONT><FONT SIZE=1>)</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">上面的过程看起来很复杂，并且添加了程序的开销，但是相比处理程序对命令的响应来说，传送命令的开销要小得多，因为仅当用户与一个用户界面对象进行交互时框架才生成相应的命令。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">当使用</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>创建新的框架应用程序</FONT><FONT SIZE=3>(skeleton application)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>时，</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就已经为它所创建的每一个命令目标类编写了相应的消息映射。在这些消息映射中，有一些已经添加了对某些消息和预定义命令的处理，而其它一些只是为了下一步添加处理函数的占位符。</P>
<P ALIGN="JUSTIFY">类的消息映射位于该类的</FONT><FONT SIZE=3>.CPP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>文件中，我们通常使用</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为每一个类将要处理的消息和命令添加入口。一个典型的消息映射具有如下的结构，它来自文件</FONT><FONT SIZE=3>DialogDemo.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>BEGIN_MESSAGE_MAP(CDialogDemoApp, CWinApp)</P>
<P>&#9;//{{AFX_MSG_MAP(CDialogDemoApp)</P>
<P>&#9;&#9;// 注意 - ClassWizard 将在此添加或删除映射宏。</P>
<P>&#9;&#9;//    不要删除你在这里看到的这些生成代码块！</P>
<P>&#9;//}}AFX_MSG</P>
<P>&#9;ON_COMMAND(ID_HELP, CWinApp::OnHelp)</P>
<P>END_MESSAGE_MAP()</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的消息映射包括一系列的宏。消息映射位于两个宏</FONT><FONT SIZE=3>――BEGIN_MESSAGE_MAP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>END_MESSAGE_MAP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>之间，其它的宏，如</FONT><FONT SIZE=3>ON_COMMAND</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>构成了消息映射的内容。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>在消息映射宏的后面没有分号。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">消息映射还包括了下面形式的注释：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>//{{AFX_MSG_MAP(CDialogDemoApp)</P>
<P>//}}AFX_MSG_MAP</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在两行注释之间包括了消息映射入口，但不要求所有的消息映射入口都在这两行注释之间。当使用</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编写入口时，它将使用这些特殊的注释。所有由</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>生成的注释都位于这两行注释之间。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>除非你确实不想在程序中再使用</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，不要更改</FONT><FONT SIZE=3>//{</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>{</FONT><FONT SIZE=3>AFX_MSG_MAP</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>//}}AFX_MSG_MAP</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>记号，这是</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>进行程序相关数据库管理的特殊标记。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">当使用</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>创建新类时，相应的消息映射将由</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>自动生成。而且，在前面的示例代码中，我们还看到了不要随意修改由</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>生成的消息映射项的警告。但是，对于那些有经验的程序员，使用源代码编辑器来手动的创建消息映射也是完全可行的。</P>
<P ALIGN="JUSTIFY">我们注意到前面的</FONT><FONT SIZE=3>BEGIN_MESSAGE_MAP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>具有下面的格式，它具有两个参数：</FONT><FONT SIZE=3>CDialogDemoApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>BEGIN_MESSAGE_MAP(CDialogDemoApp, CWinApp)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">第一个参数</FONT><FONT SIZE=3>CDialogDemoApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>表示消息映射所属的类，第二个参数</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>表示</FONT><FONT SIZE=3>CDialogDemoApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的直接基类，这向我们暗示了一点，这就是说，如果框架在类</FONT><FONT SIZE=3>CDialogDemoApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中没有找到某一特定消息或命令的映射入口，它将按照类的继承结构依次查找该与该消息或命令相匹配的入口。如果按照这种方式还是未能找到一个匹配的映射项，对于命令，框架将将它传送给下一个命令目标，对于标准</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息，框架将将它传递给一个合适的默认窗口过程。为了加速消息映射匹配的速度，框架使用了一种类似于磁盘缓存的机制，它保存了与最近匹配项有关的信息，以便在获取相同的消息时可以很快的找到与消息相匹配的消息映射。事实上，消息映射同使用虚函数相比，在某些方面要更为有效。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面我们讨论一下消息处理函数的声明。消息处理函数的声明需要遵从一些规则与协议，这些规则和协议因消息所属的种类不同而有所不同。</P>
<P ALIGN="JUSTIFY">在类</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中定义了标准的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息处理函数，这些消息以前缀</FONT><FONT SIZE=3>WM_</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>开头。相应的消息处理函数的命名基于消息的名称。举例来说，消息</FONT><FONT SIZE=3>WM_PAINT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的处理函数在</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中被声明为</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>afx_msg void OnPaint();</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">关键字</FONT><FONT SIZE=3>afx_msg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>使得上面的函数看起来和其它的</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数有所不同，然而实际上，经过预处理之后，</FONT><FONT SIZE=3>afx_msg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>将被空白所代替，也就是说，除了可以使程序员很清楚的的知道哪一些函数是消息处理函数，而哪一些是一般的成员函数。（实际上，该关键字为</FONT><FONT SIZE=3>Microsoft</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>公司为今后所作的保留字。）消息处理函数只通过消息映射来实现，而消息映射仅依赖于几个标准的预处理宏。</P>
<P ALIGN="JUSTIFY">如果需要重载在基类中定义的消息处理函数，只需简单的使用</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在派生类中定义一个具有相同原型的函数，并且为它添加消息映射入口。关于如果使用</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>重载消息处理函数的示例我们将会在本书后面的内容中遇到，这里就不再赘述。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在一些情况下，重载以后的处理函数应该在适当的地方调用基类的被重载函数以使得基类和</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以处理这些消息。而在什么地方调用基类的被重载函数依环境而定。有时候我们需要根据一些条件来决定是否需要调用基类的被重载函数，而在另外的一些场合可能恰恰相反，我们需要基类的处理函数的返回值来决定是否或如何执行自己的处理函数代码。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>有些时候我们可能会想到在将传递给消息处理函数的参数再传递给基类的处理函数时修改它们。比如说，我们有可能想到通过修改</FONT><FONT SIZE=3>OnChar</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>处理函数的</FONT><FONT SIZE=3>nChar</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>参数来在用户输入时屏蔽掉一些字符。但是这样做是不安全的，如果一定需要这样做，我们应该使用类</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>SendMessage</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，而不是直接修改传递给消息处理函数的参数。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">按照惯例，我们在消息处理函数名的前面都使用了前缀“</FONT><FONT SIZE=3>On</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”。并且消息处理函数可能带有几个参数，也可能一个参数也没有。一些消息处理函数可以返回值，而另一些可能被声明为</FONT><FONT SIZE=3>void</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。可以在</FONT><FONT SIZE=3>Class Library Reference</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中找到以</FONT><FONT SIZE=3>WM_</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>开头的消息的默认处理函数，它们都是类</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数，并且具有前缀“</FONT><FONT SIZE=3>On</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”。这些成员函数在类</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的声明均带有前缀</FONT><FONT SIZE=3>afx_msg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">对于命令或控件通知消息，</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>并未提供默认的处理函数。因此，我们需要根据命名约定来自己命名或编写这些消息处理函数。当将命令或控件通知映射到处理函数时，</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>根据命令</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或控件通知代码建议处理函数名。</P>
<P ALIGN="JUSTIFY">举个例子来说，按照命名约定，响应</FONT><FONT SIZE=3>File</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单下的</FONT><FONT SIZE=3>Open</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>命令的消息处理函数将被命名为</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>afx_msg void OnFileOpen();</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">对于一些很常见的用户界面元素，在框架中已为它们预定义了一些命令</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，比如与</FONT><FONT SIZE=3>File</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单下的</FONT><FONT SIZE=3>Open</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>命令对应的命令</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为</FONT><FONT SIZE=3>ID_FILE_OPEN</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这些预定义</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以在文件</FONT><FONT SIZE=3>AFXRES.H</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中找到。下面是所支持的最重要的一些命令的列表：</P>

<UL>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY"><LI>File</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单命令：</FONT><FONT SIZE=3>New</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Open</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Close</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Save</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Save As</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Page Setup</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Print Setup</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Print</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Print Preview</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Exit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>以及最近使用的文件</LI></P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY"><LI>Edit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单命令：</FONT><FONT SIZE=3>Clear</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Clear All</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Copy</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Cut</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Find</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Paste</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Repeat</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Replace</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Select All</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Undo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>以及</FONT><FONT SIZE=3> Redo.</LI></P>
<P ALIGN="JUSTIFY"><LI>View</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单命令：</FONT><FONT SIZE=3>Toolbar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>以及</FONT><FONT SIZE=3>Status Bar.</LI></P>
<P ALIGN="JUSTIFY"><LI>Window</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单命令：</FONT><FONT SIZE=3>New</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Arrange</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Cascade</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Tile Horizontal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Tile Vertical</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>以及</FONT><FONT SIZE=3>Split.</LI></P>
<P ALIGN="JUSTIFY"><LI>Help</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单命令：</FONT><FONT SIZE=3>Index</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Using Help</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>以及</FONT><FONT SIZE=3>About. </LI></P>
<P ALIGN="JUSTIFY"><LI>OLE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>命令</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位于</FONT><FONT SIZE=3>Edit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>：</FONT><FONT SIZE=3>Insert New Object</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Edit Links</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Paste Link</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Paste Special</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>以及</FONT><FONT SIZE=3>typename Object (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>谓词命令</FONT><FONT SIZE=3>). </LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">再举一个例子，按照命名约定的建议，对一个标签为</FONT><FONT SIZE=3>Default</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的按钮控件的</FONT><FONT SIZE=3>BN_CLICKED</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>通知消息处理函数将被命名为：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>afx_msg void OnClickedDefault();</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这样，我们就可以将</FONT><FONT SIZE=3>IDC_DEFAULT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>与一个命令相关联，这样该命令等价于应用程序指定的用户界面对象。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">以上讲到的两类消息</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>命令和控件通知消息</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的处理函数都不带任何参数，同时也不返回任何值。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在上面的例子中，每一个处理函数都对应了单个命令</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或控件</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。然而，在</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的消息映射机制中，我们还可能将单个处理函数对应一个命令</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或控件</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>范围，但是，</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不支持命令</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或控件</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>范围的处理函数的映射，因此我们必须手动的添加消息映射入口。由于到目前为止所讲述的内容还不足以提供了一个完整的示例，因此我们将在本书后面的内容中给出以上内容的示例程序。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在本节的最后解释一下宏</FONT><FONT SIZE=3>DECLARE_MESSAGE_MAP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。该宏一般出现的支持消息映射的类定义的尾部。前面已经说过，每一个从</FONT><FONT SIZE=3>CCmdTarget</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生的类都可以提供了一个消息映射来处理消息，这时我们需要在类声明中使用宏</FONT><FONT SIZE=3>DECLARE_MESSAGE_MAP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，然后在定义该类的成员函数的</FONT><FONT SIZE=3>.CPP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>文件中使用宏</FONT><FONT SIZE=3>BEGIN_MESSAGE_MAP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，然后为每一个消息处理函数添加宏入口，最后使用宏</FONT><FONT SIZE=3>END_MESSAGE_MAP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>如果你在</FONT><FONT SIZE=3>DECLARE_MESSAGE_MAP</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>之后声明了任何成员，必须为它们重新指定新的访问类型</FONT><FONT SIZE=3>(public</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>private</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>protected)</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。为了避免出现错误，我们一般都在类声明的最底部使用宏</FONT><FONT SIZE=3>DECLARE_MESSAGE_MAP</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。</LI></P></UL>

</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER"><A NAME="_Toc425696871">第四节</FONT><FONT SIZE=4> </FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>对话框类</A></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">本节讲述应用程序</FONT><FONT SIZE=3>DialogDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的对话框类</FONT><FONT SIZE=3>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。由于</FONT><FONT SIZE=3>DialogDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是一个基于对话框的应用程序，因此该对话框也将是应用程序的主窗口。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面我们先给出头文件</FONT><FONT SIZE=3>DialogDemoDlg.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的清单：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>// DialogDemoDlg.h : 头文件</P>
<P>//</P>

<P>#if !defined(AFX_DIALOGDEMODLG_H__7ABABF8A_0C8C_11D2_BC21_0000B4810A31__INCLUDED_)</P>
<P>#define AFX_DIALOGDEMODLG_H__7ABABF8A_0C8C_11D2_BC21_0000B4810A31__INCLUDED_</P>

<P>#if _MSC_VER &gt;= 1000</P>
<P>#pragma once</P>
<P>#endif // _MSC_VER &gt;= 1000</P>

<P>/////////////////////////////////////////////////////////////////////////////</P>
<P>// CDialogDemoDlg 对话框</P>

<P>class CDialogDemoDlg : public CDialog</P>
<P>{</P>
<P>// 构造</P>
<P>public:</P>
<P>&#9;CDialogDemoDlg(CWnd* pParent = NULL);&#9;// 标准构造函数</P>

<P>// Dialog Data</P>
<P>&#9;//{{AFX_DATA(CDialogDemoDlg)</P>
<P>&#9;enum { IDD = IDD_DIALOGDEMO_DIALOG };</P>
<P>&#9;&#9;// 注意：ClassWizard 将在此添加数据成员</P>
<P>&#9;//}}AFX_DATA</P>

<P>&#9;// 由 ClassWizard 生成的虚函数重载</P>
<P>&#9;//{{AFX_VIRTUAL(CDialogDemoDlg)</P>
<P>&#9;protected:</P>
<P>&#9;virtual void DoDataExchange(CDataExchange* pDX);&#9;// DDX/DDV 支持</P>
<P>&#9;//}}AFX_VIRTUAL</P>

<P>// 实现</P>
<P>protected:</P>
<P>&#9;HICON m_hIcon;</P>

<P>&#9;// 生成的消息映射函数</P>
<P>&#9;//{{AFX_MSG(CDialogDemoDlg)</P>
<P>&#9;virtual BOOL OnInitDialog();</P>
<P>&#9;afx_msg void OnSysCommand(UINT nID, LPARAM lParam);</P>
<P>&#9;afx_msg void OnPaint();</P>
<P>&#9;afx_msg HCURSOR OnQueryDragIcon();</P>
<P>&#9;//}}AFX_MSG</P>
<P>&#9;DECLARE_MESSAGE_MAP()</P>
<P>};</P>

<P>//{{AFX_INSERT_LOCATION}}</P>
<P>// Microsoft Developer Studio 将在紧贴前一行前面添加附加的声明</P>

<P>#endif </P>
<P>// !defined(AFX_DIALOGDEMODLG_H__7ABABF8A_0C8C_11D2_BC21_0000B4810A31__INCLUDED_)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在生成代码时向源代码文件中插入了一些特定的格式化注释分隔符，以标明那些</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以写入的地方。在前几节的内容中我们已经看到了一些这样的注释分隔符，如</FONT><FONT SIZE=3>AFX_MSG</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>AFX_MSG_MAP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等。在头文件</FONT><FONT SIZE=3>DialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中出现了一些新的分隔符，如</FONT><FONT SIZE=3>AFX_DATA</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用来标记在头文件中为对话框数据交换</FONT><FONT SIZE=3>(dialog data exchange</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><FONT SIZE=3>DDX)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所声明的成员变量的开始和结束。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">AFX_VIRTUAL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用来标记在头文件中由</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>生成和管理的虚函数的开始和结果。在</FONT><FONT SIZE=3>.CPP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>文件中没有对应的块。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下一个看到的函数是</FONT><FONT SIZE=3>DoDataExchange</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。框架调用该函数来交换和验证对话框数据。该函数从来不直接调用，而总是在成员函数</FONT><FONT SIZE=3>UpdateData</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中调用。成员函数</FONT><FONT SIZE=3>UpdateData</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用户初始化对话框控件或从对话框中获取数据。</P>
<P ALIGN="JUSTIFY">如果需要利用框架的自动数据交换和验证，则需要在从类</FONT><FONT SIZE=3>CDialog</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生应用程序特定的对话框时得载该成员函数。</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>会为你创建一个该成员函数的重载版本，在该重载版本的</FONT><FONT SIZE=3>DoDataExchange</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数中包括了所期望的对话框数据交换</FONT><FONT SIZE=3>(DDX)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和有效性验证</FONT><FONT SIZE=3>(DDV)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的全局函数的“数据映射”。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">DoDataExchange</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数的重载版本将在后面的内容中给出和进行更为详细的分析。</P>
<P ALIGN="JUSTIFY">成员变量</FONT><FONT SIZE=3>m_hIcon</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>包括了应用程序主对话框的图标句柄。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面介绍重载的几个消息映射函数。</P>
<P ALIGN="JUSTIFY">第一个介绍的是</FONT><FONT SIZE=3>OnInitDialog</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数。该成员函数为消息</FONT><FONT SIZE=3>WM_INITDIALOG</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的处理函数。当成员函数</FONT><FONT SIZE=3>Create</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>CreateIndirect</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>DoModal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被调用时该消息被发送至对话框，但此时对话框尚未显示于屏幕上。</P>
<P ALIGN="JUSTIFY">一般情况下我们重载该成员函数以进行一些对话框的初始化。在</FONT><FONT SIZE=3>OnInitDialog</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数的重载版本中，我们应该先调用基类的</FONT><FONT SIZE=3>OnInitDialog</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数，但无需理会其返回值。在正常情况下，</FONT><FONT SIZE=3>OnInitDialog</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数的重载版本返回</FONT><FONT SIZE=3>TRUE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">不需要为该成员函数添加一个消息映射入口。这是因为</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>通过一个标准全局对话框函数来调用</FONT><FONT SIZE=3>OnInitDialog</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数，该对话框函数对所有的</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对话框都是一样的，这种调用并不通过消息映射来完成。</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>4.3 OnSysCommand</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>成员函数的</FONT><FONT FACE="Arial" SIZE=1>nID</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>参数</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=447>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">参数</FONT><FONT SIZE=1>nID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>的值</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">含义</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_CLOSE</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">关闭</FONT><FONT SIZE=1>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>对象</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_HOTKEY</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">激活与应用程序指定的热键相关联的</FONT><FONT SIZE=1>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>对象。</FONT><FONT SIZE=1>lParam</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>参数的低位字节标识了待激活窗口的</FONT><FONT SIZE=1>HWND</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>。</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_HSCROLL</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">垂直滚动</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_KEYMENU</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">通过按键检索菜单</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_MAXIMIZA <BR>
(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>或</FONT><FONT SIZE=1>SC_ZOOM)</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">最大化</FONT><FONT SIZE=1>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>对象</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_MINIMIZE <BR>
(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>或</FONT><FONT SIZE=1>SC_ICON)</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">最小化</FONT><FONT SIZE=1>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>对象</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_MOUSEMENU</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">通过鼠标单击检索菜单</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_MOVE</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">移动</FONT><FONT SIZE=1>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>对象</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_NEXTWINDOW</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">移到下一窗口</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_PREVWINDOW</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">移到上一窗口</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_RESTORE</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">恢复窗口到通常位置和大小</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_SCREENSAVE</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">执行由</FONT><FONT SIZE=1>SYSTEM.INI</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>文件的</FONT><FONT SIZE=1>[boot]</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>段指定的屏幕保护程序</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_SIZE</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">改变窗口的大小</FONT></TD>
</TR>
<TR><TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">SC_TASKLIST</FONT></TD>
<TD WIDTH="70%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">运行或激活</FONT><FONT SIZE=1>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>任务管理程序</FONT><FONT SIZE=1>(Windows Task Manager)</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">　</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY"><LI>OnInitDialog</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>成员函数的返回值将影响应用程序设置对话框中控件的输入焦点的方式。如果</FONT><FONT SIZE=3>OnInitDialog</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>返回非零值，窗口设置输入焦点为对话框中的第一个控件。如果已显式的将输入焦点设置为对话框中的某个控件，那么应该返回</FONT><FONT SIZE=3>0</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">接下来声明的是成员函数</FONT><FONT SIZE=3>OnSysCommand</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，它是</FONT><FONT SIZE=3>WM_SYSCOMMAND</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息的处理函数。当用户从控制菜单选择了某一个命令或单击了最大化或最小化按钮。</P>
<P ALIGN="JUSTIFY">该函数的原型如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>afx_msg void OnSysCommand( UINT nID, LPARAM lParam );</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">第一个参数</FONT><FONT SIZE=3>nID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指定了系统命令要求的类型，它可以为表</FONT><FONT SIZE=3>4.3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示值之一。如果通过鼠标选择控制菜单命令，则参数</FONT><FONT SIZE=3>lParam</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>包含了鼠标的当前坐标。低位字代表</FONT><FONT SIZE=3>x</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>坐标，而高位字代表</FONT><FONT SIZE=3>y</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>坐标。</P>
<P ALIGN="JUSTIFY">在默认情况下，</FONT><FONT SIZE=3>OnSysCommand</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>执行表</FONT><FONT SIZE=3>4.3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示的预定义行为。</P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>WM_SYSCOMMAND</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息中，参数</FONT><FONT SIZE=3>nID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的低</FONT><FONT SIZE=3>4</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位由</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>内部使用，当应用程序测试</FONT><FONT SIZE=3>nID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的值时，必须使用按位与</FONT><FONT SIZE=3>(bitwise-AND)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>操作符组合值</FONT><FONT SIZE=3>0xFFF0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>nID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来得到正确的结果。</P>
<P ALIGN="JUSTIFY">应用程序可以在任何时候通过传递一个</FONT><FONT SIZE=3>WM_SYSCOMMAND</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息给成员函数</FONT><FONT SIZE=3>OnSysCommand</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来执行任何系统命令。</P>
<P ALIGN="JUSTIFY">已被定义为用来选择控制菜单项的加速键</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>快捷键</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息将解释为</FONT><FONT SIZE=3>OnSysCommand</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的调用，其它快捷键将翻译为</FONT><FONT SIZE=3>WM_COMMAND</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>控制菜单项可以通过成员函数</FONT><FONT SIZE=3>GetSystemMenu</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>AppendMenu</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>InsertMenu</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>以及</FONT><FONT SIZE=3>ModifyMenu</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>来进行修改。修改了控制菜单的应用程序必须处理</FONT><FONT SIZE=3>WM_SYSCOMMAND</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>消息，所有未被应用程序处理的消息必须传递给成员函数</FONT><FONT SIZE=3>OnSysCommand</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。由应用程序添加的命令值必须由应用程序处理，而不能传递给函数</FONT><FONT SIZE=3>OnSysCommand</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。</LI></P>
<P ALIGN="JUSTIFY"><LI>该成员函数由框架所调用，以允许应用程序处理</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>消息。传递给函数的消息代表了当获得消息时由框架获得的参数。如果你调用了基类的实现，该实现将使用消息最初传递的参数，而不是由函数提供的参数。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">成员函数</FONT><FONT SIZE=3>OnPaint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是消息</FONT><FONT SIZE=3>WM_PAINT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的处理函数，它当窗口客户区需要重绘时被调用。</P>
<P ALIGN="JUSTIFY">成员函数</FONT><FONT SIZE=3>OnQueryDragIcon</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对应于消息</FONT><FONT SIZE=3>WM_QUERYDRAGICON</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，它也是由框架在最小化窗口而没有为类定义一个图标时调用。系统通过对该函数的调用来获得当用户拖动被最小化的窗口时用来显示的光标。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">如果应用程序返回了一个图标名光标的句柄，系统将其转换了黑白的。该句柄必须标识一个与显示驱动程序分辨率相兼容的单色光标或图标。应用程序可以调用</FONT><FONT SIZE=3>CWinApp::LoadCursor</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>CWinApp::LoadIcon</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数来从它的可执行文件中的资源内加载一个光标或图标并获得其句柄。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面给出类</FONT><FONT SIZE=3>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实现文件</FONT><FONT SIZE=3>DialogDemoDlg.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的清单：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>// DialogDemoDlg.cpp : 实现文件</P>
<P>//</P>

<P>#include "stdafx.h"</P>
<P>#include "DialogDemo.h"</P>
<P>#include "DialogDemoDlg.h"</P>

<P>#ifdef _DEBUG</P>
<P>#define new DEBUG_NEW</P>
<P>#undef THIS_FILE</P>
<P>static char THIS_FILE[] = __FILE__;</P>
<P>#endif</P>

<P>/////////////////////////////////////////////////////////////////////////////</P>
<P>// CAboutDlg 用于 App About 的对话框</P>

<P>class CAboutDlg : public CDialog</P>
<P>{</P>
<P>public:</P>
<P>&#9;CAboutDlg();</P>

<P>// Dialog Data</P>
<P>&#9;//{{AFX_DATA(CAboutDlg)</P>
<P>&#9;enum { IDD = IDD_ABOUTBOX };</P>
<P>&#9;//}}AFX_DATA</P>

<P>&#9;// 由 ClassWizard 生成的虚函数重载</P>
<P>&#9;//{{AFX_VIRTUAL(CAboutDlg)</P>
<P>&#9;protected:</P>
<P>&#9;virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV 支持</P>
<P>&#9;//}}AFX_VIRTUAL</P>

<P>// 实现</P>
<P>protected:</P>
<P>&#9;//{{AFX_MSG(CAboutDlg)</P>
<P>&#9;//}}AFX_MSG</P>
<P>&#9;DECLARE_MESSAGE_MAP()</P>
<P>};</P>

<P>CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)</P>
<P>{</P>
<P>&#9;//{{AFX_DATA_INIT(CAboutDlg)</P>
<P>&#9;//}}AFX_DATA_INIT</P>
<P>}</P>

<P>void CAboutDlg::DoDataExchange(CDataExchange* pDX)</P>
<P>{</P>
<P>&#9;CDialog::DoDataExchange(pDX);</P>
<P>&#9;//{{AFX_DATA_MAP(CAboutDlg)</P>
<P>&#9;//}}AFX_DATA_MAP</P>
<P>}</P>

<P>BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)</P>
<P>&#9;//{{AFX_MSG_MAP(CAboutDlg)</P>
<P>&#9;&#9;// 没有消息处理函数</P>
<P>&#9;//}}AFX_MSG_MAP</P>
<P>END_MESSAGE_MAP()</P>

<P>/////////////////////////////////////////////////////////////////////////////</P>
<P>// CDialogDemoDlg 对话框</P>

<P>CDialogDemoDlg::CDialogDemoDlg(CWnd* pParent /*=NULL*/)</P>
<P>&#9;: CDialog(CDialogDemoDlg::IDD, pParent)</P>
<P>{</P>
<P>&#9;//{{AFX_DATA_INIT(CDialogDemoDlg)</P>
<P>&#9;&#9;// 注意：ClassWizard 将在此添加成员初始化</P>
<P>&#9;//}}AFX_DATA_INIT</P>
<P>&#9;// 注意在 Win32 中 LoadIcon 不需要一个相应的 DestroyIcon</P>
<P>&#9;m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);</P>
<P>}</P>

<P>void CDialogDemoDlg::DoDataExchange(CDataExchange* pDX)</P>
<P>{</P>
<P>&#9;CDialog::DoDataExchange(pDX);</P>
<P>&#9;//{{AFX_DATA_MAP(CDialogDemoDlg)</P>
<P>&#9;&#9;// 注意：ClassWizard 将在此添加 DDX 和 DDV 调用</P>
<P>&#9;//}}AFX_DATA_MAP</P>
<P>}</P>

<P>BEGIN_MESSAGE_MAP(CDialogDemoDlg, CDialog)</P>
<P>&#9;//{{AFX_MSG_MAP(CDialogDemoDlg)</P>
<P>&#9;ON_WM_SYSCOMMAND()</P>
<P>&#9;ON_WM_PAINT()</P>
<P>&#9;ON_WM_QUERYDRAGICON()</P>
<P>&#9;//}}AFX_MSG_MAP</P>
<P>END_MESSAGE_MAP()</P>

<P>/////////////////////////////////////////////////////////////////////////////</P>
<P>// CDialogDemoDlg 消息处理函数</P>

<P>BOOL CDialogDemoDlg::OnInitDialog()</P>
<P>{</P>
<P>&#9;CDialog::OnInitDialog();</P>

<P>&#9;// 添加 "About..." 菜单项到系统菜单</P>

<P>&#9;// IDM_ABOUTBOX 必须在系统命令范围之内</P>
<P>&#9;ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX);</P>
<P>&#9;ASSERT(IDM_ABOUTBOX &lt; 0xF000);</P>

<P>&#9;CMenu* pSysMenu = GetSystemMenu(FALSE);</P>
<P>&#9;if (pSysMenu != NULL)</P>
<P>&#9;{</P>
<P>&#9;&#9;CString strAboutMenu;</P>
<P>&#9;&#9;strAboutMenu.LoadString(IDS_ABOUTBOX);</P>
<P>&#9;&#9;if (!strAboutMenu.IsEmpty())</P>
<P>&#9;&#9;{</P>
<P>&#9;&#9;&#9;pSysMenu-&gt;AppendMenu(MF_SEPARATOR);</P>
<P>&#9;&#9;&#9;pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);</P>
<P>&#9;&#9;}</P>
<P>&#9;}</P>

<P>&#9;// 该当前对话框设置图标。当应用程序主窗口不为对话框时由框架自动完成该任务</P>
<P>&#9;SetIcon(m_hIcon, TRUE);&#9;&#9;&#9;// 设置大图标</P>
<P>&#9;SetIcon(m_hIcon, FALSE);&#9;&#9;// 设置小图标</P>
<P>&#9;</P>
<P>&#9;// TODO: 在此添加额外初始化</P>
<P>&#9;</P>
<P>&#9;return TRUE;  // 除非将焦点设置为某一控件，否则返回 TRUE</P>
<P>}</P>

<P>void CDialogDemoDlg::OnSysCommand(UINT nID, LPARAM lParam)</P>
<P>{</P>
<P>&#9;if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX)</P>
<P>&#9;{</P>
<P>&#9;&#9;CAboutDlg dlgAbout;</P>
<P>&#9;&#9;dlgAbout.DoModal();</P>
<P>&#9;}</P>
<P>&#9;else</P>
<P>&#9;{</P>
<P>&#9;&#9;CDialog::OnSysCommand(nID, lParam);</P>
<P>&#9;}</P>
<P>}</P>

<P>// 如果你向对话框添加了一个最小化按钮，你将需要下面的代码来绘制图标。</P>
<P>// 对于使用文件/视模型的 MFC 应用程序，这一步由框架自动完成。</P>

<P>void CDialogDemoDlg::OnPaint() </P>
<P>{</P>
<P>&#9;if (IsIconic())</P>
<P>&#9;{</P>
<P>&#9;&#9;CPaintDC dc(this); // 重绘设备上下文</P>

<P>&#9;&#9;SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);</P>

<P>&#9;&#9;// 在窗户区矩形中居中图标</P>
<P>&#9;&#9;int cxIcon = GetSystemMetrics(SM_CXICON);</P>
<P>&#9;&#9;int cyIcon = GetSystemMetrics(SM_CYICON);</P>
<P>&#9;&#9;CRect rect;</P>
<P>&#9;&#9;GetClientRect(&amp;rect);</P>
<P>&#9;&#9;int x = (rect.Width() - cxIcon + 1) / 2;</P>
<P>&#9;&#9;int y = (rect.Height() - cyIcon + 1) / 2;</P>

<P>&#9;&#9;// 绘制图标</P>
<P>&#9;&#9;dc.DrawIcon(x, y, m_hIcon);</P>
<P>&#9;}</P>
<P>&#9;else</P>
<P>&#9;{</P>
<P>&#9;&#9;CDialog::OnPaint();</P>
<P>&#9;}</P>
<P>}</P>

<P>// 在用户拖动被最小化的窗口时系统调用该函数来获得用于显示的光标。</P>
<P>HCURSOR CDialogDemoDlg::OnQueryDragIcon()</P>
<P>{</P>
<P>&#9;return (HCURSOR) m_hIcon;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在实现文件</FONT><FONT SIZE=3>DialogDemoDlg.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中包括了类</FONT><FONT SIZE=3>CAboutDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义，该类封装了应用程序的“关于”对话框。由于类</FONT><FONT SIZE=3>CAboutDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>与类</FONT><FONT SIZE=3>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>相比要简单得多，所以我们在此不再讲述。下面我们主要分几个部分来讲述类</FONT><FONT SIZE=3>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P><DIR>

</FONT><FONT FACE="Arial" SIZE=3><P>(1)&#9;</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3>构造函数</P></DIR>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在类</FONT><FONT SIZE=3>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的构造函数中，注释分隔符</FONT><FONT SIZE=3>AFX_DATA_INIT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用于在对话框类的构造函数中标记对话框数据交换</FONT><FONT SIZE=3>(DDX)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员变量初始化的开始和结束。接着使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>全局函数</FONT><FONT SIZE=3>AfxGetApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>获得指向应用程序对象的指针，再通过该指针调用成员函数</FONT><FONT SIZE=3>LoadIcon</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>加载图标，并将其句柄放入成员变量</FONT><FONT SIZE=3>m_hIcon</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">类</FONT><FONT SIZE=3>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>DoDataExchange</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>只是简单的调用基类的对应成员函数。在成员函数</FONT><FONT SIZE=3>DoDataExchange</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>内，注释分隔符</FONT><FONT SIZE=3>AFX_DATA_MAP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用于标记对话框数据交换函数调用的开始和结束。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>尽管在接下来的一章中，我们将要再次对菜单的应用作系统的介绍，但考虑到程序说明的完整性，在这里，我们仍然先对其作简明的介绍。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">　</P><DIR>

</FONT><FONT FACE="Arial" SIZE=3><P>(2)&#9;</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3>消息处理成员函数</FONT><FONT FACE="Arial" SIZE=3>OnInitDialog</P></DIR>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">消息处理函数</FONT><FONT SIZE=3>OnInitDialog</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>首先调用基类的对应成员函数。接着的两个</FONT><FONT SIZE=3>ASSERT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>宏断言</FONT><FONT SIZE=3>IDM_ABOUTBOX</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处于系统命令范围内。</FONT><FONT SIZE=3>ASSERT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>宏以一个布尔表达式为参数，然后对该表达式求值，如果结果为</FONT><FONT SIZE=3>0 (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>假</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><FONT SIZE=3>ASSERT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>输出一个诊断信息，然后中断程序，如果结果为非</FONT><FONT SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，宏</FONT><FONT SIZE=3>ASSERT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>什么也不做。</P>
<P ALIGN="JUSTIFY">由宏</FONT><FONT SIZE=3>ASSERT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>输入的诊断信息具下面的格式：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>assertion failed in file &lt;文件名&gt; in line &lt;行号&gt;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在这里文件名代表了出现</FONT><FONT SIZE=3>ASSERT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>错的源代码文件，行号指出了源代码文件中出错的行。</P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的发行版本</FONT><FONT SIZE=3>(Release version)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，宏</FONT><FONT SIZE=3>ASSERT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>并不对表达式进行求值，从而也不会中断程序的执行。与宏</FONT><FONT SIZE=3>ASSERT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不同，宏</FONT><FONT SIZE=3>VERIFY</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中调试版本和发行版本中都将对表达式进行求值。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">接下来，由类</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>GetSystemMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回控制菜单的一个拷贝。如果传递给该函数的参数为假，函数</FONT><FONT SIZE=3>GetSystemMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回正在使用的控制菜单的一个拷贝的句柄。该拷贝同控制菜单完全相同，但它可以修改。如果传递的参数为真，函数</FONT><FONT SIZE=3>GetSystemMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>重置控制菜单为默认值，如果原有控制菜单经过修改，该改动将丢失。在这种情况下，函数</FONT><FONT SIZE=3>GetSystemMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的返回值是未定义的。可以通过由成员函数</FONT><FONT SIZE=3>GetSystemMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回的指针使用</FONT><FONT SIZE=3>CMenu::AppendMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>CMenu::InsertMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>CMenu::ModifyMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数来改变控制菜单。</P>
<P ALIGN="JUSTIFY">控制菜单最初包括由不同</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>值，如</FONT><FONT SIZE=3>SC_CLOSE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>SC_MOVE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>SC_SIZE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等标识的项。这些控制菜单中的项产生</FONT><FONT SIZE=3>WM_SYSCOMMAND</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息。所有预定义的控制菜单具有大于</FONT><FONT SIZE=3>0xF000</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>值，因此，如果应用程序向控制菜单中添加了新的项，这些项所使用的</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>值应该小于</FONT><FONT SIZE=3>0xF000</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以自动的决定是否使标准控制菜单中的项变灰。类</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以通过响应</FONT><FONT SIZE=3>WM_INITMENU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来执行检查或变灰，该消息在所有菜单显示之前发送。</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>4. 4 </FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>成员函数</FONT><FONT FACE="Arial" SIZE=1>AppendMenu</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>的</FONT><FONT FACE="Arial" SIZE=1>nFlags</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>参数</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=412>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">值</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">含义</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">MF_CHECKED</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">在菜单项前面放置一个默认的选中标记。当应用程序提供了选中标记位图时，则使用表示选中状态的位图。</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">MF_UNCHECKED</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">清除菜单项前面的选中标记。如果应用程序提供了选中标记位图，则使用表示不选中状态的位图。</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">MF_DISABLED</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">禁止某项被选择，但不使其变灰。</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">MF_ENABLED</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">允许某项被选择。</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">MF_GRAYED</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">禁止某项被选择，并使其变灰。</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">MF_MENUBARBREAK</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">对于静态菜单，将项放到新的一行，对于弹出菜单，将项放到新的一列。新的弹出菜单列和旧的列使用垂直分隔线隔开。</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">MF_MENUBREAK</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">将项放到新的一行，或弹出菜单的新的一列。列之间没有任何分隔线。</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">MF_OWNERDRAW</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">指定项为一个自绘制项。当菜单第一次显示时，拥有该菜单的窗口将收到消息</FONT><FONT SIZE=1>WM_MEASUREITEM</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>，该消息包括了菜单项的高度和宽度。而每次当需要更新菜单项的显示外观时，将发送消息。该选对顶层菜单项无效。</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">WM_POPUP</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">指定该菜单项具有一个相关联的弹出菜单。</FONT><FONT SIZE=1>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>参数指定与该项相关的弹出菜单句柄。该标志用来添加顶层弹出菜单或将一弹出菜单添加到另一弹出菜单。</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">WM_SEPARATOR</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">绘制一个水平分隔线。仅用于弹出式菜单。该行不可以变灰，不可以被禁止，也不可以被加亮，并且其它参数被忽略。</FONT></TD>
</TR>
<TR><TD WIDTH="35%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">MF_STRING</FONT></TD>
<TD WIDTH="65%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">指定菜单项为一字符串。</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">如果由函数</FONT><FONT SIZE=3>GetSystemMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回的指针不为空，则通过一个</FONT><FONT SIZE=3>CString</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象</FONT><FONT SIZE=3>strAboutMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从资源文件中加载字符串</FONT><FONT SIZE=3>IDS_ABOUTBOX</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。如果成功的话</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>通过检验</FONT><FONT SIZE=3>strAboutMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是否为空来判断</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，将该菜单项添加到控制菜单中。</P>
<P ALIGN="JUSTIFY">添加菜单项使用类</FONT><FONT SIZE=3>CMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>AppendMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。该函数具有如下的原型：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>BOOL AppendMenu( UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL );</P>
<P>BOOL AppendMenu( UINT nFlags, UINT nIDNewItem, const CBitmap* pBmp );</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">第一个参数</FONT><FONT SIZE=3>nFlags</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指定了在新添加菜单时关于新增菜单项的状态的信息。它可以为表</FONT><FONT SIZE=3>4.4</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所列的一个或多个值。需要注意的事是表</FONT><FONT SIZE=3>4.4</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中所列的某些标志是互斥的，也就是说这其中的一些标志不可以同时使用。关于这方面的详细信息请参考</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中关于成员函数</FONT><FONT SIZE=3>AppendMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的联机文档。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>在程序设计中（尤其是在涉及到图形编程时！），图形化的菜单是不是对用户具有更大的吸引力？要达到这一点，在菜单编程中使用位图参数就大功告成了！是不是相当简单？</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">如果</FONT><FONT SIZE=3>nFlags</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>参数被设置为</FONT><FONT SIZE=3>MF_POPUP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，参数</FONT><FONT SIZE=3>nIDNewItem</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为一个弹出菜单的句柄；如果</FONT><FONT SIZE=3>nFlags</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>参数被设置为</FONT><FONT SIZE=3>MF_SEPARATOR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，该参数被忽略；对于其它情况，它为新增菜单项的命令</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">随着参数</FONT><FONT SIZE=3>nFlags</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的不同，参数</FONT><FONT SIZE=3>lpszNewItem</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>具有不同的解释，如表</FONT><FONT SIZE=3>4.5</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示。</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>4. 5 nFlags</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>参数不同时对</FONT><FONT FACE="Arial" SIZE=1>lpszNewItem</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>参数的不同解释</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=412>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">Nflags</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>的值</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">对</FONT><FONT SIZE=1>lpszNewItem</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>的解释</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">MF_OWNERDRAW</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">包括一个由应用程序提供的</FONT><FONT SIZE=1>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位值，应用程序使用该值来维护与该菜单项相关联的附加数据。该</FONT><FONT SIZE=1>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位值在应用程序处理消息</FONT><FONT SIZE=1>WM_MEASUREITEM</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>和</FONT><FONT SIZE=1>WM_DRAWITEM</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>时可用，它被保存在这些消息提供的结构的</FONT><FONT SIZE=1>itemData</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>成员中。</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP" HEIGHT=18>
<FONT SIZE=1><P ALIGN="JUSTIFY">MF_STRING</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP" HEIGHT=18>
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">包括指向以</FONT><FONT SIZE=1>null</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>结束的字符串的指针。</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP" HEIGHT=22>
<FONT SIZE=1><P ALIGN="JUSTIFY">MF_SEPARATOR</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP" HEIGHT=22>
<FONT SIZE=1><P ALIGN="JUSTIFY">lpszNewItem</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>参数被忽略。</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在第二种格式的成员函数</FONT><FONT SIZE=3>AppendMenu</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，参数</FONT><FONT SIZE=3>pBmp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向一个</FONT><FONT SIZE=3>CBitmap</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象，该对象将被用作菜单项。</P>
<P ALIGN="JUSTIFY">函数</FONT><FONT SIZE=3>SetIcon</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用来将句柄设置为某一特定图标，该图标由第一个参数标识。第二个参数指定和图标的大小，如果该参数为真，表示图标为</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>象素<FONT FACE="Symbol">&#180;</FONT>
</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>象素大小；如果为假，表示图标为</FONT><FONT SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>象素<FONT FACE="Symbol">&#180;</FONT>
</FONT><FONT SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>象素大小。</P>
<P ALIGN="JUSTIFY">最后，由于我们没有将输入焦点设置为某一个特定的控件，因此消息处理函数</FONT><FONT SIZE=3>OnInitDialog</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回真值</FONT><FONT SIZE=3>TRUE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P><DIR>

</FONT><FONT FACE="Arial" SIZE=3><P>(3)&#9;</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3>消息处理成员函数</FONT><FONT FACE="Arial" SIZE=3>OnSysCommand</P></DIR>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">类</FONT><FONT SIZE=3>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT SIZE=3>OnSysCommand</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数非常之简单，首先它检查用户选择的命令是否</FONT><FONT SIZE=3>IDM_ABOUTBOX (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>注意在</FONT><FONT SIZE=3>if</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语句中使用了表达式</FONT><FONT SIZE=3>nID &amp; 0xFFF0)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，如果是的话，声明一个类</FONT><FONT SIZE=3>CAboutDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的对象，调用该对象的</FONT><FONT SIZE=3>DoModal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数以模态方式显示该对话框；否则，函数</FONT><FONT SIZE=3>OnSysCommand</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>调用基类的成员函数</FONT><FONT SIZE=3>OnSysCommand</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。前面已经提到过，对于应用程序自己添加的控制菜单项</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如这里的</FONT><FONT SIZE=3>IDM_ABOUTBOX)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，不要调用基类提供的成员函数</FONT><FONT SIZE=3>OnSysCommand</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进行默认处理。</P><DIR>

</FONT><FONT FACE="Arial" SIZE=3><P>(4)&#9;</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3>消息处理成员函数</FONT><FONT FACE="Arial" SIZE=3>OnPaint</P></DIR>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">首先，类</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>IsIconic</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用来判断一个窗口是否被最小化。如果是，函数</FONT><FONT SIZE=3>IsIconic</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回真值</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>非零值</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>；反之，返回假值</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>零</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。如果</FONT><FONT SIZE=3>IsIconic</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回真，则以当前</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>它指向当前</FONT><FONT SIZE=3>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为参数构造类</FONT><FONT SIZE=3>CPaintDC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的对象</FONT><FONT SIZE=3>dc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。类</FONT><FONT SIZE=3>CPaintDC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>封装了</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序重绘时所使用的设备描述表。然后，成员函数</FONT><FONT SIZE=3>SendMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>向窗口发送一条</FONT><FONT SIZE=3>WM_ICONERASEBKGND</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息，该条消息表示在重画被最小化的窗口的图标之前需要对图标背景进行填充。而类</FONT><FONT SIZE=3>CDC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>GetSafeHdc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回该类的成员函数</FONT><FONT SIZE=3>m_hDC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，即相应的输出设备上下文，该设备上下文作为</FONT><FONT SIZE=3>WM_ICONERASEBKGND</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT SIZE=3>wParam</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>参数被发送。</P>
<P ALIGN="JUSTIFY">接着成员函数</FONT><FONT SIZE=3>OnPaint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>分别以</FONT><FONT SIZE=3>SM_CXICON</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>SM_CYICON</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>有参数调用</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数</FONT><FONT SIZE=3>GetSystemMetrics (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>注意它并不是类</FONT><FONT SIZE=3>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>及其基类，典型的如</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，从而得到以象素为单位的图标默认宽度和高度，图标大小的典型值为</FONT><FONT SIZE=3>32<FONT FACE="Symbol">&#180;</FONT>
32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，但我们不可以在应用程序中作此假设，因为它依赖于所安装的显示硬件，并可能随用户对系统设置的改变而改变。</P>
<P ALIGN="JUSTIFY">然后类</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>GetClientRect</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>将当前客户区矩形的度量放入第一个参数所指向的</FONT><FONT SIZE=3>CRect</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象中。类</FONT><FONT SIZE=3>CRect</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>封装了由左上角和右下角所确定的一个矩形。其成员函数</FONT><FONT SIZE=3>Width</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Height</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>分别返回所确定矩形的宽和高。然后通过计算得到使图标居中的坐标。最后调用类</FONT><FONT SIZE=3>CDC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>DrawIcon</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>绘制由</FONT><FONT SIZE=3>m_hIcon</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所标识的图标。</P>
<P ALIGN="JUSTIFY">如果当前窗口并未被最小化，类</FONT><FONT SIZE=3>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT SIZE=3>OnPaint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数调用基类提供的相应成员函数。</P><DIR>

</FONT><FONT FACE="Arial" SIZE=3><P>(5)&#9;</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3>消息处理函数</FONT><FONT FACE="Arial" SIZE=3>OnQueryDragIcon</P></DIR>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">消息处理函数</FONT><FONT SIZE=3>OnQueryDragIcon</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>只是简单的返回句柄</FONT><FONT SIZE=3>m_hIcon</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，并将其类型强制转换为</FONT><FONT SIZE=3>HCURSOR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">程序所使用的资源如图</FONT><FONT SIZE=3>4.9</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image239.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image239.gif" WIDTH=215 HEIGHT=70></P>
<OL TYPE="a">

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><LI>类</FONT><FONT SIZE=1>CAboutDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>所对应的对话框</LI></P></OL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image240.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image240.gif" WIDTH=184 HEIGHT=106></P>
</FONT><FONT SIZE=1><P ALIGN="CENTER">b. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>类</FONT><FONT SIZE=1>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>所对应的对话框</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image241.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image241.gif" WIDTH=133 HEIGHT=133></P>
</FONT><FONT SIZE=1><P ALIGN="CENTER">c. </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>对话框</FONT><FONT SIZE=1>CDialogDemoDlg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>所用的图标</P>
<P ALIGN="CENTER">图</FONT><FONT SIZE=1>4. 9 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>在应用程序</FONT><FONT SIZE=1>DialogDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>中所用到的资源</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">现在即可编译并运行应用程序</FONT><FONT SIZE=3>DialogDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，其结果如图</FONT><FONT SIZE=3>4.10</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。通过单击控制菜单中的项“关于</FONT><FONT SIZE=3>DialogDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”，可以打开如图</FONT><FONT SIZE=3>4.9</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中</FONT><FONT SIZE=3>a</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示的对话框。而无论单击“确定”还是“取消”，应用程序</FONT><FONT SIZE=3>DialogDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>都将被关闭。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image242.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image242.gif" WIDTH=184 HEIGHT=106></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>4. 10 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>应用程序</FONT><FONT SIZE=1>DialogDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>的运行结果</P>
</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER"><A NAME="_Toc425696872">第五节</FONT><FONT SIZE=4> </FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>小结</A></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">本章详细的分析了由</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>生成的一个基于对话框的应用程序，这是进行下一步对控件的学习的基础。同时，我们还借用该程序说明了使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编写的应用程序的结构，涉及到了以下的一些内容：</P>

<UL>
<P ALIGN="JUSTIFY"><LI>从</FONT><FONT SIZE=3>CWinApp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生的应用程序类</LI></P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY"><LI>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序的消息映射机制和方法</LI></P>
<P ALIGN="JUSTIFY"><LI>从</FONT><FONT SIZE=3>CDialog</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生的对话框类</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这里</FONT><FONT SIZE=3>CDialog</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>又从</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生</FONT><FONT SIZE=3>)</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">我们在这些内容上花费了大量的篇幅，但就算是这样还是未能将其完全的阐述清楚。它们是一些比较复杂，但并不神秘的东西，然而一旦理解了这些东西，那么你对</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的理解立刻就会上升一个层次，从而在实际编程的过程中获益更多。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在本章，我们对代码进行几乎是逐行逐字的讲解和说明，这是考虑到初学者对于</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的编程方式比较陌生的情况。在后面几章的内容中，我们对于一些关系不是很紧密的内容不再作详细的讲述，你需要随时查阅</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的联机文档，好在里面有数不清的资源可以利用。但是应该记住一点，我们建议你弄懂示例程序中的每一行所完成或实现的功能，只有这样，才能充分利用这些经过实践证明是可行的编程方法和技巧，从而在比较短的时期内很快的提高自己的编程水平和能力。</P></FONT></BODY>
</HTML>
