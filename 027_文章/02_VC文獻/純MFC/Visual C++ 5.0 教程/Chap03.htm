<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb_2312-80">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>第三章 Win32应用程序设计</TITLE>
<META NAME="Template" CONTENT="D:\Office95\Template\Manuscripts\32开图书模板.dot">
</HEAD>
<BODY>

<FONT FACE="黑体" LANG="ZH-CN" SIZE=5><P ALIGN="CENTER"><A NAME="_Toc425696652">第三章</FONT><FONT FACE="Arial" SIZE=5> Win32</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=5>应用程序设计</A></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在过去，进行</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>程序设计是一件痛苦异常的事情，原因是那时候还没有现在的这些设计精美的应用程序开发工具。在今天，一个对</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>程序运行的内部机制几乎一无所知的初入门者，只需要通过不到一天的学习，也可以使用如</FONT><FONT SIZE=3>Visual Basic</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>之类的程序开发工具创建出功能完整的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序。这在几年前还是一件不可思议的事，因为即使是一个熟练掌握</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言的程序员，在当时差不多需要半年的学习才可以较全面的掌握</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的编程技术，而且，与在</FONT><FONT SIZE=3>DOS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>环境下编程相比，急剧膨胀的程度代码大大增加了程序调试的困难，从而使得编写一个出色的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序要比编写一个出色的</FONT><FONT SIZE=3>DOS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>需要考虑多得多的东西。</P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>Microsoft</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的另一种易学易用的编程工具</FONT><FONT SIZE=3>Visual Basic</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，从某种角度说，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>程序不是编出来的，而是由程序员画出来的。但是要知道，一个出色的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的应用程序并不仅在于在屏幕上绘出程序的各个窗口和在窗口中恰当的安排每一个控件。对于具有一定基础的程序员而言，更重要的内容在于知道</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序的运行机制，以及它们之间以何种方式来进行通信，然而，明确自己在编写</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>时所需做的工作是哪一些。换句话说，我们需要透过</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>漂亮的图形用户界面，认清在底层所发生的每一件事情。然而，这并非是一件容易的事。虽然，使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>AppWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，我们仍可能只需要回答几个简单的问题和添加少数的几条代码就能够生成功能完整的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序。但是记住，没有一个成功的商业软件是使用这样的方式生成的。同时，也只有深入的理解了</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序框架的运行机制，才可能用好和用活这一工具，才能达到熟悉掌握</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的境界。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">尽管说</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序框架提供的是面向对象的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编程接口，这和传统的使用</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言和</FONT><FONT SIZE=3>SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来进行的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序设计有着很大的不同，但是从底层来说，其中的大部分功能仍是通过调用最基本的</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来实现的。其中最重要的一点是，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序的运行机制仍然没有改变，它们仍然是通过消息来和操作系统，进而和用户进行交互的事件驱动的应用程序。</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对这一切进行了比较彻底的封装，它们隐藏在你所看不见的背面。即使你对这一切一无所知，你仍可以在</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来进行程序设计。但是，经验表明，理解这一切的最好的方式是回过头去，看一看这些内容在</FONT><FONT SIZE=3>SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编写的应用程序是如何实现的，然后，再看一看在</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中是如何把它们一层一层的与程序员隔离开的。</P>
<P ALIGN="JUSTIFY">因此，在本章中介绍相对已“过时”的</FONT><FONT SIZE=3>Win32 SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编程，并非是说以后也使用</FONT><FONT SIZE=3>SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来编写应用程序，而在于让你通过它们更深入的从</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的内部了解</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，并且，对于某些术语和概念的说明和澄清，也有助于你以后理解很多的东西。如果你一开始对这些东西不感兴趣，那么，你可以先暂时跳过此章，继续阅读本书的其它部分。当你对于</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的某些问题感到不解，或者想知道</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>究竟是如何工作的时候，再回过头来补充这些知识，也是完全可以的。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">本章包括以下的内容：</P>

<UL>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY"><LI>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序的消息处理</LI></P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY"><LI>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>SDK</LI></P>
<P ALIGN="JUSTIFY"><LI>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数</LI></P>
<P ALIGN="JUSTIFY"><LI>窗口和窗口过程</LI></P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY"><LI>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位编程的特点</LI></P></UL>

</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER"><A NAME="_Toc425696653">第一节</FONT><FONT SIZE=4> </FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>事件驱动的应用程序</A></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">类似的话已在很多书籍中说过了无数遍，以至于每一个正在或试图进行</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编程的人都耳熟能详：</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序是事件驱动</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或称作消息驱动</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的应用程序。</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是一个多任务的操作系统，也就是说，在同一时刻，在</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中有着多个应用程序的实例正在运行，比如说这时我正在打开字处理软件</FONT><FONT SIZE=3>Word</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来编写这本书的书稿，同时，还打开了</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的集成开发环境</FONT><FONT SIZE=3>Microsoft Developer Studio</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来调试书中的示例程序，而且，后台还在放着歌曲。在这样的一个操作系统中，不可能像过去的</FONT><FONT SIZE=3>DOS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>那样，由一个应用程序来享用所有的系统资源，这些资源是由</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>统一管理的。那么，特定的应用程序如何获得用户输入的信息呢？事实上，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>时刻监视着用户的一举一动，并分析用户的动作与哪一个应用程序相关，然后，将用户的动作以消息的形式发送给该应用程序，应用程序时刻等待着消息的到来，一但发现它的消息队列中有未处理的消息，就获取并分析该消息，最后，应用程序根据消息所包含的内容采取适当的动作来响应用户所作的操作。举一个例子来说明上面的问题，假设我们编了一个程序，该程序有一个</FONT><FONT SIZE=3>File</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单，那么，在运行该应用程序的时候，如果用户单击了</FONT><FONT SIZE=3>File</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单，这个动作将被</FONT><FONT SIZE=3>Windows (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>而不是应用程序本身！</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所捕获，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>经过分析得知这个动作应该由上面所说的那个应用程序去处理，既然是这样，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就发送了个叫做</FONT><FONT SIZE=3>WM_COMMAND</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的消息给应用程序，该消息所包含的信息告诉应用程序：“用户单击了</FONT><FONT SIZE=3>File</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单”，应用程序得知这一消息之后，采取相应的动作来响应它，这个过程称为消息处理。</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为每一个应用程序</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>确切地说是每一个线程</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>维护了相应的消息队列，应用程序的任务就是不停的从它的消息队列中获取消息，分析消息和处理消息，直到一条接到叫做</FONT><FONT SIZE=3>WM_QUIT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息为止，这个过程通常是由一种叫做消息循环的程序结构来实现的。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所能向应用程序发送的消息多达数百种，但是，对于一般的应用程序来说，只是其中的一部分有意义，举一个例子，如果你的应用程序只使用鼠标，那么如</FONT><FONT SIZE=3>WM_KEYUP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>WM_KEYDOWN</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>WM_CHAR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等消息就没有任何意义，也就是说，应用程序中事实上不需要处理这些事件，对于这些事件，只需要交给</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>作默认的处理即可。因此，在应用程序中，我们需要处理的事件只是所有事件中的一小部分。</P>
<P ALIGN="JUSTIFY">图</FONT><FONT SIZE=3>3.1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>给出了一般</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序的执行流程。</P>
<P ALIGN="JUSTIFY">因此，从某种角度上来看，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序是由一系列的消息处理代码来实现的。这和传统的过程式编程方法很不一样，编程者只能够预测用户所利用应用程序用户界面对象所进行的操作以及为这些操作编写处理代码，却不可以这些操作在什么时候发生或者是以什么顺序来发生，也就是说，我们不可能知道什么消息会在什么时候以什么顺序来临。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image243.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image243.gif" WIDTH=543 HEIGHT=440></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>3. 1 Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>应用程序的基本流程</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>程序在处理消息时使用了一种叫做回调函数</FONT><FONT SIZE=3>(callback function)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的特殊函数。回调函数由应用程序定义，但是，在应用程序中并没有调用回调函数的代码，回调函数是供操作系统或者其子系统调用的，这种调用通常发生在某一事件发生，或者在窗口或字体被枚举时。典型的回调函数有窗口过程、对话框过程和钩子函数。其中的窗口过程和对话框过程将在本章后面的内容中讲述。</P>
</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER"><A NAME="_Toc425696654">第二节</FONT><FONT SIZE=4> Win32 API</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>和</FONT><FONT SIZE=4>SDK</A></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">说到</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编程，就不能不谈到</FONT><FONT SIZE=3>Windows API (Windows Application Programming Interface</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序编程接口</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，它是所有</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序的根本之所在。简单的说，</FONT><FONT SIZE=3>API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就是一系列的例程，应用程序通过调用这些例程来请求操作系统完成一些低级服务。在</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这样的图形用户界面中，应用程序的窗口、图标、菜单和对话框等就是由</FONT><FONT SIZE=3>API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来管理和维护的。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">Windows API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>具有两种基本类型：</FONT><FONT SIZE=3>Win16 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。两者在很多方面非常相像，但是</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>除了几乎包括了</FONT><FONT SIZE=3>Win16 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的所有内容以外，还包括很多的其它内容。</FONT><FONT SIZE=3>Windows API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>依靠三个主要的核心组件提供</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的大部分函数，在</FONT><FONT SIZE=3>Win16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，它们具有不同的名称，如表</FONT><FONT SIZE=3>3.1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示。</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>3. 1 Win16</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>和</FONT><FONT FACE="Arial" SIZE=1>Win32</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>的核心组件</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=511>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">Win16 API</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">Win32 API</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">说明</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">USER.EXE</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">USER32.DLL</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">负责窗口的管理，包括消息、菜单、光标、通信、计时器和其它与控制窗口显示</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">GDI.EXE</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">GDI32.DLL</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">提供图形设备接口，管理用户界面和图形绘制，包括</FONT><FONT SIZE=1>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>元文件、位图、设备描述表和字体等</FONT></TD>
</TR>
<TR><TD WIDTH="20%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">KRNL386.EXE</FONT></TD>
<TD WIDTH="22%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">KERNEL32.DLL</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">处理存储器低层功能、任务和资源管理等</FONT><FONT SIZE=1>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>核心服务</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">虽然</FONT><FONT SIZE=3>Win16 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>组件带有</FONT><FONT SIZE=3>.EXE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的扩展名，但是它们事实都是动态链接库</FONT><FONT SIZE=3>(.DLL)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，不能单独运行。其它一些非核心的</FONT><FONT SIZE=3>Windows API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>由其它组件所提供的</FONT><FONT SIZE=3>DLL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来实现，这些组件包括通用对话框、打印、文件压缩、版本控制以及多媒体支持等。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">Windows SDK (Windows Software Development Kit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>软件开发工具包</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Windows API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>紧密联系，它是一套帮助</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言程序员创建</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序的工具，在</FONT><FONT SIZE=3>Windows SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中包括了以下几个组成部分：</P>

<UL>
<P ALIGN="JUSTIFY"><LI>大量的在线帮助，这些帮助描述了</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编程所可能用到的函数、消息、结构、宏及其它资源</LI></P>
<P ALIGN="JUSTIFY"><LI>各种编程工具，如对话框编辑器及图象编辑器等</LI></P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY"><LI>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>库及头文件</LI></P>
<P ALIGN="JUSTIFY"><LI>使用</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言编写的示例程序</LI></P></UL>

<P ALIGN="JUSTIFY">该工具包的最新版本就是我们正在使用的</FONT><FONT SIZE=3>Win32 SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，在安装了</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的同时，</FONT><FONT SIZE=3>Win32 SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>也安装到你的计算机上了。尽管</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>提供了对</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的比较完整的封装，但是，在某些情况下，我们更倾向于直接调用</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，因为这有时候可以获得更高的效率，并且有着更大的自由度。而且，使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编写的新风格的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序的工作方式基本上与使用</FONT><FONT SIZE=3>SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编写的同一程序一样，它们往往有着很多的共同之处，只是使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>更加的方便，因为它隐藏了大量的复杂性。</P>
<P ALIGN="JUSTIFY">前面提到过，面向对象的编程方式是当前最流行的程序设计方法，但是，</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>本身却是基于</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言的过程式编程的，</FONT><FONT SIZE=3>SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的最主要的不同之处也就是以</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>与</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>之间的差别，使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进行</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序设计需要面向对象的编程思想和方法，好在我们已经在前面这此进行了大量的铺垫。</P>
</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER"><A NAME="_Toc425696655">第三节</FONT><FONT SIZE=4> </FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>使用</FONT><FONT SIZE=4>SDK</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>编写</FONT><FONT SIZE=4>Windows</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>应用程序</A></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">传统的</FONT><FONT SIZE=3>DOS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>程序以</FONT><FONT SIZE=3>main</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数作为进入程序的初始入口点，在</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序中，</FONT><FONT SIZE=3>main</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数被</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数取而代之，</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数的原型如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>int WINAPI WinMain (HINSTANCE hInstance,&#9;&#9;// 当前实例句柄</P>
<P>&#9;&#9;&#9;&#9;&#9;HINSTANCE hPrevInstance,&#9;// 前一实例句柄</P>
<P>&#9;&#9;&#9;&#9;&#9;LPSTR lpCmdLine,&#9;&#9;&#9;// 指向命令行参数的指针</P>
<P>&#9;&#9;&#9;&#9;&#9;int nCmdShow)&#9;&#9;&#9;&#9;// 窗口的显示状态</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这里出现了一个新的名词“句柄”</FONT><FONT SIZE=3>(handle)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，所谓的句柄是一个标识对象的变量，或者是一个对操作系统资源的间接引用。</P>
<P ALIGN="JUSTIFY">在上面的函数原型中，我们看到了一些“奇怪”的数据类型，如前面的</FONT><FONT SIZE=3>HINSTANCE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LPSTR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等，事实上，很多这样的数据类型只是一些基本数据类型的别名，表</FONT><FONT SIZE=3>3.2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>列出了一些在</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编程中常用的基本数据类型的别名，表</FONT><FONT SIZE=3>3.3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>列出了常用的预定义句柄，它们的类型均为</FONT><FONT SIZE=3>void *</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，即一个</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位指针。</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>3. 2 Windows</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>基本数据类型</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=535>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>中所用的数据类型</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">对应的基本数据类型</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">说明</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">BOOL</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">int</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">布尔值</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">BSTR</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">unsigned short *</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位字符指针</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">BYTE</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">unsigned char</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">8</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位无符号整数</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">COLORREF</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">unsigned long</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">用作颜色值的</FONT><FONT SIZE=1>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位值</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">DWORD</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">unsigned long</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位无符号整数，段地址和相关的偏移地址</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">LONG</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">long</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位带符号整数</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">LPARAM</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">long</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">作为参数传递给窗口过程或回调函数的</FONT><FONT SIZE=1>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位值</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">LPCSTR</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">const char *</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">指向字符串常量的</FONT><FONT SIZE=1>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位指针</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">LPSTR</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">char *</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">指向字符串的</FONT><FONT SIZE=1>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位指针</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">LPCTSTR</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">const char *(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>注</FONT><FONT SIZE=1>1)</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">指向可移植的</FONT><FONT SIZE=1>Unicode</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>和</FONT><FONT SIZE=1>DBCS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>字符串常量的</FONT><FONT SIZE=1>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位指针</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">LPTSTR</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">char *(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>注</FONT><FONT SIZE=1>1)</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">指向可移植为</FONT><FONT SIZE=1>Unicode</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>和</FONT><FONT SIZE=1>DBCS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>字符串的</FONT><FONT SIZE=1>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位指针</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">LPVOID</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">void *</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">指向未定义类型的</FONT><FONT SIZE=1>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位指针</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">LRESULT</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">long</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">来自窗口过程或回调函数的</FONT><FONT SIZE=1>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位返回值</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">UINT</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">unsigned int</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位无符号整数</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">WNDPROC</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">long (__stdcall *)(void *,unsigned int,unsigned int,long)(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>注</FONT><FONT SIZE=1>2)</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">指向窗口过程的</FONT><FONT SIZE=1>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位指针</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">WORD</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">unsigned short</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位无符号整数</FONT></TD>
</TR>
<TR><TD WIDTH="17%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">WPARAM</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">unsigned int</FONT></TD>
<TD WIDTH="58%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">当作参数传递给窗口过程或回调函数的</FONT><FONT SIZE=1>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>位值</FONT></TD>
</TR>
</TABLE>
</CENTER></P>
<DIR>
<DIR>
<DIR>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">注</FONT><FONT SIZE=1>1:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>这是在</FONT><FONT SIZE=1>DBCS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>版本下的情况，在</FONT><FONT SIZE=1>Unicode</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>版本下</FONT><FONT SIZE=1>LPCTSTR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>和</FONT><FONT SIZE=1>LPTSTR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>将代表其它的数据类型。</P>
<P ALIGN="JUSTIFY">注</FONT><FONT SIZE=1>2:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>事实上，</FONT><FONT SIZE=1>WNDPROC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>被定义为</FONT><FONT SIZE=1>LRESULT (CALLBACK*)(HWND, UINT, WPARAM, LPARAM)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>，这个定义最终被编译器解释为</FONT><FONT SIZE=1>long (__stdcall *)(void *,unsigned int,unsigned int,long)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>。</P></DIR>
</DIR>
</DIR>

</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>3. 3 Windows</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>公用句柄类型</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=337>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">句柄类型</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">说明</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HBITMAP</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">保存位图信息的内存域的句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HBRUSH</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">画刷句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HCTR</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">子窗口控件句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HCURSOR</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">鼠标光标句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HDC</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">设备描述表句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HDLG</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">对话框句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HFONT</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">字体句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HICON</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">图标句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HINSTANCE</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">应用程序的实例句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HMENU</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">菜单句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HMODULE</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">模块句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HPALETTE</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">颜色调色板句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HPEN</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">在设备上画图时用于指明线型的笔的句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HRGN</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">剪贴区域句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HTASK</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">独立于已执行任务的句柄</FONT></TD>
</TR>
<TR><TD WIDTH="28%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">HWND</FONT></TD>
<TD WIDTH="72%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">窗口句柄</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">查看</FONT><FONT SIZE=3>Win32 SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>文档或者浏览</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>头文件</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如</FONT><FONT SIZE=3>windef.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>ctype.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>以及</FONT><FONT SIZE=3>winnt.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以获得关于其它数据类型的定义，这些定义往往使用了</FONT><FONT SIZE=3>#define</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>typedef</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等关键字。</P>
<P ALIGN="JUSTIFY">这里解释什么是应用程序的一个实例</FONT><FONT SIZE=3>(instance)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。最简单的理解可以用下面的例子来说明：比如说已经在</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中打开了一个“写字板”</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以在“开始”菜单中的“程序</FONT><FONT SIZE=3>|</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>附件”下面找到它的快捷方式</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，现在你需要从另一篇文章里复制一部分内容到你正在写的这篇文章中，那么，你可以再打开一个“写字板”</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>注意写字板不是一个多文档应用程序，不能像在</FONT><FONT SIZE=3>Word</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中那样打开多个不同的文件</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，然后从该写字板中复制文件的内容到在前一个写字板内打开的文章中。这里，我们多次运行了同一个应用程序，在这个例子中，我们将所打开的两个写字板叫做该应用程序的两个实例。对于实例的更精确</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>当然也要比上面的例子要更难懂得多</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义，在</FONT><FONT SIZE=3>Win32 SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中是这样给出的：实例就是类中一特定对象类型的一个实例化对象</FONT><FONT SIZE=3>(instantiation)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，如一个特定的进程或线程，在多任务操作系统中，一个实例指所加载的应用程序或动态链接库的一份拷贝。刚开始时我们也许看不懂这一定义，不过没有关系，慢慢的就理解了。</FONT><FONT SIZE=3> </P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>尽管在前面给出的</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>函数的原型中包括了一个名为</FONT><FONT SIZE=3>hPrevInstance</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的</FONT><FONT SIZE=3>HINSTANCE</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>类型的参数，按照其字面上的意义，它所传递的是应用程序的前一个实例的句柄，但是，在</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>平台下，该参数的值总是为</FONT><FONT SIZE=3>NULL</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，而不管是否有当前应用程序的实例在运行。在过去的</FONT><FONT SIZE=3>Windows 3.x</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>环境下编程，我们常常使用下面的代码来检查应用程序是否已有一个实例在运行：</LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>if (!hPrevInstance)</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>// </FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>在此添加没有应用程序实例在运行时的所需执行的代码。</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>// </FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>对于大多数应用程序，我们常在这里注册窗口类。</LI></P>
<P ALIGN="JUSTIFY"><LI>}</LI></P></UL>
<DIR>
<DIR>

</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">然而，在</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>操作系统</FONT><FONT SIZE=3>――Windows 95</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Windows NT</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>以及其后续版本中，上面的</FONT><FONT SIZE=3>if</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>条件体中的代码总会被执行，因为</FONT><FONT SIZE=3>hPrevInstance</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>总是为</FONT><FONT SIZE=3>NULL</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，因此</FONT><FONT SIZE=3>!hPrevInstance</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>恒为真。</P>
<P ALIGN="JUSTIFY">之所以这样，是因为在</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>环境下，每一个应用程序的实例都有自已独立的地址空间，因此，它们之间互相独立，互不干涉。但是，对于一些应用程序，只需要而且只应该有一个实例在运行。什么情况下会是这样呢？假设我们编写了一个应用程序，在默认情况下，该应用程序将在后台运行，通过按下程序所定义的某一个热键，应用程序将被激活。对于这样的应用程序，在同一时该只应该有一个实例在运行。另外，像</FONT><FONT SIZE=3>Windows NT</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>下在任务管理器，在同一时刻也只可以有一个实例在运行。</P>
<P ALIGN="JUSTIFY">使用下面的技巧可以保证在同一时刻只有应用程序的一个实例：</P></DIR>
</DIR>


<UL>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>#include "windows.h"</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI></LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>#define VK_X 0x58</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI></LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>int WINAPI WinMain (HINSTANCE hInstance,</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;&#9;&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>HINSTANCE hPrevInstance,</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;&#9;&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>LPSTR lpCmdLine,</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;&#9;&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>int nCmdShow)</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>if (!CreateMutex(NULL,TRUE,"No Previous Instance!"))</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>MessageBox(NULL,"</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>创建</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>Mutex</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>失败</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>!","NoPrev",MB_OK|MB_SYSTEMMODAL);</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return FALSE;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;}</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>if (GetLastError()==ERROR_ALREADY_EXISTS)</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>MessageBox(NULL,"</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>已有</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>NoPrev</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>的一个实例在运行</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>, </FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>当前实例将被终止</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>!",</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>"NoPrev",MB_OK|MB_SYSTEMMODAL);</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return FALSE;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;}</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>if(!RegisterHotKey(NULL,0x0001,MOD_CONTROL|MOD_SHIFT,VK_X))</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>MessageBox(NULL,"</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>注册热键</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>Ctrl+Shift+X</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>失败</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>!",</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>"NoPrev",MB_OK|MB_SYSTEMMODAL);</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return FALSE;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;}</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>MessageBox(NULL,"NoPrev</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>已启动</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>!\n\n</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>按下热键</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>Ctrl+Shift+X</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>将终止</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>NoPrev.",</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>"NoPrev",MB_OK|MB_SYSTEMMODAL);</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>MSG msg;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>while (GetMessage(&amp;msg,NULL,0,0))</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>switch (msg.message)</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>case WM_HOTKEY:</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>if (int(msg.wParam)==0x0001)</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>if (MessageBox(NULL,"</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>终止</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>NoPrev?",</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;&#9;&#9;&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>"NoPrev",MB_YESNO|MB_SYSTEMMODAL)==IDYES)</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;&#9;&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return TRUE;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;}</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;}</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return TRUE;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>}</LI></P></UL>
<DIR>
<DIR>

</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的代码是一个功能完整的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>应用程序，其中用到了一些到目前为止我们还未讲述到的内容。程序定义了热键</FONT><FONT SIZE=3>Ctrl+Shift+X</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，当按下该热键时将终止该程序。由于程序中没有包括任何窗口，因此这是唯一的一种正常终止应用程序的方法。当程序</FONT><FONT SIZE=3>NoPrev</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>正在后台运行时，如果用户按下了组合键</FONT><FONT SIZE=3>Ctrl+Shift+X</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>将向程序主线程的消息队列中发送一条称为</FONT><FONT SIZE=3>WM_HOTKEY</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的消息，当程序收到这条消息时，即弹出了消息框询问是否终止</FONT><FONT SIZE=3>NoPrev</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。上面的说明将有助于你理解以上代码，但是我们目前对止并不做要求。这里，只需要注意下面的代码：</P></DIR>
</DIR>


<UL>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>if (!CreateMutex(NULL,TRUE,"No Previous Instance!"))</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>MessageBox(NULL,"</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>创建</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>Mutex</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>失败</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>!","NoPrev",MB_OK|MB_SYSTEMMODAL);</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return FALSE;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>}</LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>if (GetLastError()==ERROR_ALREADY_EXISTS)</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>MessageBox(NULL,"</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>已有</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>NoPrev</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>的一个实例在运行</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>, </FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1>当前实例将被终止</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>!",</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>"NoPrev",MB_OK|MB_SYSTEMMODAL);</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return FALSE;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>}</LI></P></UL>
<DIR>
<DIR>

</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在上面的代码中，我们先调用</FONT><FONT SIZE=3>CreateMutex</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>创建一个名为“</FONT><FONT SIZE=3>No Previous Instance</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>”的命名互斥对象</FONT><FONT SIZE=3>(named mutex object)</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，如果该对象名已存在</FONT><FONT SIZE=3>(</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>注意这时函数</FONT><FONT SIZE=3>CreateMutex</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>仍返回真值</FONT><FONT SIZE=3>TRUE)</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，则随后调用的</FONT><FONT SIZE=3>GetLastError</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>函数将返回</FONT><FONT SIZE=3>ERROR_ALREADY_EXISTS</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，由此得知已有一个应用程序的实例正在运行。从而弹出消息框提醒用户，然后终止应用程序的当前实例。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>
</DIR>

<P ALIGN="JUSTIFY">在上面的</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数原型中的另一个奇怪的标识符为</FONT><FONT SIZE=3>WINAPI</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这是一个在</FONT><FONT SIZE=3>windef.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>头文件中定义的宏，在当前版本</FONT><FONT SIZE=3>Win32 SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，</FONT><FONT SIZE=3>WINAPI</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被定义为</FONT><FONT SIZE=3>FAR PASCAL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，因此，使用</FONT><FONT SIZE=3>FAR PASCAL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>同使用</FONT><FONT SIZE=3>WINAPI</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>具有同样的效果，但是，我们强烈建议你使用</FONT><FONT SIZE=3>WINAPI</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来代替以前常用的</FONT><FONT SIZE=3>FAR PASCAL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，因为</FONT><FONT SIZE=3>Microsoft</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不保证</FONT><FONT SIZE=3>FAR PASCAL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>能够在将来的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>版本中正常工作。在目前情况下，和</FONT><FONT SIZE=3>FAR PASCAL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等价的标识符还有</FONT><FONT SIZE=3>CALLBACK (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用在如窗口过程或对话框过程之类的回调函数前</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>APIENTRY</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等。它们对编译器而言都是一回事，最终将被解释为</FONT><FONT SIZE=3>__stdcall</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。在</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>环境下编程，会遇到很多这样的情况，注意不要混淆它们。</P>
<P ALIGN="JUSTIFY">一般情况下，我们应该在</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数中完成下面的操作：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">1.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>注册窗口类；</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">2.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>创建应用程序主窗口；</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">3.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进入应用程序消息循环。</P>
<P ALIGN="JUSTIFY">接下来我们将依次讨论这些内容。</P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序中，每一个窗口都必须从属于一个窗口类，窗口类定义了窗口所具有的属性，如它的样式、图标、鼠标指针、菜单名称及窗口过程名等。在注册窗口类前，我们先创建一个类型为</FONT><FONT SIZE=3>WNDCLASS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的结构，然后在该结构对象中填入窗口类的信息，最后将它传递给函数</FONT><FONT SIZE=3>RegisterClass</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，整个过程如下面的代码所示：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>WNDCLASS wc;</P>

<P>// 填充窗口类信息</P>
<P>wc.style=CS_HREDRAW|CS_VREDRAW;</P>
<P>wc.lpfnWndProc=WndProc;</P>
<P>wc.cbClsExtra=0;</P>
<P>wc.cbWndExtra=0;</P>
<P>wc.hInstance=hInstance;</P>
<P>wc.hIcon=LoadIcon(NULL,IDI_APPLICATION);</P>
<P>wc.hCursor=LoadCursor(NULL,IDC_ARROW);</P>
<P>wc.hbrBackground=GetStockObject(WHITE_BRUSH);</P>
<P>wc.lpszMenuName=NULL;</P>
<P>wc.lpszClassName="SdkDemo1";</P>

<P>// 注册窗口类</P>
<P>RegisterClass(&amp;wc);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">下面解释一下结构</FONT><FONT SIZE=3>WNDCLASS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中各成员的含义：</P><DIR>
<DIR>
<DIR>
<DIR>
<DIR>

</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">style:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指定窗口样式。该样式可以为一系列屏蔽位的按位或，在前面的例子中，</FONT><FONT SIZE=3>CS_HREDRAW</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>表示当窗口用户区宽度改变时重绘整个窗口，而</FONT><FONT SIZE=3>CS_VREDRAW</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>则表则表示当窗口用户区高度改变时重绘整个窗口。对于其它的窗口样式，请参阅</FONT><FONT SIZE=3>SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中关于</FONT><FONT SIZE=3>WNDCLASS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的联机文档。</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>顺便说一句，请注意该成员的大小写，它是小写的</FONT><FONT SIZE=3>style</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，而不是</FONT><FONT SIZE=3>Style</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</FONT><FONT SIZE=3>)</P>
<P ALIGN="JUSTIFY">lpfnWndProc:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向窗口过程的指针。关于窗口过程我们将以后面的内容中讲述。在前面的例子中，我们使用名为</FONT><FONT SIZE=3>WndProc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的窗口过程。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">cbClsExtra:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指定在窗口类结构之后分配的附加字节数。操作系统将这些字节初始化为</FONT><FONT SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">cbWndExtra:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指定在窗口实例之后分配的附加字节数。操作系统将这些字节初始化为</FONT><FONT SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。如果应用程序使用</FONT><FONT SIZE=3>WNDCLASS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>结构注册一个使用资源文件中的</FONT><FONT SIZE=3>CLASS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指令创建的对话框，那么</FONT><FONT SIZE=3>cbWndExtra</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>必须被设置为</FONT><FONT SIZE=3>DLGWINDOWEXTRA</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">hInstance :&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>标识该类的窗口过程所属的实例。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">hIcon :&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>标识类图标。该成员必须为一个图标资源的句柄。如果该成员为</FONT><FONT SIZE=3>NULL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，则应用程序必须在用户最小化应用程序窗口时绘制图标。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">hCursor :&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>标识类鼠标指针。该成员必须为一个光标资源的句柄，如果该成员为</FONT><FONT SIZE=3>NULL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，当鼠标移进应用程序窗口时应用程序必须显式指定指针形状。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">hbrBackground:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>标识类背景刷子。该成员可以为一个用来绘制背景的画刷句柄，或者为标准系统颜色值之一。</FONT><FONT SIZE=3> </P>
<P ALIGN="JUSTIFY">lpszMenuName:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向一以</FONT><FONT SIZE=3>NULL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>结尾的字符串的指针，该字符串指定了类菜单的资源名称。如果在资源名称为的菜单为一个整数所标识，则可以使用</FONT><FONT SIZE=3>MAKEINTRESOURCE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>宏将其转换为一个字符串；如果该成员为</FONT><FONT SIZE=3>NULL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，则属于该类的窗口无默认菜单。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">lpszClassName:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向一个以</FONT><FONT SIZE=3>NULL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>结尾的字符串或为一个原子。如果该参数为一个原子，那么它必须是一个使用</FONT><FONT SIZE=3>GlobalAddAtom</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数创建的全局原子；如果为一个字符串，该字符器将成员窗口类名。</P></DIR>
</DIR>
</DIR>
</DIR>
</DIR>


<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>这里多次提到窗口类这一名词，但是它和前面常说的</FONT><FONT SIZE=3>C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>类没有任何联系。窗口类只表示了窗口的类型，它完全不是面向对象意义上的类，因为它不支持面向对象技术中的继承及多态等。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在使用</FONT><FONT SIZE=3>RegisterClass</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>注册窗口类成功之后，即可以使用该窗口类创建并显示应用程序的窗口。这个过程如下面的代码所示：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>// 创建应用程序主窗口</P>
<P>hWnd=CreateWindow ("SdkDemo1",&#9;&#9;&#9;&#9;&#9;// 窗口类名</P>
<P>&#9;&#9;&#9;&#9;   "第一个Win32 SDK应用程序",&#9;// 窗口标题</P>
<P>&#9;&#9;&#9;&#9;   WS_OVERLAPPEDWINDOW,&#9;&#9;// 窗口样式</P>
<P>&#9;&#9;&#9;&#9;   CW_USEDEFAULT,&#9;&#9;&#9;&#9;// 初始化 x 坐标</P>
<P>&#9;&#9;&#9;&#9;   CW_USEDEFAULT,&#9;&#9;&#9;&#9;// 初始化 y 坐标</P>
<P>&#9;&#9;&#9;&#9;   CW_USEDEFAULT,&#9;&#9;&#9;&#9;// 初始化窗口宽度</P>
<P>&#9;&#9;&#9;&#9;   CW_USEDEFAULT,&#9;&#9;&#9;&#9;// 初始化窗口高度</P>
<P>&#9;&#9;&#9;&#9;   NULL,&#9;&#9;&#9;&#9;&#9;&#9;// 父窗口句柄</P>
<P>&#9;&#9;&#9;&#9;   NULL,&#9;&#9;&#9;&#9;&#9;&#9;// 窗口菜单句柄</P>
<P>&#9;&#9;&#9;&#9;   hInstance,&#9;&#9;&#9;&#9;&#9;// 程序实例句柄</P>
<P>&#9;&#9;&#9;&#9;   NULL);&#9;&#9;&#9;&#9;&#9;&#9;// 创建参数</P>

<P>// 显示窗口</P>
<P>ShowWindow(hWnd,SW_SHOW);</P>
<P>// 更新主窗口客户区</P>
<P>UpdateWindow(hWnd);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">由于上述代码均加上了详尽的注释，这里仅作一些简单的说明和强调。</FONT><FONT SIZE=3>CreateWindow</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数的原型是这样的：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>HWND CreateWindow(LPCTSTR lpClassName,&#9;// 指向已注册的类名</P>
<P>                  LPCTSTR lpWindowName,&#9;// 指向窗口名称</P>
<P>                  DWORD dwStyle,&#9;&#9;&#9;// 窗口样式</P>
<P>                  int x,&#9;&#9;&#9;&#9;&#9;// 窗口的水平位置</P>
<P>                  int y,&#9;&#9;&#9;&#9;&#9;// 窗口的垂直位置</P>
<P>                  int nWidth,&#9;&#9;&#9;&#9;// 窗口宽度</P>
<P>                  int nHeight,&#9;&#9;&#9;&#9;// 窗口高度</P>
<P>                  HWND hWndParent,&#9;&#9;&#9;// 父窗口或所有者窗口句柄</P>
<P>                  HMENU hMenu,&#9;&#9;&#9;&#9;// 菜单句柄或子窗口标识符</P>
<P>                  HANDLE hInstance,&#9;&#9;&#9;// 应用程序实例句柄</P>
<P>                  LPVOID lpParam,&#9;&#9;&#9;// 指向窗口创建数据的指针</P>
<P>                  );</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在前面的示例中，我们对</FONT><FONT SIZE=3>x</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>y</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>nWidth</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>nHeight</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>参数都传递了同一个值</FONT><FONT SIZE=3>CW_USEDEFAULT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，表示使用系统默认的窗口位置和大小，该常量仅对于重叠式窗口</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>即在</FONT><FONT SIZE=3>dwStype</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>样式中指定了</FONT><FONT SIZE=3>WS_OVERLAPPEDWINDOW</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，另一个常量</FONT><FONT SIZE=3>WS_TILEDWINDOW</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>有着相同的值</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>有效。对于</FONT><FONT SIZE=3>CreateWindows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数的其它内容，比如关于</FONT><FONT SIZE=3>dwStyle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>参数所用常量的详细参考请自行参阅</FONT><FONT SIZE=3>Win32 SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的文档。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>尽管</FONT><FONT SIZE=3>Windows 95</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>是一个</FONT><FONT SIZE=3>32</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>位的操作系统，但是，其中也保留了很多</FONT><FONT SIZE=3>16</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>位的特征，比如说，在</FONT><FONT SIZE=3>Windows 95</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>环境下，系统最多只可以有</FONT><FONT SIZE=3>16384</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>个窗口句柄。而在</FONT><FONT SIZE=3>Windows NT</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>下则无此限。然而，事实上，对于一般的桌面个人机系统来说，我们几乎不可能超过这个限制。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">创建窗口完成之后，</FONT><FONT SIZE=3>ShowWindows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>显示该窗口，第二个参数</FONT><FONT SIZE=3>SW_SHOW</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>表示在当前位置以当前大小激活并显示由第一个参数标识的窗口。然后，函数</FONT><FONT SIZE=3>UpdateWindows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>向窗口发送一条</FONT><FONT SIZE=3>WM_PAINT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息，以通知窗口更新其客户区。需要注意的是，由</FONT><FONT SIZE=3>UpdateWindows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>发送的</FONT><FONT SIZE=3>WM_PAINT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息将直接发送到窗口过程</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在上面的例子中是</FONT><FONT SIZE=3>WndProc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，而不是发送到进程的消息队列，因此，尽管这时应用程序的主消息循环尚未启动，但是窗口过程仍可接收到该</FONT><FONT SIZE=3>WM_PAINT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息并更新其用户区。</P>
<P ALIGN="JUSTIFY">在完成上面的步骤之后，进入应用程序的主消息循环。一般情况下，主消息循环具有下面的格式：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>while (GetMessage(&amp;msg,NULL,0,0))</P>
<P>{</P>
<P>&#9;TranslateMessage(&amp;msg);</P>
<P>&#9;DispatchMessage(&amp;msg);</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">主消息循环由对三个</FONT><FONT SIZE=3>API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数的调用和一个</FONT><FONT SIZE=3>while</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>结构组成。其中</FONT><FONT SIZE=3>GetMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从调用线程的消息队列中获取消息，并将消息放到由第一个参数指定的消息结构中。如果指定了第二个参数，则</FONT><FONT SIZE=3>GetMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>获取属于该参数指定的窗口句柄所标识的窗口的消息，如果该参数为</FONT><FONT SIZE=3>NULL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，则</FONT><FONT SIZE=3>GetMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>获取属于调用线程及属于该线程的所有窗口的消息。最后两个参数指定了</FONT><FONT SIZE=3>GetMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所获取消息的范围，如果两个参数均为</FONT><FONT SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，则</FONT><FONT SIZE=3>GetMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>检索并获取所有可以得到的消息。</P>
<P ALIGN="JUSTIFY">在上面的代码中，变量</FONT><FONT SIZE=3>msg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是一个类型为</FONT><FONT SIZE=3>MSG</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的结构对象，该结构体的定义如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>typedef struct tagMSG {     // msg</P>
<P>    HWND   hwnd;</P>
<P>    UINT   message;</P>
<P>    WPARAM wParam;</P>
<P>    LPARAM lParam;</P>
<P>    DWORD  time;</P>
<P>    POINT  pt; } MSG;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">下面解释各成员的含义：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">hwnd:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>标识获得该消息的窗口进程的窗口句柄。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">message:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指定消息值。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">wParam:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>其含义特定于具体的消息类型。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">lParam:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>其含义特定于具体的消息类型。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">time:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指定消息发送时的时间。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">pt:&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>以屏幕坐标表示的消息发送时的鼠标指针的位置。</P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>while</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>循环体中的</FONT><FONT SIZE=3>TranslateMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数将虚拟按键消息翻译为字符消息，然后将消息发送到调用线程的消息队列，在下一次调用</FONT><FONT SIZE=3>GetMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数或</FONT><FONT SIZE=3>PeekMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数时，该字符消息将被获取。</FONT><FONT SIZE=3>TranslateMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数将</FONT><FONT SIZE=3>WM_KEYDOWN</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>WM_KEYUP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>虚拟按键组合翻译为</FONT><FONT SIZE=3>WM_CHAR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>WM_DEADCHAR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，将</FONT><FONT SIZE=3>WM_SYSKEYDOWN</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>WM_SYSKEYUP</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>虚拟按键组合翻译为</FONT><FONT SIZE=3>WM_SYSCHAR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>WM_SYSREADCHAR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。需要注意的一点是，仅当相应的虚拟按键组合能够被翻译为所对应的</FONT><FONT SIZE=3>ASCII</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>字符时，</FONT><FONT SIZE=3>TranslateMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>才发送相应的</FONT><FONT SIZE=3>WM_CHAR</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息。</P>
<P ALIGN="JUSTIFY">如果一个字符消息被发送到调用线程的消息队列，则</FONT><FONT SIZE=3>TranlateMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回非零值，否则返回零值。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>与在</FONT><FONT SIZE=3>Windows 95</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>操作系统下不同，在</FONT><FONT SIZE=3>Windows NT</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>下，</FONT><FONT SIZE=3>TranslateMessage</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>对于功能键和光标箭头键也返回一个非零值。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">然后，函数</FONT><FONT SIZE=3>DispatchMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>将属于某一窗口的消息发送该窗口的窗口过程。这个窗口由</FONT><FONT SIZE=3>MSG</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>结构中的</FONT><FONT SIZE=3>hwnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员所标识的。函数的返回值为窗口过程的返回值，但是，我们一般不使用这个返回值。这里要注意的是，并不一定是所有属于某一个窗口的消息都发送给窗口的窗口过程，比如对于</FONT><FONT SIZE=3>WM_TIMER</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息，如果其</FONT><FONT SIZE=3>lParam</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>参数不为</FONT><FONT SIZE=3>NULL</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的话，由该参数所指定的函数将被调用，而不是窗口过程。</P>
<P ALIGN="JUSTIFY">如果</FONT><FONT SIZE=3>GetMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从消息队列中得到一个</FONT><FONT SIZE=3>WM_QUIT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息，则它将返回一个假值，从而退出消息循环，</FONT><FONT SIZE=3>WM_QUIT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息的</FONT><FONT SIZE=3>wParam</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>参数指定了由</FONT><FONT SIZE=3>PostQuitMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数给出的退出码，一般情况下，</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数返回同一值。</P>
<P ALIGN="JUSTIFY">下面我们来看一下程序主窗口的窗口过程</FONT><FONT SIZE=3>WndProc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。窗口过程名是可以由用户自行定义，然后在注册窗口类时在</FONT><FONT SIZE=3>WNDCLASS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>结构中指定。但是，一般来说，程序都把窗口过程命令为</FONT><FONT SIZE=3>WndProc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来类似的名称，如</FONT><FONT SIZE=3>MainWndProc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等，并不是一定要这样做，但是这样明显的有利于阅读，因此也是我们推荐的做法。窗口过程具有如下的原型：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>LRESULT WINAPI WndProc(HWND,UINT,WPARAM,LPARAM);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">或</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>LRESULT CALLBACK WndProc(HWND,UINT,WPARAM,LPARAM);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">对于编译器而言，两种书写形式都是一样的，它们都等价于</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>long __stdcall WndProc(void *,unsigned int,unsigned int,long)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">窗口过程使用了四个参数，在它被调用时</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>再强调一点，一般情况下，窗口过程是由操作系统调用，而不是由应用程序调用的，这就是我们为什么将它们称为回调函数的道理</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这四个参数对应于所发送消息结构的前四个成员。下面给出了一个窗口过程的例子：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>// WndProc 主窗口过程</P>
<P>LRESULT WINAPI WndProc (HWND hWnd,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;UINT msg,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;WPARAM wParam,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;LPARAM lParam)</P>
<P>{</P>
<P>&#9;HDC hdc;</P>
<P>&#9;RECT rc;</P>
<P>&#9;HPEN hPen,hPenOld;</P>
<P>&#9;HBRUSH hBrush,hBrushOld;</P>
<P>&#9;switch (msg)</P>
<P>&#9;{</P>
<P>&#9;case WM_PAINT:</P>
<P>&#9;&#9;hdc=GetDC(hWnd);</P>
<P>&#9;&#9;GetClientRect(hWnd,&amp;rc);</P>
<P>&#9;&#9;hPen=CreatePen(PS_SOLID,0,RGB(0,0,0));</P>
<P>&#9;&#9;hBrush=CreateHatchBrush(HS_DIAGCROSS,RGB(0,0,0));</P>
<P>&#9;&#9;hPenOld=SelectObject(hdc,hPen);</P>
<P>&#9;&#9;hBrushOld=SelectObject(hdc,hBrush);</P>
<P>&#9;&#9;Ellipse(hdc,rc.left,rc.top,rc.right,rc.bottom);</P>
<P>&#9;&#9;SelectObject(hdc,hPenOld);</P>
<P>&#9;&#9;SelectObject(hdc,hBrushOld);</P>
<P>&#9;&#9;ReleaseDC(hWnd,hdc);</P>
<P>&#9;&#9;break;</P>
<P>&#9;case WM_DESTROY:</P>
<P>&#9;&#9;PostQuitMessage(0);</P>
<P>&#9;&#9;break;</P>
<P>&#9;default:</P>
<P>&#9;&#9;break;</P>
<P>&#9;}</P>
<P>&#9;return DefWindowProc(hWnd,msg,wParam,lParam);</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在该窗口过程中，我们处理了最基本两条消息。</P>
<P ALIGN="JUSTIFY">第一条消息是</FONT><FONT SIZE=3>WM_PAINT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，当窗口客户区的全部或一部分需要重绘时，系统向该窗口发送该消息。在前面的过程中我们已经提到过，在使用</FONT><FONT SIZE=3>ShowWindow</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数显示窗口之后，通常随即调用函数</FONT><FONT SIZE=3>UpdateWindow</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，该函数直接向窗口过程发送一个</FONT><FONT SIZE=3>WM_PAINT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息，以通知窗口绘制其客户区。在该消息的处理函数中，我们先使用</FONT><FONT SIZE=3>GetDC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>获得窗口的设备句柄，关于设备句柄本书后面将要专门涉及，这里我们只需知道它是用来调用各种绘图方法的。然后调用</FONT><FONT SIZE=3>GetClientRect</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>获得当前窗口的客户区矩形。接着调用</FONT><FONT SIZE=3>CreatePen</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>创建一个黑色画笔，调用</FONT><FONT SIZE=3>CreateHatchBrush</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>创建一个</FONT><FONT SIZE=3>45</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>度交叉线的填充画刷，并且</FONT><FONT SIZE=3>SelectObject</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数将它们选入设备描述表中，原有的画笔和画刷被保存到</FONT><FONT SIZE=3>hPenOld</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>hBrushOld</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，以便以后恢复。完成以上步骤之后，调用</FONT><FONT SIZE=3>Ellipse</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数以当前客户区大小绘制一个椭圆。最后，再一次调用</FONT><FONT SIZE=3>SelectObject</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数恢复原有的画笔和画刷，并调用</FONT><FONT SIZE=3>ReleaseDC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>释放设备描述表句柄。在这个消息的处理代码中，我们涉及到了一些新的概念、数据类型和</FONT><FONT SIZE=3>API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数，然而本章并不着意于讲述这些内容，读者也不必深究它们，这些代码只是为了完整该示例程序才使用的。对于窗口来说，除了客户区以外的其它内容将由系统进行重绘，这些内容包括窗口标题条、边框、菜单条、工具条以及其它控件，如果包含了它们的话。这种重绘往往发生在覆盖于窗口上方的其它窗口被移走，或者是窗口被移动或改变大小时。因此，对于大多数窗口过程来说，</FONT><FONT SIZE=3>WM_PAINT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息是必须处理的。</P>
<P ALIGN="JUSTIFY">另一个对于绝大多数窗口过程都必须处理的消息是</FONT><FONT SIZE=3>WM_DESTROY</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，当窗口被撤消时</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>比如用户从窗口的系统菜单中选择了“关闭”，或者单击了右边的小叉，对于这些事件，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的默认处理是调用</FONT><FONT SIZE=3>DestroyWindow</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数撤销相应的窗口</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，将会接收到该消息。由于本程序仅在一个窗口，因此在这种情况下应该终止应用程序的执行，因此我们调用了</FONT><FONT SIZE=3>PostQuitMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数，该函数向线程的消息队列中放入一个</FONT><FONT SIZE=3>WM_QUIT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息，传递给</FONT><FONT SIZE=3>PostQuitMessage</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数的参数将成为</FONT><FONT SIZE=3>WM_QUIT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>消息的</FONT><FONT SIZE=3>wParam</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>参数，在上面的例子中，该值为</FONT><FONT SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">对于其它情况，在上面的示例程序中我们没有必要进行处理，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>专门为此提供了一个默认的窗口过程，称为</FONT><FONT SIZE=3>DefWindowProc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，我们只需要以</FONT><FONT SIZE=3>WndProc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的参数原封不动的调用默认窗口过程</FONT><FONT SIZE=3>DefWindowProc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，并将其返回值作为</FONT><FONT SIZE=3>WndProc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的返回值即可。</P>
<P ALIGN="JUSTIFY">将上面讲述的所有内容综合起来，我们就已经使用</FONT><FONT SIZE=3>Win32 SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>完成了一个功能简单，但是结构完整的</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序了。对于使用</FONT><FONT SIZE=3>Win32 SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编写的实用的</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序，它们的结构与此相比要复杂得多，在这些情况下，应用程序也许不仅仅包括一个窗口，而对应的窗口过程中的</FONT><FONT SIZE=3>switch</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>结构一般也会是一个异常膨胀的嵌套式</FONT><FONT SIZE=3>switch</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>结构。如此庞大的消息处理过程大大增加了程序调试和维护的难度，使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>则有可能在很多程度上减轻这种负担，这便是</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为广大程序员所乐于接受，以至今天成为实际上的工业标准的原因。但是，不管它如何复杂，归根到底，一般情况下，它仍然具有和我们的这个功能简单的</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序一样或类似的结构。为了读者阅读和分析方便，我们把这个程序的完整代码给出如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;windows.h&gt;</P>

<P>// 函数原型</P>
<P>int WINAPI WinMain(HINSTANCE,HINSTANCE,LPSTR,int);</P>
<P>LRESULT WINAPI WndProc(HWND,UINT,WPARAM,LPARAM);</P>

<P>// WinMain 函数</P>
<P>int WINAPI WinMain (HINSTANCE hInstance,</P>
<P>&#9;&#9;&#9;&#9;&#9;HINSTANCE hPrevInstance,</P>
<P>&#9;&#9;&#9;&#9;&#9;LPSTR lpCmdLine,</P>
<P>&#9;&#9;&#9;&#9;&#9;int nCmdShow)</P>
<P>{</P>
<P>&#9;HWND hWnd;&#9;&#9;// 主窗口句柄</P>
<P>&#9;MSG msg;&#9;&#9;// 窗口消息</P>
<P>&#9;WNDCLASS wc;&#9;// 窗口类</P>

<P>&#9;if (!hPrevInstance)</P>
<P>&#9;{</P>
<P>&#9;&#9;// 填充窗口类信息</P>
<P>&#9;&#9;wc.style=CS_HREDRAW|CS_VREDRAW;</P>
<P>&#9;&#9;wc.lpfnWndProc=WndProc;</P>
<P>&#9;&#9;wc.cbClsExtra=0;</P>
<P>&#9;&#9;wc.cbWndExtra=0;</P>
<P>&#9;&#9;wc.hInstance=hInstance;</P>
<P>&#9;&#9;wc.hIcon=LoadIcon(NULL,IDI_APPLICATION);</P>
<P>&#9;&#9;wc.hCursor=LoadCursor(NULL,IDC_ARROW);</P>
<P>&#9;&#9;wc.hbrBackground=GetStockObject(WHITE_BRUSH);</P>
<P>&#9;&#9;wc.lpszMenuName=NULL;</P>
<P>&#9;&#9;wc.lpszClassName="SdkDemo1";</P>
<P>&#9;&#9;// 注册窗口类</P>
<P>&#9;&#9;RegisterClass(&amp;wc);</P>
<P>&#9;}</P>

<P>&#9;// 创建应用程序主窗口</P>
<P>&#9;hWnd=CreateWindow ("SdkDemo1",&#9;&#9;&#9;&#9;&#9;// 窗口类名</P>
<P>&#9;&#9;&#9;&#9;&#9;   "第一个Win32 SDK应用程序",&#9;// 窗口标题</P>
<P>&#9;&#9;&#9;&#9;&#9;   WS_OVERLAPPEDWINDOW,&#9;&#9;// 窗口样式</P>
<P>&#9;&#9;&#9;&#9;&#9;   CW_USEDEFAULT,&#9;&#9;&#9;&#9;// 初始化 x 坐标</P>
<P>&#9;&#9;&#9;&#9;&#9;   CW_USEDEFAULT,&#9;&#9;&#9;&#9;// 初始化 y 坐标</P>
<P>&#9;&#9;&#9;&#9;&#9;   CW_USEDEFAULT,&#9;&#9;&#9;&#9;// 初始化窗口宽度</P>
<P>&#9;&#9;&#9;&#9;&#9;   CW_USEDEFAULT,&#9;&#9;&#9;&#9;// 初始化窗口高度</P>
<P>&#9;&#9;&#9;&#9;&#9;   NULL,&#9;&#9;&#9;&#9;&#9;&#9;// 父窗口句柄</P>
<P>&#9;&#9;&#9;&#9;&#9;   NULL,&#9;&#9;&#9;&#9;&#9;&#9;// 窗口菜单句柄</P>
<P>&#9;&#9;&#9;&#9;&#9;   hInstance,&#9;&#9;&#9;&#9;&#9;// 程序实例句柄</P>
<P>&#9;&#9;&#9;&#9;&#9;   NULL);&#9;&#9;&#9;&#9;&#9;&#9;// 创建参数</P>

<P>&#9;// 显示窗口</P>
<P>&#9;ShowWindow(hWnd,SW_SHOW);</P>
<P>&#9;// 更新主窗口客户区</P>
<P>&#9;UpdateWindow(hWnd);</P>

<P>&#9;// 开始消息循环</P>
<P>&#9;while (GetMessage(&amp;msg,NULL,0,0))</P>
<P>&#9;{</P>
<P>&#9;&#9;TranslateMessage(&amp;msg);</P>
<P>&#9;&#9;DispatchMessage(&amp;msg);</P>
<P>&#9;}</P>
<P>&#9;return msg.wParam;</P>
<P>}</P>

<P>// WndProc 主窗口过程</P>
<P>LRESULT WINAPI WndProc (HWND hWnd,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;UINT msg,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;WPARAM wParam,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;LPARAM lParam)</P>
<P>{</P>
<P>&#9;HDC hdc;</P>
<P>&#9;RECT rc;</P>
<P>&#9;HPEN hPen,hPenOld;</P>
<P>&#9;HBRUSH hBrush,hBrushOld;</P>
<P>&#9;switch (msg)</P>
<P>&#9;{</P>
<P>&#9;case WM_PAINT:</P>
<P>&#9;&#9;hdc=GetDC(hWnd);</P>
<P>&#9;&#9;GetClientRect(hWnd,&amp;rc);</P>
<P>&#9;&#9;hPen=CreatePen(PS_SOLID,0,RGB(0,0,0));</P>
<P>&#9;&#9;hBrush=CreateHatchBrush(HS_DIAGCROSS,RGB(0,0,0));</P>
<P>&#9;&#9;hPenOld=SelectObject(hdc,hPen);</P>
<P>&#9;&#9;hBrushOld=SelectObject(hdc,hBrush);</P>
<P>&#9;&#9;Ellipse(hdc,rc.left,rc.top,rc.right,rc.bottom);</P>
<P>&#9;&#9;SelectObject(hdc,hPenOld);</P>
<P>&#9;&#9;SelectObject(hdc,hBrushOld);</P>
<P>&#9;&#9;ReleaseDC(hWnd,hdc);</P>
<P>&#9;&#9;break;</P>
<P>&#9;case WM_DESTROY:</P>
<P>&#9;&#9;PostQuitMessage(0);</P>
<P>&#9;&#9;break;</P>
<P>&#9;default:</P>
<P>&#9;&#9;break;</P>
<P>&#9;}</P>
<P>&#9;return DefWindowProc(hWnd,msg,wParam,lParam);</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">该示例代码中的所有内容都已在前面做了完整的讲解，这里我们简单的说一下如何在</FONT><FONT SIZE=3>Microsoft Developer Studio</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中编译该示例程序。请按下面的步骤进行：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">1.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>选择</FONT><FONT SIZE=3>File</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单下的</FONT><FONT SIZE=3>New</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>命令，新建一个</FONT><FONT SIZE=3>Win32 Application</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>工程，这里我们假设对该工程命名为</FONT><FONT SIZE=3>SdkDemo1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，而事实上这完全取决于你的意愿。这个过程已经在本书的第一章中作为介绍，这里就不再重复说明了。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">2.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>选择</FONT><FONT SIZE=3>Project</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单下的</FONT><FONT SIZE=3>Add To Project|New...</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>命令，向工程中添加一个</FONT><FONT SIZE=3>C++ Source File (C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>源文件</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，可以将该文件命名为</FONT><FONT SIZE=3>winmain.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，不需要键入扩展名，</FONT><FONT SIZE=3>Microsoft Developer Studio</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在创建文件时会自动加上</FONT><FONT SIZE=3>.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的后缀名。这个过程也已经在第一章中作过介绍。阅读过该章内容的读者不应感到陌生。然后在</FONT><FONT SIZE=3>Wordspace</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>窗口的</FONT><FONT SIZE=3>FileView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中双击文件名</FONT><FONT SIZE=3>winmain.cpp (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在依赖于你在前面过程中的设定</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，输入下面的源代码即可。</P>
<P ALIGN="JUSTIFY">如果已将源代码输入为</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>源文件</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>以</FONT><FONT SIZE=3>.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为后缀名的文件</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，则可以使用</FONT><FONT SIZE=3>Project|Add To Project|Files...</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>将其添加到工程中。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image244.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image244.gif" WIDTH=390 HEIGHT=267></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>3.2 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>示例程序</FONT><FONT SIZE=1>SdkDemo1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>的运行结果</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">3.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>单击</FONT><FONT SIZE=3>Build</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单下的</FONT><FONT SIZE=3>Build SdkDemo1.exe</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>Build All</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或按下快捷键</FONT><FONT SIZE=3>F7 (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果未对该快捷键做过自定义操作的话</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或单击</FONT><FONT SIZE=3>Build</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>Build Minibar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>工具条上的<IMG SRC="Image245.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image245.gif" WIDTH=23 HEIGHT=22>按钮，编译并创建可执行文件</FONT><FONT SIZE=3>SdkDemo1.exe</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，运行该可执行文件</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从</FONT><FONT SIZE=3>Developer Studio</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中或资源管理器均可</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，将得到如图</FONT><FONT SIZE=3>3.2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示的结果。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">前面已经不只一次说到过，使用这种方式编写的应用程序使用调试和维护的难度很大。这个问题是使用直接使用</FONT><FONT SIZE=3>SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编程的固有总是。但是，我们还是有办法可以使得该程序的结构更紧凑和更集中一些，从而改善代码的可读性，也使得它更接近于使用</FONT><FONT SIZE=3>SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编写的真正的</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序。</P>
<P ALIGN="JUSTIFY">通过分析应用程序，我们发现，在上面的程序代码中，</FONT><FONT SIZE=3>WinMain</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数的代码显得有些过分臃肿，解决总是的办法就是将这些代码分离为单个的函数，这样，我们就可以得到更实用的基本</FONT><FONT SIZE=3>SDK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序框架，当然，相对于</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所提供的应用程序框架来说，我们的这个应用程序框架几乎不值一提，但是，它的确是要比前面的示例程序好多了。</P>
<P ALIGN="JUSTIFY">经过修改的代码如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;windows.h&gt;</P>

<P>// 函数原型</P>
<P>int WINAPI WinMain(HINSTANCE,HINSTANCE,LPSTR,int);</P>
<P>LRESULT WINAPI WndProc(HWND,UINT,WPARAM,LPARAM);</P>
<P>BOOL InitApplication(HINSTANCE);</P>
<P>BOOL InitInstance(HINSTANCE,int);</P>

<P>// WinMain 函数</P>
<P>int WINAPI WinMain (HINSTANCE hInstance,</P>
<P>&#9;&#9;&#9;&#9;&#9;HINSTANCE hPrevInstance,</P>
<P>&#9;&#9;&#9;&#9;&#9;LPSTR lpCmdLine,</P>
<P>&#9;&#9;&#9;&#9;&#9;int nCmdShow)</P>
<P>{</P>
<P>&#9;if (!hPrevInstance)</P>
<P>&#9;&#9;if (!InitApplication(hInstance))</P>
<P>&#9;&#9;&#9;return FALSE;</P>

<P>&#9;if (!InitInstance(hInstance,SW_SHOW))</P>
<P>&#9;&#9;return FALSE;</P>

<P>&#9;MSG msg;&#9;&#9;// 窗口消息</P>
<P>&#9;</P>
<P>&#9;// 开始消息循环</P>
<P>&#9;while (GetMessage(&amp;msg,NULL,0,0))</P>
<P>&#9;{</P>
<P>&#9;&#9;TranslateMessage(&amp;msg);</P>
<P>&#9;&#9;DispatchMessage(&amp;msg);</P>
<P>&#9;}</P>
<P>&#9;</P>
<P>&#9;return msg.wParam;</P>
<P>}</P>

<P>// WndProc 主窗口过程</P>
<P>LRESULT WINAPI WndProc (HWND hWnd,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;UINT msg,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;WPARAM wParam,</P>
<P>&#9;&#9;&#9;&#9;&#9;&#9;LPARAM lParam)</P>
<P>{</P>
<P>&#9;HDC hdc;</P>
<P>&#9;RECT rc;</P>
<P>&#9;HPEN hPen,hPenOld;</P>
<P>&#9;HBRUSH hBrush,hBrushOld;</P>
<P>&#9;switch (msg)</P>
<P>&#9;{</P>
<P>&#9;case WM_PAINT:</P>
<P>&#9;&#9;hdc=GetDC(hWnd);</P>
<P>&#9;&#9;GetClientRect(hWnd,&amp;rc);</P>
<P>&#9;&#9;hPen=CreatePen(PS_SOLID,0,RGB(0,0,0));</P>
<P>&#9;&#9;hBrush=CreateHatchBrush(HS_DIAGCROSS,RGB(0,0,0));</P>
<P>&#9;&#9;hPenOld=SelectObject(hdc,hPen);</P>
<P>&#9;&#9;hBrushOld=SelectObject(hdc,hBrush);</P>
<P>&#9;&#9;Ellipse(hdc,rc.left,rc.top,rc.right,rc.bottom);</P>
<P>&#9;&#9;SelectObject(hdc,hPenOld);</P>
<P>&#9;&#9;SelectObject(hdc,hBrushOld);</P>
<P>&#9;&#9;ReleaseDC(hWnd,hdc);</P>
<P>&#9;&#9;break;</P>
<P>&#9;case WM_DESTROY:</P>
<P>&#9;&#9;PostQuitMessage(0);</P>
<P>&#9;&#9;break;</P>
<P>&#9;default:</P>
<P>&#9;&#9;break;</P>
<P>&#9;}</P>
<P>&#9;return DefWindowProc(hWnd,msg,wParam,lParam);</P>
<P>}</P>

<P>BOOL InitApplication(HINSTANCE hInstance)</P>
<P>{</P>
<P>&#9;WNDCLASS wc;&#9;// 窗口类</P>

<P>&#9;// 填充窗口类信息</P>
<P>&#9;wc.style=CS_HREDRAW|CS_VREDRAW;</P>
<P>&#9;wc.lpfnWndProc=WndProc;</P>
<P>&#9;wc.cbClsExtra=0;</P>
<P>&#9;wc.cbWndExtra=0;</P>
<P>&#9;wc.hInstance=hInstance;</P>
<P>&#9;wc.hIcon=LoadIcon(NULL,IDI_APPLICATION);</P>
<P>&#9;wc.hCursor=LoadCursor(NULL,IDC_ARROW);</P>
<P>&#9;wc.hbrBackground=GetStockObject(WHITE_BRUSH);</P>
<P>&#9;wc.lpszMenuName=NULL;</P>
<P>&#9;wc.lpszClassName="SdkDemo2";</P>

<P>&#9;// 注册窗口类</P>
<P>&#9;return RegisterClass(&amp;wc);</P>
<P>}</P>

<P>BOOL InitInstance(HINSTANCE hInstance,int nCmdShow)</P>
<P>{</P>
<P>&#9;HWND hWnd;&#9;&#9;// 主窗口句柄</P>
<P>&#9;</P>
<P>&#9;// 创建应用程序主窗口</P>
<P>&#9;hWnd=CreateWindow ("SdkDemo2",&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 窗口类名</P>
<P>&#9;&#9;&#9;&#9;&#9;   "经过修改的第一个Win32 SDK应用程序",&#9;// 窗口标题</P>
<P>&#9;&#9;&#9;&#9;&#9;   WS_OVERLAPPEDWINDOW,&#9;&#9;&#9;&#9;// 窗口样式</P>
<P>&#9;&#9;&#9;&#9;&#9;   CW_USEDEFAULT,&#9;&#9;&#9;&#9;&#9;&#9;// 初始化 x 坐标</P>
<P>&#9;&#9;&#9;&#9;&#9;   CW_USEDEFAULT,&#9;&#9;&#9;&#9;&#9;&#9;// 初始化 y 坐标</P>
<P>&#9;&#9;&#9;&#9;&#9;   CW_USEDEFAULT,&#9;&#9;&#9;&#9;&#9;&#9;// 初始化窗口宽度</P>
<P>&#9;&#9;&#9;&#9;&#9;   CW_USEDEFAULT,&#9;&#9;&#9;&#9;&#9;&#9;// 初始化窗口高度</P>
<P>&#9;&#9;&#9;&#9;&#9;   NULL,&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 父窗口句柄</P>
<P>&#9;&#9;&#9;&#9;&#9;   NULL,&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 窗口菜单句柄</P>
<P>&#9;&#9;&#9;&#9;&#9;   hInstance,&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 程序实例句柄</P>
<P>&#9;&#9;&#9;&#9;&#9;   NULL);&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 创建参数</P>

<P>&#9;if (!hWnd)</P>
<P>&#9;&#9;return FALSE;</P>

<P>&#9;// 显示窗口</P>
<P>&#9;ShowWindow(hWnd,SW_SHOW);</P>
<P>&#9;// 更新主窗口客户区</P>
<P>&#9;UpdateWindow(hWnd);</P>
<P>&#9;return TRUE;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">由于上面的代码只是将前面的代码的结构作了一下调整，并没有引入新的</FONT><FONT SIZE=3>API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数和其它编程内容，因此为了节省篇幅，我们这里对该代码不再进行讲解，至于其与</FONT><FONT SIZE=3>SdkDemo1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的代码相比的优越性，由读者自己将两段代码对比后得出。</P>
</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER"><A NAME="_Toc425696656">第四节</FONT><FONT SIZE=4> 32</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>位编程的特点</A></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">本节假定用户是刚接触</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编程的新手，那么，有必要将一些相关的概念术语弄清楚，同时，也要把</FONT><FONT SIZE=3>Windows 95</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Windows NT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位的</FONT><FONT SIZE=3>Windows 3.x</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>相区别开来。这些最重要的概念包括进程和线程的管理以及新的</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位平坦内存模式。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在介绍</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位内存管理之前，我们有必要介绍一下进程和线程这两个术语。</P>
<P ALIGN="JUSTIFY">进程是装入内存中正在执行的应用程序，进程包括私有的虚拟地址空间、代码、数据及其它操作系统资源，如文件、管道以及对该进程可见的同步对象等。进程包括了一个或多个在进程上下文内运行的线程。</P>
<P ALIGN="JUSTIFY">线程是操作系统分配</FONT><FONT SIZE=3>CPU</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>时间的基本实体。线程可以执行应用程序代码的任何部分，包括当前正在被其它线程执行的那些。同一进程的所有线程共享同样的虚拟地址空间、全局变量和操作系统资源。</P>
<P ALIGN="JUSTIFY">在一个应用程序中，可以包括一个或多个进程，每个进程由一个或多个线程构成。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">线程通过“休眠”</FONT><FONT SIZE=3>(sleeping</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，暂停所有执行并等待</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的方法，来做到与进程中的其它线程所同步。在线程休眠前，必须告诉</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，该线程将等待某一事件的发生。当该事件发生时，</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>发给线程一个唤醒调用，线程继续执行。也就是说，线程与事件一起被同步，除此之外，也可以由特殊的同步对象来进行线程的同步。这些同步对象包括：</P>

<UL>
<P ALIGN="JUSTIFY"><LI>互斥</FONT><FONT SIZE=3>  </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不受控制的或随意的线程访问在多线程应用程序中可能会引起很大的问题。这里所说的互斥是一小须代码，它时刻采取对共享数据的独占控制以执行代码。互斥常被应用于多进程的同步数据存取。</LI></P>
<P ALIGN="JUSTIFY"><LI>信号量</FONT><FONT SIZE=3>  </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>信号量与互斥相似，但是互斥只允许在同一时刻一个线程访问它的数据，而信号量允许多个线程在同一时刻访问它的数据。</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不知道哪一个线程拥有信号量，它只保证信号量使用的资源量。</LI></P>
<P ALIGN="JUSTIFY"><LI>临界区</FONT><FONT SIZE=3>  </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>临界区对象也和互斥相似，但它仅被属于单个进程的线程使用。临界区对象提供非常有效的同步模式，同互斥一样，每次在同一时间内只有一个线程可以访问临界区对象。</LI></P>
<P ALIGN="JUSTIFY"><LI>事件&#9;</FONT><FONT SIZE=3>  </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>事件对象用于许多实例中去通知休眠的线程所等待的事件已经发生，事件告诉线程何时去执行某一个给定的任务，并可以使多线程流平滑。</LI></P></UL>

<P ALIGN="JUSTIFY">将所有的这些同步对象应用于控制数据访问使得线程同步成为可能，否则，如果一个线程改变了另一个线程正在读的数据，将有可能导致很大的麻烦。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>环境下，每个运行的在进程内的线程还可以为它自己的特定线程数据分配内存，通过</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>提供的线程本地存储</FONT><FONT SIZE=3>(TLS)API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，应用程序可以建立动态的特定线程数据，在运行时这些数据联系在一起。</P>
<P ALIGN="JUSTIFY">本书将在专门的章节中讨论线程和进程的问题。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面我们来看在</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位应用程序地址空间中的内存分配和内存管理。</P>
<P ALIGN="JUSTIFY">常见的内存分配可以划分为两类：帧分配</FONT><FONT SIZE=3>(frame allocation)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和堆分配</FONT><FONT SIZE=3>(heap allocation)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。两者的主要区别在于帧分配通常和实际的内存块打交道，而堆分配在一般情况下则使用指向内存块的指针，并且，帧对象在超过其作用域时会被自动的删除，而程序员必须显式的删除在堆上分配的对象。</P>
<P ALIGN="JUSTIFY">在帧上分配内存的这种说法来源于“堆栈帧”</FONT><FONT SIZE=3>(stack frame)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这个名词，堆栈帧在每当函数被调用时创建，它是一块用来暂时保存函数参数以及在函数中定义的局部变量的内存区域。帧变量通常被称作自动变量，这是因为编译器自动为它们分配所需的内存。</P>
<P ALIGN="JUSTIFY">帧分配有两个主要特征，首先，当我们定义一个局部变量是，编译器将在堆栈帧上分配足够的空间来保存整个变量，对于很大的数组和其它数据结构也是这样；其次，当超过其作用域时，帧变量将被自动的删除。下面举一个帧分配的例子：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>int Func(int Argu1,int Argu2)&#9;// 编译器将在堆栈帧上为函数参数变量分配空间</P>
<P>{</P>
<P>&#9;// 在堆栈上创建局部对象</P>
<P>&#9;char szDatum[256][256];</P>
<P>&#9;...</P>
<P>&#9;// 超过作用域时将自动删除在堆栈上分配的对象</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">对于局部函数变量，其作用域转变在函数退出时发生，但如果使用了嵌套的花括号，则帧变量的作用域将有可能比函数作用域小。自动删除这些帧变量非常之重要。对于简单的基本数据类型</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如整型或字节变量</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、数组或数据结构，自动删除只是简单的回收被这些这是所占用的内存。由于这些变量已超出其作用域，它们将再也不可以被访问。对于</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象，自动删除的过程要稍稍复杂一些。当一个对象被定义为一个帧变量时，其构造函数在定义对象变量时被自动的调用，当对象超出其作用域时，在对象所占用的内存被释放前，其析构函数先被自动的调用。这种对构造函数和析构函数的调用看起来非常的简便，但我们必须对它们倍加小心，尤其是对析构函数，不正确的构造和释放对象将可能对内存管理带来严重的问题。在本书的第二章中我们曾经历过其中的一种</FONT><FONT SIZE=3>――</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针挂起。</P>
<P ALIGN="JUSTIFY">在帧上分配对象的最大的优越性在于这些对象将会被自动的删除，也就是说，当你在帧上分配对象之后，不必担心它们会导致内存漏损</FONT><FONT SIZE=3>(memory leak)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。但是，帧分配也有其不方便之处，首先，在帧上分配的变量不可以超出其作用域，其中，帧空间往往是有限的，因此，在很多情况下，我们更倾向于使用下面接着要讲述的堆分配来代替这里所讲述的帧分配来为那些庞大的数据结构或对象分配内存。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">堆是为程序所保留的用于内存分配的区域，它与程序代码和堆栈相隔离。在通常情况下，</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>程序使用函数</FONT><FONT SIZE=3>malloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>free</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来分配和释放堆内存。调试版本</FONT><FONT SIZE=3>(Debug version)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>提供了改良版本的</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>内建运算符</FONT><FONT SIZE=3>new</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>delete</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用于在堆内存中分配和释放对象。</P>
<P ALIGN="JUSTIFY">使用</FONT><FONT SIZE=3>new</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>delete</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>代替</FONT><FONT SIZE=3>malloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>free</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以从类库提供的增强的内存管理调试支持中得到好处，这在检测内存漏损时非常之有用。而当你使用</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的发行版本</FONT><FONT SIZE=3>(Release version)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来创建应用程序时，</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的发行版本并没有使用这种改良版本的</FONT><FONT SIZE=3>new</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>delete</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>操作符，取而代之的是一种更为有效的分配和释放内存的方法。</P>
<P ALIGN="JUSTIFY">与帧分配不同，在堆上可分配的对象所占用的内存的总量只受限于系统可有的所有虚拟内存空间。</P>
<P ALIGN="JUSTIFY">以下的示例代码对比了上面讨论的内存分配方法在为数组、数据结构和对象分配内存时的用法：</P>
<P ALIGN="JUSTIFY">使用帧分配为数组分配内存：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>{ </P>
<P>    const int BUFF_SIZE = 128; </P>

<P>    // 在帧上分配数组空间</P>
<P>    char myCharArray[BUFF_SIZE];</P>
<P>    int myIntArray[BUFF_SIZE];</P>
<P>    // 所分配的空间在超出作用域时自动回收</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">使用堆分配为数组分配内存：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>const int BUFF_SIZE = 128;</P>

<P>// 在堆上分配数组空间</P>
<P>char* myCharArray = new char[BUFF_SIZE]; </P>
<P>int* myIntArray = new int[BUFF_SIZE];</P>
<P>...</P>
<P>delete [] myCharArray;</P>
<P>delete [] myIntArray;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">使用帧分配为结构分配内存：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>struct MyStructType { int topScore;};</P>
<P>void SomeFunc(void)</P>
<P>{</P>
<P>    // 帧分配</P>
<P>    MyStructType myStruct;</P>

<P>    // 使用该结构</P>
<P>    myStruct.topScore = 297;</P>

<P>    // 在超出作用域时结构所占用的内存被自动回收</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">使用堆分配为结构分配内存：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>// 堆分配</P>
<P>MyStructType* myStruct = new MyStructType;</P>

<P>// 通过指针使用该结构</P>
<P>myStruct-&gt;topScore = 297;</P>

<P>delete myStruct;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">使用帧分配为对象分配内存：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>{</P>
<P>    CMyClass myClass;                 // 构造函数被自动调用</P>

<P>    myClass.SomeMemberFunction();     // 使用该对象</P>

<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">使用堆分配为对象分配内存：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>// 自动调用构造函数</P>
<P>CMyClass *myClass=new CMyClass;  </P>

<P>myClass-&gt;SomeMemberFunction();     // 使用该对象</P>

<P>delete myClass;                    // 在使用delete的过程中调用析构函数</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>一定要记住一个事实，在堆上分配的内存一定要记得释放，对于使用运算符</FONT><FONT SIZE=3>new</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>分配的内存，应当使用</FONT><FONT SIZE=3>delete</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>运算符来释放；而使用</FONT><FONT SIZE=3>malloc</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>函数分配的内存应当使用</FONT><FONT SIZE=3>free</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>函数来释放。不应当对同一内存块交叉使用运算符</FONT><FONT SIZE=3>new</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>delete</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和函数</FONT><FONT SIZE=3>malloc</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>free (</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>即使用</FONT><FONT SIZE=3>delete</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>运算符释放由</FONT><FONT SIZE=3>malloc</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>函数分配的内存，或使用</FONT><FONT SIZE=3>free</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>函数释放由</FONT><FONT SIZE=3>new</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>运算符根本的内存</FONT><FONT SIZE=3>)</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，否则在</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的调试版本下将会导致内存冲突。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">对固定大小的内存块，使用运算符</FONT><FONT SIZE=3>new</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>delete</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>要比使用标准</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>库函数</FONT><FONT SIZE=3>malloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>free</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>方便。但有时候我们需要使用可变大小的内存块，这时，我们必须使用标准的</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>库函数</FONT><FONT SIZE=3>malloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>realloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>free</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。下面的示例代码创建了一个可变大小的数组：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;malloc.h&gt;</P>
<P>#include &lt;stdio.h&gt;</P>

<P>#define UPPER_BOUND 128</P>

<P>void main()</P>
<P>{</P>
<P>&#9;int *iArray=(int *)malloc(sizeof(int));</P>
<P>&#9;for (int i=0;i&lt;UPPER_BOUND;i++)</P>
<P>&#9;{</P>
<P>&#9;&#9;iArray=(int *)realloc(iArray,(i+1)*sizeof(int));</P>
<P>&#9;&#9;printf("  %08x",(int)iArray);</P>
<P>&#9;&#9;iArray[i]=i+1;</P>
<P>&#9;}</P>
<P>&#9;for (i=0;i&lt;UPPER_BOUND;i++)</P>
<P>&#9;{</P>
<P>&#9;&#9;printf("%5d",iArray[i]);</P>
<P>&#9;}</P>
<P>&#9;free(iArray);</P>
<P>&#9;return;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">观察下面的运行结果：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>  00410770  00410780  00410790  004107a0  004107a0  004107c0  004107e0  00410800</P>
<P>  00410800  00410830  00410860  00410890  00410890  004108d0  00410910  00410950</P>
<P>  00410950  004109a0  004109f0  00410a40  00410a40  00410aa0  00410b00  00410b60</P>
<P>  00410b60  00410bd0  00410c40  00410cb0  00410cb0  00410d30  00410db0  00410e30</P>
<P>  00410e30  00410ec0  00410f50  00410760  00410760  00410800  004108a0  00410940</P>
<P>  00410940  004109f0  00410aa0  00410b50  00410b50  00410c10  00410cd0  00410d90</P>
<P>  00410d90  00410e60  00410f30  00410760  00410760  00410840  00410920  00410a00</P>
<P>  00410a00  00410af0  00410be0  00410cd0  00410cd0  00410dd0  00410ed0  00410760</P>
<P>  00410760  00410870  00410980  00410a90  00410a90  00410bb0  00410cd0  00410df0</P>
<P>  00410df0  00410760  00410890  004109c0  004109c0  00410b00  00410c40  00410d80</P>
<P>  00410d80  00410760  004108b0  00410a00  00410a00  00410b60  00410cc0  00410e20</P>
<P>  00410e20  00410760  004108d0  00410a40  00410a40  00410bc0  00410d40  00410760</P>
<P>  00410760  004108f0  00410a80  00410c10  00410c10  00410db0  00410760  00410900</P>
<P>  00410900  00410ab0  00410c60  00410e10  00410e10  00410760  00410920  00410ae0</P>
<P>  00410ae0  00410cb0  00410760  00410930  00351d98  00351d98  00351d98  00351d98</P>
<P>  00351d98  00351d98  00351d98  00351d98  00351d98  00351d98  00351d98  00351d98</P>
<P>    1    2    3    4    5    6    7    8    9   10   11   12   13   14   15   16</P>
<P>   17   18   19   20   21   22   23   24   25   26   27   28   29   30   31   32</P>
<P>   33   34   35   36   37   38   39   40   41   42   43   44   45   46   47   48</P>
<P>   49   50   51   52   53   54   55   56   57   58   59   60   61   62   63   64</P>
<P>   65   66   67   68   69   70   71   72   73   74   75   76   77   78   79   80</P>
<P>   81   82   83   84   85   86   87   88   89   90   91   92   93   94   95   96</P>
<P>   97   98   99  100  101  102  103  104  105  106  107  108  109  110  111  112</P>
<P>  113  114  115  116  117  118  119  120  121  122  123  124  125  126  127  128</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的结果说明两个问题：一是在使用</FONT><FONT SIZE=3>realloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>改变所分配内存单元的大小时，</FONT><FONT SIZE=3>realloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可能会移动该内存块到新的位置。二是在</FONT><FONT SIZE=3>realloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>改变和移动内存块时，该内存块中的数据也同时会被保留。所以上面的模式可以满足一些特殊场合的需要。但是，请记住一点，随着内存块的增大，</FONT><FONT SIZE=3>realloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的运行效率会极大的下降，当上面的，因此，除非必要，我们不要使用这种方式，虽然它灵活方便，但这往往是以牺牲效率为代价的。</P>
<P ALIGN="JUSTIFY">最后重新强调一点，即不要使用</FONT><FONT SIZE=3>realloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>改变由</FONT><FONT SIZE=3>new</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>运算符分配的内存块的大小。前面已经说过，这将会在</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的调试版本中导致内存冲突。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面我们简单的介绍</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>内存管理模式。</P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>Microsoft Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序编程接口中，每一个进程都有自己多达</FONT><FONT SIZE=3>4GB</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的虚拟地址空间。内存中低位的</FONT><FONT SIZE=3>2GB (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从</FONT><FONT SIZE=3>0x00</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>到</FONT><FONT SIZE=3>0x7FFFFFFF)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以为用户所用，高位的</FONT><FONT SIZE=3>2GB (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从</FONT><FONT SIZE=3>0x80000000</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>到</FONT><FONT SIZE=3>0xFFFFFFFFF)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为内核所保留。进程所使用的虚拟地址并不代码对象在内存中实际的物理地址。事实上，内核为每一个进程维护了一个页映射，页映射是一个用于将虚拟地址转换为对应的物理地址的内部数据结构。</P>
<P ALIGN="JUSTIFY">每一个进程的虚拟地址空间都要比所有进程可用的物理内存</FONT><FONT SIZE=3>RAM (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>随机存取存储器</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的总合大得多。为了增加物理存储的大小，内核使用磁盘作为额外的存储空间。对于所有正在执行的进程来说，总的存储空间的量是物理内存</FONT><FONT SIZE=3>RAM</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和磁盘上可以为页面文件所用的自由空间的总合，这里页面文件指用来增加物理存储空间的磁盘文件。每个进程物理存储空间和虚拟地址</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>也称为逻辑地址</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>空间以页的形式来组织，页是一种内存单元，其大小依赖于宿主计算机的类型。对于</FONT><FONT SIZE=3>x86</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>计算机来说，宿主页大小为</FONT><FONT SIZE=3>4KB</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，但我们不能假定对有所有运行</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>操作系统的计算机，其页大小均为</FONT><FONT SIZE=3>4KB</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">为了使内存管理具有最大的灵活性，内核可以将物理内存中的页移入或移出磁盘上的页面文件。当一个页被移入物理内存时，内核更新受到影响的进程的页映射。将内核需要物理内存空间时，它将物理内存中最近最少使用的页移入页面文件。对于应用程序来说，内核对物理内存的管理是完全透明的，应用程序只对它自己的虚拟地址空间进行操作。</FONT><FONT SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在进程虚拟地址空间中的页可以具在表所列的状态之一：</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>3. 4 </FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>虚拟地址空间中页的不同状态</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=526>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">状态</FONT></TD>
<TD WIDTH="79%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">说明</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">空闲</FONT><FONT SIZE=1>(Free)</FONT></TD>
<TD WIDTH="79%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">空闲页是当前不可用，但可以被占用或保留的页。</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">保留</FONT><FONT SIZE=1>(Reserved)</FONT></TD>
<TD WIDTH="79%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">保留页是进程的虚拟地址空间中为将来使用所保留的页。进程不可以存取保留页，并且也没有为保留页分配物理存储。保留页保留虚拟地址中的一段以使得它们不可以被随后的其它分配操作</FONT><FONT SIZE=1>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>如</FONT><FONT SIZE=1>malloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>和</FONT><FONT SIZE=1>LocalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>之类的函数等</FONT><FONT SIZE=1>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>所使用。一个进程可以使用</FONT><FONT SIZE=1>VirtualAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>函数在其地址空间中保留页面，然后再占用这些保留页。最后使用</FONT><FONT SIZE=1>VirtualFree</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>函数释放它们。</FONT></TD>
</TR>
<TR><TD WIDTH="21%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">占用</FONT><FONT SIZE=1>(Committed)</FONT></TD>
<TD WIDTH="79%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">已被占用的页是那些已分配了物理存储</FONT><FONT SIZE=1>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>在内存中或磁盘上</FONT><FONT SIZE=1>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>的页。占用页可以被禁止进行存取，或允许只读存取，或允许读写存取。进程可以使用</FONT><FONT SIZE=1>VirtualAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>函数分配占用页。</FONT><FONT SIZE=1>GlobalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>和</FONT><FONT SIZE=1>LocalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>函数分配允许读写存取的占用页。占用页可以使用</FONT><FONT SIZE=1>VirtualFree</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>函数进行释放，函数</FONT><FONT SIZE=1>VirtualFree</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>释放页的存储空间，并将其状态改变为保留。</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">进程可以使用函数</FONT><FONT SIZE=3>GlobalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来分配内存。在</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位线性环境中，本地堆和全局堆并没有区别，因此，使用这两个函数来分配内存对象也没有任何区别。</P>
<P ALIGN="JUSTIFY">由</FONT><FONT SIZE=3>GlobalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数分配的内存对象位于私有的占用页中，这些页允许进行读写存取。私有内存不可以为其它进程所访问。与在</FONT><FONT SIZE=3>Windows 3.x</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中不同，使用带有</FONT><FONT SIZE=3>GMEM_DDESHARE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>标志的</FONT><FONT SIZE=3>GlobalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数分配的内存事实上并没有被全局共享。保留该标志位仅是为了向前兼容和为一些应用程序增强动态数据交换</FONT><FONT SIZE=3>(DDE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><FONT SIZE=3>dynamic data exchange)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的性能而使用。应用程序如果因其它目的需要共享内存，那么必须使用文件映射对象。多个进程可以通过映射同一个文件映射对象的视来提供命名共享内存。我们在这里将不讨论文件映射和共享内存的问题。</P>
<P ALIGN="JUSTIFY">通过使用函数</FONT><FONT SIZE=3>GlobalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，可以分配能够表示为</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位的任意大小的内存块，所受的唯一限制是可用的物理内存，包括在磁盘上的页面文件中的存储空间。这些函数，和其它操作全局和本局内存对象的全局和本地函数一起被包含在</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，以和</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位版本相兼容。但是，从</FONT><FONT SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位分段内存模式到</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位虚拟内存模式的转变将使得一些函数和一些选项变得不必要甚至没有意义。比如说，现在不再和近指针和远指针的区别，因为无论在本地还是在全局进行分配都将返回</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位虚拟地址。</FONT><FONT SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">函数</FONT><FONT SIZE=3>GlobalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>都可以分配固定或可移动的内存对象。可移动对象也可以被标记为可丢弃的</FONT><FONT SIZE=3>(discardable)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。在早期的</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>版本中，可移动的内存对象对于内存管理非常之重要，它们允许系统在必要时压缩堆以为其它内存分配提供可用空间。通过使用虚拟内存，系统能够通过移动物理内存页来管理内存，而不影响使用这些页的进程的虚拟地址。当系统移动一个物理内存页时，它简单的将进程的虚拟页映射到新的物理页的位置。可移动内存在分配可丢弃内存仍然有用。当系统需要额外的物理存储时，它使用一种称作“最近最少使用”的算法来释放非锁定的可丢弃内存。可丢弃内存可以用于那些不是经常需要和易于重新创建的数据。</P>
<P ALIGN="JUSTIFY">当分配固定内存对象时，</FONT><FONT SIZE=3>GlobalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回</FONT><FONT SIZE=3>32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位指针，调用线程可以立即使用该指针来进行内存存取。对于可移动内存，返回值为一个句柄。为了得到一个指向可移动内存的指针，调用线程可以使用</FONT><FONT SIZE=3>GlobalLock</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalLock</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数。这些函数锁定内存使得它不能够被移动或丢弃，除非使用函数</FONT><FONT SIZE=3>GlobalReAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>LocalReAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对内存对象进行重新分配。已锁定内存对象的内存块保持锁定状态，直至锁定计数减到</FONT><FONT SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这时该内存块可以被移动或丢弃。</P>
<P ALIGN="JUSTIFY">由</FONT><FONT SIZE=3>GlobalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所分配的内存的实际大小可能大于所要求的大小。为了得到已分配的实际内存数，可以使用函数</FONT><FONT SIZE=3>GlobalSize</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalSize</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。如果总分配量大于所要求的量，进程则可以使用所有的这些量。</FONT><FONT SIZE=3>]</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">函数</FONT><FONT SIZE=3>GlobalReAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalReAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>以字节为单位改变由</FONT><FONT SIZE=3>GlobalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数分配内存对象的大小或其属性。内存对象的大小可以增大，也可以减小。</P>
<P ALIGN="JUSTIFY">函数</FONT><FONT SIZE=3>GlobalFree</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalFree</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用于释放由</FONT><FONT SIZE=3>GlobalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>LocalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>GlobalReAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>LocalReAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>分配的内存。</P>
<P ALIGN="JUSTIFY">其它的全局和本地函数包括</FONT><FONT SIZE=3>GlobalDiscard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>LocalDiscard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>GlobalFlags</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>LocalFlags</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>GlobalHandle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalHandle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</FONT><FONT SIZE=3>GlobalDiscard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>LocalDiscard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用于丢弃指定的可丢弃内存对象，但不使其句柄无效。该句柄可能通过函数</FONT><FONT SIZE=3>GlobalReAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>LocalReAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>与新分配的内存块相关联。函数</FONT><FONT SIZE=3>GlobalFlags</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>LocalFlags</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回关于指定内存对象的信息。这些住处包括对象的锁定计数以及对象是否可丢弃或是否已被丢弃。函数</FONT><FONT SIZE=3>GlobalHandle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>或</FONT><FONT SIZE=3>LocalHandle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回与指定指针相关联的内存对象的句柄。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进程可以完全的使用标准的</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>库函数</FONT><FONT SIZE=3>malloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>free</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等来操作内存。在</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的早期版本中使用这些函数，将可能带来问题隐患，但是使用</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的应用程序中则不会。举例来说，使用</FONT><FONT SIZE=3>malloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>分配固定指针将不能使用可移动内存的优点。由于系统可以通过移动物理内存页来自由的管理内存，而不影响虚拟地址，因此内存管理将不再成为问题。类似的，远指针和近指针之间不再有差别。因此，除非你希望使用可丢弃内存，否则完全可以将标准的</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>库函数用于内存管理。</P>
<P ALIGN="JUSTIFY"></P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>提供了一系列的虚拟内存函数来操作或决定虚拟地址空间中的页的状态。许多应用程序使用标准的分配函数</FONT><FONT SIZE=3>GlobalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>LocalAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>malloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等就可以满足其需要。然而，虚拟内存函数提供了一些这些标准分配函数所不具有的功能，它们可以进行下面的这些操作：</P>

<UL>
<P ALIGN="JUSTIFY"><LI>保留进程虚拟地址空间中的一段</FONT><FONT SIZE=3>  </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>保留地址空间并不为它们分配物理存储，而只是防止其它分配操作使用这段空间。它并不影响其它进程的虚拟地址空间。保留页防止了对物理存储的不必要的浪费，然而它允许进程为可能增长的动态数据结构保留一段地址空间，进程可以在需要的时候为这些空间分配物理存储。</LI></P>
<P ALIGN="JUSTIFY"><LI>占用进程虚拟地址空间中的保留页的一部分，以使得物理存储</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>无论是</FONT><FONT SIZE=3>RAM</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>还是磁盘空间</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>只对正在进行分配的进程可用。</LI></P>
<P ALIGN="JUSTIFY"><LI>指定允许读写存取、只读存取或不允许存取的占用页区域。这和标准的分配函数总是分配允许读写存取的页不同。</LI></P>
<P ALIGN="JUSTIFY"><LI>释放一段保留页，使得调用线程在随后的分配操作中可以使用这段虚拟地址。</LI></P>
<P ALIGN="JUSTIFY"><LI>取消对一段页的占用，释放它们的物理存储，使它们可以其它进程在随后的分配中使用。</LI></P>
<P ALIGN="JUSTIFY"><LI>在物理内存</FONT><FONT SIZE=3>RAM</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中锁定一个或多个占用页，以免系统将这些页交换到页面文件中。</LI></P>
<P ALIGN="JUSTIFY"><LI>获得关于调用线程或指定线程的虚拟地址空间中的一段页的信息。</LI></P>
<P ALIGN="JUSTIFY"><LI>改变调用线程或指定线程的虚拟地址空间中指定占用页段的存取保护。</LI></P></UL>

<P ALIGN="JUSTIFY">虚拟内存函数对内存页进行操作。函数使用当前计算机的页大小来对指定的大小和地址进行舍入。</P>
<P ALIGN="JUSTIFY">可以使用函数</FONT><FONT SIZE=3>GetSystemInfo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来获得当前计算机的页大小。</P>
<P ALIGN="JUSTIFY">函数</FONT><FONT SIZE=3>VirtualAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>完成以下操作：</P>

<UL>
<P ALIGN="JUSTIFY"><LI>保留一个或多个自由页。</LI></P>
<P ALIGN="JUSTIFY"><LI>占用一个或多个保留页。</LI></P>
<P ALIGN="JUSTIFY"><LI>保留并占用一个或多个自由页。</LI></P></UL>

<P ALIGN="JUSTIFY">你可以指针所保留或占用的页的起始地址，或者让系统来决定。函数将指定的地址舍入到合适的页边界。保留页是不可访问的，但占用页可以使用标志位</FONT><FONT SIZE=3>PAGE_READWRITE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>PAGE_READONLY</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>PAGE_NOACCESS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来分配。当页被占用时，从页面文件中分配存储空间，每个页仅在第一次试图对其进行读写操作时被初始化并加载到物理内存中。可以用一般的指针引用来访问由</FONT><FONT SIZE=3>VirtualAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数占用的页。</P>
<P ALIGN="JUSTIFY">函数</FONT><FONT SIZE=3>VirtualFree</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>完成下面的操作：</P>

<UL>
<P ALIGN="JUSTIFY"><LI>解除对一个或多个页的占用，改变其状态为保留。解除对页的战胜释放与之相关的物理存储，使其为其它进程可用。任何占用页块都可以被解除占用。</LI></P>
<P ALIGN="JUSTIFY"><LI>释放一个或多个保留页块，改变其状态为自由。释放页块使这段保留空间可以为进程分配空间使用。保留页只能通过释放由函数</FONT><FONT SIZE=3>VirtualAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>最初保留的整个块来释放。</LI></P>
<P ALIGN="JUSTIFY"><LI>同时解除对一个或多个占用页的占用并释放它们，将其状态改变为自由。指定的块必须包括由</FONT><FONT SIZE=3>VirtualAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>最初保留的整个块，而且这些页的当前状态必须为占用。</LI></P></UL>

<P ALIGN="JUSTIFY">函数</FONT><FONT SIZE=3>VirtualLock</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>允许进程将一个或多个占用页锁定在物理内存</FONT><FONT SIZE=3>RAM</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，防止系统将它们交换到页面文件中。这保证了一些要求苛刻的数据可以不通过磁盘访问来存取。将一个页锁定入内存是很危险的，因为它限制了系统管理内存的能力。由于可能会将可执行代码交换到页面文件中，可执行程序使用</FONT><FONT SIZE=3>VirtualLock</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>将有可能降低系统性能。函数</FONT><FONT SIZE=3>VirtualUnlock</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>解除</FONT><FONT SIZE=3>VirtualLock</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对内存的锁定。</FONT><FONT SIZE=3> </P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">函数</FONT><FONT SIZE=3>VirtualQuery</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>VirtualQueryEx</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回关于以进程地址空间中某一指定地址开始的一段连续内存区域的信息。</FONT><FONT SIZE=3>VirtualQuery</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回关于调用线程内存的信息。</FONT><FONT SIZE=3>VirtualQueryEx</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>返回指定进程内存的信息，这通常用来支持调试程序，这些程序常常需要知道关于被调试进程的信息。页区域以相对于指定地址最接近的页边界为界。一般来说，它通过具有下述属性的后续页来进行扩展：</P>
<P ALIGN="JUSTIFY">所有页具有相同的状态，或为占用，或为保留，或为自由。</P>
<P ALIGN="JUSTIFY">如果初始页不为自由，区域中的所有页都属于通过调用</FONT><FONT SIZE=3>VirtualAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>保留的同一个最初页分配。</P>
<P ALIGN="JUSTIFY">所有页的存取保护相同，或为</FONT><FONT SIZE=3>PAGE_READONLY</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，或为</FONT><FONT SIZE=3>PAGE_READWRITE</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，或为</FONT><FONT SIZE=3>PAGE_NOACCESS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">函数</FONT><FONT SIZE=3>VirtualProtect</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>允许进程修改进程地址空间中任意占用页的存取保护。举例来说，一个进程可以分配读写页来保存易受影响的数据，然后将存取改变为只读或禁止访问，以避免无意中被重写。典型的，</FONT><FONT SIZE=3>VirtualProtect</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>用于使用</FONT><FONT SIZE=3>VirtualAlloc</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>分配的页，但事实下，它也可以用于通过其它分配函数占用的页。然而，</FONT><FONT SIZE=3>VirtualProtect</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>改变整个页的保护状态，而由其它函数返回的指针并非总是指向页边界。函数</FONT><FONT SIZE=3>VirtualProtectEx</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>类似于</FONT><FONT SIZE=3>VirtualProtect</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，但函数</FONT><FONT SIZE=3>VirtualProtectEx</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以改变指定进程的内存的保护状态。改变这些内存的保护状态在调试程序访问被调试进程的内存的非常有用。</P></FONT></BODY>
</HTML>
