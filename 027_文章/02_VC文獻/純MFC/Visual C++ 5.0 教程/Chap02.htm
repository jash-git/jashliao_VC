<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=gb_2312-80">
<META NAME="Generator" CONTENT="Microsoft Word 97">
<TITLE>第二章 面向对象编程与C++语言</TITLE>
<META NAME="Template" CONTENT="D:\Office95\Template\Manuscripts\32开图书模板.dot">
</HEAD>
<BODY>

<FONT FACE="黑体" LANG="ZH-CN" SIZE=5><P ALIGN="CENTER">第二章</FONT><FONT FACE="Arial" SIZE=5> </FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=5>面向对象编程与</FONT><FONT FACE="Arial" SIZE=5>C++</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=5>语言</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">面向对象的编程是当前程序设计中的热门话题，在这方面已有很多的书籍和其它文献可供参考，而且，全面的讲述面向对象的编程技术也不是本书的任务，在这里，本章仅仅介绍使用</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进行面向对象编程中所用到的一些关键概念，这些概念是进一步学习</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所必须的。除了介绍面向对象编程和</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言的基本概念外，本章还介绍了在使用</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的类时所需注意的一些问题。</P>
<P ALIGN="JUSTIFY">另一个需要注意的问题是，尽管本章会介绍面向对象编程和</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言的基本概念，但是，我们仍然假定阅读本书的读者具有</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言的基础知识，至少，需要使用过</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的类和对象，并且对它们有一定的了解。本章也会介绍类和对象的概念以及如何使用它们，但是，假设你在阅读这些内容之前，对它们还是一无所知，那么，我们建议你最好先看一下一些专门介绍面向对象编程和</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言的入门知识，本书不需要你非常深入的了解这些内容，因为我们假定你懂得</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言，但不假定你精通</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言，本章正是写给那些虽然能够使用</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言中的类和对象进行编程，但是对一些概念的认识还不够清晰的</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>初学者。如果你已经对</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言以及它在</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的实现非常之熟悉，那么，你也可以暂时跳过本章的内容，继续阅读本书的其它章节。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">本章所要讲述的内容包括：</P>

<UL>
<P ALIGN="JUSTIFY"><LI>面向对象的编程的编程技术</LI></P>
<P ALIGN="JUSTIFY"><LI>对象及其特点</LI></P>
<P ALIGN="JUSTIFY"><LI>使用</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的类</LI></P>
<P ALIGN="JUSTIFY"><LI>从已有的类中派生新的类</LI></P>
<P ALIGN="JUSTIFY"><LI>多态及其在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的实现</LI></P>
<P ALIGN="JUSTIFY"><LI>类模板</LI></P></UL>

</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER">第一节</FONT><FONT SIZE=4> </FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>面向对象的编程技术</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">本节阐述面向对象的程序设计方法中的若干重要概念、方法和思想。在刚开始的时候，也许你对这些概念还不大能搞得清楚，但是，随着对</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的使用和了解的深入，当你再回过头来仔细推敲这些概念，就会发现对它们有了新的认识。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">传统的“结构化程序设计”方法是由荷兰学者</FONT><FONT SIZE=3>Dijkstra</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT SIZE=3>70</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>年代提出的，它把面向机器代码的程序抽象为三种基本程序结构：顺序结构、选择结构和重复结构，并提出了一系列的设计原则，如自上而下、逐步求精、模板化编程等。根据这些原则，按照程序所需实现的功能，自上而下层层展开。上层是定义算法的模块，最下层是实现算法的模块。按照这样的规范构成的模块是高度功能性的，有很强的内聚力。但各模块的数据处于实现功能的从属地位，因此，各模块与数据间的相关性就较差，无论把数据分放在各个模块里还是作为全局量放在总控模块中，模块之间都有很大的耦合力。在</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>程序中，多个模块是并发执行的，这样，这种耦合力就会极易导致程序系统出现混乱。</P>
<P ALIGN="JUSTIFY">而且，在传统的语言中，程序是由传递参数的程序和函数的集合组成，每个过程处理它的参数，并可能返回某个值，这种程序是以过程为中心的。在传统的面向过程的程序设计中，程序员必须基于过程来组织模块，这必然会导致程序的结构与应用领域中结构差异很大。</P>
<P ALIGN="JUSTIFY">现行程序设计方法的另一个大的缺点是围绕着各种软件系统中关键结构的作用域与可见性。许多重要的函数或过程的实现主要地取决于关键的数据结构。如果一个或多个这样的数据结构了发生了变化，这种变化将涉及到许多方面，许多函数和过程必须重写。有时几个关键的数据结构发生变化，将导致整个软件系统的结构崩溃。随着软件规模和复杂性的增长，这种缺陷日益明显。当程序达到一定规模后，为了修改一个小的错误，常可能引出多个大的错误，究其原因，问题就出在传统的程序设计方式上。</P>
<P ALIGN="JUSTIFY">而当前的软件应用领域已从传统的科学计算和事务处理扩展到了其它的很多方面，如人工智能、计算机辅助设计和辅助制造等，所需处理的数据也已从简单的数字和字符串发展为记录在各种介质上并且有多种格式的多媒体数据，如数字、正文、图形、声音和影像等。数据量和数据类型的空前激增导致了许多程序的规模和复杂性均接近或达到了用结构化程序设计方法无法管理的程度。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">为了最大限度的得用已有的资源和减少程序开发的工作量，需要有一种比传统的过程式结构化程序设计方法抽象能力更强的新方法，面向对象的程序设计方法正是在这种背景下诞生的。</P>
</FONT><FONT FACE="Arial"><P>2.1.1 </FONT><FONT FACE="黑体" LANG="ZH-CN">面向对象的程序设计</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">面向对象的程序的最根本的目的就是使程序员更好的理解和管理庞大而复杂的程序，它在结构化程序设计的基础上完成进一步的抽象。这种在设计方法上更高层次的抽象正是为了适应目前软件开发的特点。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">最早的“面向对象”设计语言是</FONT><FONT SIZE=3>Smalltalk</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言，该语言是</FONT><FONT SIZE=3>1972</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>年美国</FONT><FONT SIZE=3>Xeron</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>公司</FONT><FONT SIZE=3>Palo Alto</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>研究中心为快速处理各种信息而在</FONT><FONT SIZE=3>Alto</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个人机上研制的软件，</FONT><FONT SIZE=3>1983</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>年正式发行了</FONT><FONT SIZE=3>Smalltalk 2.0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>版。</FONT><FONT SIZE=3>Smalltalk 80</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被认为是最纯的面向对象的语言，该语言只有一种数据类型</FONT><FONT SIZE=3>―</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象。</FONT><FONT SIZE=3>Smalltalk</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>未能推广，</FONT><FONT SIZE=3>Alto</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>机上的软件也从未出售过，但它所开创的面向对象程序设计方法将结构化程序设计的抽象层次又增高了一层，对程序设计方法产生的影响是巨大的。继</FONT><FONT SIZE=3>Smalltalk</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>之后，出现了许多的面向对象的程序设计语言，如</FONT><FONT SIZE=3>Eiffel</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Clos</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Objective-C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等，其它的非面向对象的程序设计语言，如</FONT><FONT SIZE=3>Pascal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Basic</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等也引进了新的面向对象的机制，产生了新的</FONT><FONT SIZE=3>Object Pascal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Visual Basic</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>等面向对象的变种。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">使用面向对象的程序设计方法绝非是要摒弃现有的结构化程序设计方法，相反，它是在充分吸收结构化程序设计优点的基础上，引进了一些新的、强有力的概念，从而开创了程序设计工作的新天地。面向对象的程序设计方法把可重复使用性视为软件开发的中心问题，通过装配可重用的部件来生产软件，而不是像目前编程所用的那样，通过调用函数库中的函数来实现。这里要注意，我们是基于应用程序这一个层次来阐述这些问题是，事实上，在对象内部的实现上，我们常常使用过程式的结构化程序设计方法，也常常调用</FONT><FONT SIZE=3>C/C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数库中的很多有用的函数，然而从程序的总体结构上说，它是由一系列对象构成的，对象之间能够以某种方式进行通信和协作，从而实现程序的具体功能。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">面向对象的程序设计中最基本的概念是对象，一般意义上的对象指的是一个实体的实例，在这个实体中包括了特定的数据和对这些数据进行操作的函数。对于面向对象的程序设计，一个对象具有状态</FONT><FONT SIZE=3>(state)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、行为</FONT><FONT SIZE=3>(behavior)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和标识</FONT><FONT SIZE=3>(identity)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。对象的状态包括它的属性和这些属性的当前值。对象的行为包括可以进行的操作以及所伴随的状态的变化。对象的标识用来区别于其它的对象。而一个</FONT><FONT SIZE=3>COM</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象的行为由它所支持的接口来定义。我们通常不显式的指定</FONT><FONT SIZE=3>COM</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象的状态，而被其接口所包含。使用</FONT><FONT SIZE=3>IUnknown::QueryInterface</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在接口之间进行移动的能力定义了</FONT><FONT SIZE=3>COM</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象的标识。</P>
<P ALIGN="JUSTIFY">对象的核心概念就是通常所说的“封装性”</FONT><FONT SIZE=3>(encapsulation)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、“继承性”</FONT><FONT SIZE=3>(inheritance)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和“多态性”</FONT><FONT SIZE=3>(polymorphism)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，下面我们分别阐述其具体含义。</P>
</FONT><FONT FACE="Arial"><P>2.1.2 </FONT><FONT FACE="黑体" LANG="ZH-CN">封装</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">按照面向对象编程原定义，所谓的封装性是指隐藏类</FONT><FONT SIZE=3>(class)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为支持和实施抽象所作的内部工作的过程。类的接口是公有的，它定义了一个类所能完成的功能，而这些接口的实现是私有的或受保护的，它定义了类完成这些功能所作的具体操作。对于使用这些类的编程者来说，只需要知道类所能完成的功能，而不需要知道这些功能具体是如何实现。拿我们所常的手表作为例子，在使用手表时，我们只需要知道手表所能完成的功能和如何使用手表来完成这些功能，这些内容相当于对象的接口。我们不需要知道在手表的内部，这些功能是如何实现的，因此，对于手表来说，无论手表使用的是一般的机械摆，还是石英振荡器，只要它们的使用方法是完全一样的，用户就没有必要知道这个不同。另一个例子的集成电路芯片，我们只需要知道该芯片的每一个引脚的电气参数和功能，而不必知道这些功能在芯片的内部是如何实现的，就可以使用该芯片来组装电路。如果仅就封装性而言，这里的手表和集成电路芯片就相当于面向对象的编程中的对象。下面我们再举一个例子，众所周知，</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>操作平台目前包括</FONT><FONT SIZE=3>Windows 95</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Windows NT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，而事实上，</FONT><FONT SIZE=3>Windows 95</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Windows NT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>使用了完全不同的内核，对于很多同样的操作，在</FONT><FONT SIZE=3>Windows 95</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Windows NT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>两个操作系统下的实现方式是不同，但两个操作系统都提供了同样的</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序编程接口</FONT><FONT SIZE=3>(API)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这样，我们所编写的应用程序只需要和</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序编程接口打交道，而没有必要知道具体的每一个</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数在操作系统中是如何实现的。换一种说法就是，</FONT><FONT SIZE=3>Windows 95</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Windows NT</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>封装了</FONT><FONT SIZE=3>Win32 API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数的具体实现。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">一个类在定义数据的同时也定义了对这些数据的操作，这些操作称作方法</FONT><FONT SIZE=3>(method)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。按照面向对象的定义，方法就是对对象中的数据的访问。在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，对对象中的数据的访问是通过公有成员函数来进行的，这些公有成员函数可以在对象的外部进行调用，它们提供了对象的外部接口。而对于这些接口的内部的实现在对象的外部的不可见的，这些实现包括了类内部所使用的数据结构和支持公有方法的实现的私有成员函数，通常，这些数据成员和成员函数是私有的，它们只能为类中成员函数所访问，而不能从类的外部进行访问。</P>
<P ALIGN="JUSTIFY">访问一个方法的过程称为向这个对象发送一个消息</FONT><FONT SIZE=3>(message)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，对象的工作是靠消息来激发的，对象之间也是通过消息发生联系的，即请求其它对象做什么或响应其它对象的请求是通过发送或接收消息来实现的。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>这里的所说消息和在</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>编程中所常说的消息是两个不同术语，尽管在某些方面两者的确有很多相象之处。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">封装可避免许多维护性问题。如果一个基本数据类型的结构被修改了，例如一个链表修改成了一个数组，除类中的访问该数据的方法的代码外，软件系统的其余部分是不受影响的，因为基本数据在外部是不可见的，只能通过公有方法的接口与基本数据发生联系，改变一个类的实现，丝毫不影响使用这个类的程序员，从而大大的减少了应用程序出错的可能性。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image246.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image246.gif" WIDTH=544 HEIGHT=346></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>2.1 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>自然世界中的继承关系</P>
</FONT><FONT FACE="Arial"><P>2.1.3 </FONT><FONT FACE="黑体" LANG="ZH-CN">继承</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">类支持层次机制，因此我们可以借用可重用性部件来很容易的从一个或多个已有类出发，来生产各种更符合我们要求的新类。假设我们从类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>出发来派生新的类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，那么我们称类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的基类</FONT><FONT SIZE=3>(base class)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的派生类</FONT><FONT SIZE=3>(derived class)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>继承了类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的各种行为和状态，并可添加自己的成员变量和成员函数。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">我们先来看一个例子，图</FONT><FONT SIZE=3>2.1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>给出了自然世界中的生物的一种继承层次图，最高层次的生物类代表了层次结构中最一般的概念，较低层次的类表示由上一层的类</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>即其基类</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所派生的特殊的概念。如上面的继承关系，动物类从其基类</FONT><FONT SIZE=3>―</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>生物类中继承生物类的所有属性和行为，并且定义了动物类所特有的属性和行为，类似的，脊椎动物类从动物类那儿继承了所有的属性和行为，并且定义了自身特有的属性和行为；……，人类从灵长动物类那儿继承了所有的属性和行为，并且定义了人类所特有的属性和行为。</P>
<P ALIGN="JUSTIFY">之所以举上面的例子是为了将程序空间和现实生活空间来进行对比，结果说明一点，类的继承使得我们可以以一种自然的方式来模拟生活空间中的对象的层次结构，也就是说，我们可以以一种符合正常思维逻辑的自然的方式来思考和组织应用程序的结构，然后，可以将这个结构几乎不作修改或者只需作少量的修改地用面向对象的编程来表达，从而大大的缩短了软件系统的开发周期。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面我们举一个现实编程中的例子，考虑</FONT><FONT SIZE=3>MFC (Microsoft Foundation Class Library</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><FONT SIZE=3>Microsoft</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>基础类库</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的</FONT><FONT SIZE=3>CEdit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>类，它封装了</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的编辑框控件，图</FONT><FONT SIZE=3>2.2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>显示了</FONT><FONT SIZE=3>CEdit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>类的继承结构。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image247.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image247.gif" WIDTH=196 HEIGHT=159></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>2.2 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>类</FONT><FONT SIZE=1>CEdit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>在</FONT><FONT SIZE=1>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>中的继承层次</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在图</FONT><FONT SIZE=3>2.2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，类</FONT><FONT SIZE=3>CObject</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是所有的</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>类的根</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>根是一个术语，它指在继承层次中处于最顶层的类，根是所有继承层次中的类的最终基类</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，在类</FONT><FONT SIZE=3>CObject</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中提供了功能有：串行化支持、运行库信息、对象诊断输出以及与集合类的兼容等。类</FONT><FONT SIZE=3>CCmdTarget</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从类</FONT><FONT SIZE=3>CObject</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>直接派生，它是</FONT><FONT SIZE=3>Microsoft</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>基础类库的消息映射结构的基类，消息映射将命令和消息传递给所编写的处理成员函数，这里，命令指来自菜单项、命令按钮和加速键的消息。类</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>提供了</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中所有窗口类的基本功能性，它封装了</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的窗口句柄</FONT><FONT SIZE=3>hWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。类</FONT><FONT SIZE=3>CEdit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>直接派生，它提供了对</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编辑控件的特定支持。</P>
<P ALIGN="JUSTIFY">我们看到，类</FONT><FONT SIZE=3>CEdit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>本身仅提供了特定于编辑控件的</FONT><FONT SIZE=3>38</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个成员函数，但是，你可以通过类</FONT><FONT SIZE=3>CEdit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进行调用的成员函数却多达</FONT><FONT SIZE=3>300</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>多个，事实上，这些成员函数中的绝大部分由其基类所提供，其中</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就为</FONT><FONT SIZE=3>CEdit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>提供了多达</FONT><FONT SIZE=3>304</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>个成员函数，由于</FONT><FONT SIZE=3>CEdit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>类继承了其基类的数据和方法，因此，可以通过</FONT><FONT SIZE=3>CEdit</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>类调用</FONT><FONT SIZE=3>CWnd</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>类中提供的方法来实现对标准</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>窗口的操作。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">继承机制所带来的最大优势在于使软件系统非常的易于扩充，程序员不仅可以直接的使用各种已有的类，还可以从这些类方便的派生出新的类，新的类继承了基类所包括的所有接口和功能，因此只需要定义和实现与基类所提供的功能中不同的那一部分，这大大的降低了软件开发的复杂性和费用，因此面向对象的编程方式非常之适合于进行大型软件系统的开发。</P>
<P ALIGN="JUSTIFY">降低软件开发的复杂性的意义不仅在于它可以有效的降低软件开发的费用，而且还使得在软件系统中出错的可能性大为减少。由于类有着清晰的继承层次，因此，我们可以很快的定义出错的代码所处的位置，因此能够很快的修正程序中出现的问题。</P>
<P ALIGN="JUSTIFY">继承机制还使得我们可以将与现实生活空间相一致的思维方式应用于程序空间，即我们可以在程序设计时使用直观的思维方式设计程序中所使用的对象的层次结构，然后，直接将此结构映射到面向对象的程序空间，而不需要做任何修改或仅需要作少量修改就可以使用面向对象的程序设计方法来实现该结构。这时，编写程序的过程更类似于“搭积木”，我们可以从很多途径来获得到程序所需使用的各种对象，然后，将这些对象以一定的层次结构组合起来，从而实现程序的逻辑结构。</P>
</FONT><FONT FACE="Arial"><P>2.1.4 </FONT><FONT FACE="黑体" LANG="ZH-CN">多态和虚函数</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在讲述多态之前我们先来看一个问题。仍以前面的图</FONT><FONT SIZE=3>2.2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为例，假定我们已经定义了一个指向哺乳动物类的实例对象的指针，如下所示：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>CMammal *pMammal</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">然后我们定义了一个人类的实例对象和一个狒狒类的实例对象，如下所示：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>CHuman Human;</P>
<P>CBaboon Baboon;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">然后，我们可以将指针</FONT><FONT SIZE=3>pMammal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向</FONT><FONT SIZE=3>Human</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象，在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言中是可以这样做的：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>pMammal=&amp;Human;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">也可以将指针指向</FONT><FONT SIZE=3>Human</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>pMammal=&amp;Baboon;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">考查上面的两种情况，我们假定在哺乳动物类、人类和狒狒类中都定义了一个</FONT><FONT SIZE=3>Eat (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>吃</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>方法，很显然，当我们使用下面的代码来调用人类对象和狒狒类对象的</FONT><FONT SIZE=3>Eat</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>方法时不会遇到什么问题：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>Human.Eat();</P>
<P>Baboon.Eat();</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">但是，现在来考虑下面的代码：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>pMammal-&gt;Eat();</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">当</FONT><FONT SIZE=3>pMammal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向不同的对象时，上面的代码将发生什么样的结果。很显然，当</FONT><FONT SIZE=3>pMammal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向一个哺乳动物类的实例对象时，上面的代码将调用哺乳动物类的</FONT><FONT SIZE=3>Eat</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>方法。但是，当</FONT><FONT SIZE=3>pMammal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向一个人类的实例对象时，上面的代码是调用人类的</FONT><FONT SIZE=3>Eat</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>方法呢，还是仍然调用哺乳动物类的</FONT><FONT SIZE=3>Eat</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>方法？我们期望的是前面一种情况，这就是类和对象的多态性。我们期望，当</FONT><FONT SIZE=3>pMammal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向不同的实例对象时，编译器将根据实例对象的类型调用正确的</FONT><FONT SIZE=3>Eat</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>方法。在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，类的多态性是通过虚函数来实现的。就上面的例子来说，我们将</FONT><FONT SIZE=3>Eat</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>方法定义为一个公有的虚函数，这样，当</FONT><FONT SIZE=3>pMammal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针指向一个人类的实例对象时，编译器调用的就是人类的</FONT><FONT SIZE=3>Eat</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>方法，当</FONT><FONT SIZE=3>pMammal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针指向一个狒狒类的实例对象时，编译器调用的就是狒狒类的实例对象，从而实现了运行时的多态。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，多态定义为不同函数的同一接口。从这个定义出发，函数和操作符的重载也属于多态。</P>
<P ALIGN="JUSTIFY">考虑下面定义的两个函数：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>int print(char*);</P>
<P>int print(int);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的两个不同函数使用同样的函数名，在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，这称为函数的重载。这时，若将一个字符指针传递给</FONT><FONT SIZE=3>print</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数，如下所示：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>char *sz="Hello World!";</P>
<P>print(sz);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这时，编译器调用的是</FONT><FONT SIZE=3>int print(char*)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，如果将一个整型变量传递给</FONT><FONT SIZE=3>print</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数，如下所示：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>int i=0;</P>
<P>print(i);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">则编译器调用的是</FONT><FONT SIZE=3>int print(int)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。这种根据所传递的参数的不同而调用不同函数的情形也称作多态。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面我们来看运算符重载的例子，在下面的过程中，我们为矩阵类重载了运算符“</FONT><FONT SIZE=3>+</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>CMatrix operator +(CMatrix, CMatix);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">然后使用下面的代码：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>int a=1, b=1, c;</P>
<P>CMatrix A(3, 3, 0), B(3, 3, 1), C(3, 3);</P>
<P>c=a+b;</P>
<P>C=A+B;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在上面的例子中，我们定义了三个整型变量和三个类</FONT><FONT SIZE=3>CMatrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实例变量，</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>均为</FONT><FONT SIZE=3>3<FONT FACE="Symbol">&#180;</FONT>
3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的矩阵，其中</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中全部元素均置为</FONT><FONT SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的全部元素均置为</FONT><FONT SIZE=3>1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。然后将“</FONT><FONT SIZE=3>+</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”运算符作用来整型变量和类</FONT><FONT SIZE=3>CMatirx</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实例变量。这时，编译器将表达式</FONT><FONT SIZE=3>c=a+b</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>翻译为</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>c=operator +(a, b);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">而将表达式</FONT><FONT SIZE=3>C=A+B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>翻译为</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>C=operator +(A, B)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">然后，根据传递参数的不同，调用不同的</FONT><FONT SIZE=3>operator +</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">与类和对象的多态不同，对于函数和运算符的多态，是在编译过程中完成的，因此我们将它们称为编译时多态，与此相对，将类和对象的多态称为运行时多态。</P>
<P ALIGN="JUSTIFY">封装性、继承性和多态性是面向对象编程的三大特征，则开始的时候，你也许对它们还没有非常清晰的概念，但这没有什么关系，当你使用了一段时间的</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言，然后再回过头来看这些概念时，你就会发现对它们有了更深入的认识和了解。事实上，许多的</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>程序正是在使用</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言进行编程已有相当一段时间时才对这三个概念有了正确而清晰的认识的。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>在前面的过程中，我们多次混用了对象和类这两个术语，事实上，它们之间是有差别的。在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中，类是一种数据类型，它是一组相同类型的对象的抽象。在类中定义了这一类对象的统一的接口。而对象在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中是指某一数据类型的一个实例，如下面的代码所示：</LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>Class CBaloon;</LI></P>
<P ALIGN="JUSTIFY"><LI>CBaloon Baloon1;</LI></P>
<P ALIGN="JUSTIFY"><LI>CBaloon Baloon2;</LI></P>
<P ALIGN="JUSTIFY"><LI>CBaloon Baloon3;</LI></P></UL>
<DIR>
<DIR>

</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在上面的代码中，我们声明了一个类</FONT><FONT SIZE=3>CBaloon</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，这是所有狒狒对象的抽象，然后，我们使用类来创建了三个不同的实例对象</FONT><FONT SIZE=3>Baloon1</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Baloon2</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Baloon3</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">然而，尽管类和对象是两个意义不同的概念，但是，它们在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>语言中是紧密相关的，这使得很多的文档</FONT><FONT SIZE=3>(</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>包括</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的联机文档</FONT><FONT SIZE=3>)</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>在有些时候也不加区分的混用这两个术语。读者根据相应的上下文，应该能够很方便的辨明它们具体所指的内容究竟是类还是类的实例对象。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>
</DIR>

<P ALIGN="JUSTIFY">在随后的小节中，我们将讲述如何在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中实现上面所说的面向对象的编程概念。</P>
</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER">第二节</FONT><FONT SIZE=4> </FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>类的声明和定义</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">本节讲述在声明和定义类及类中的成员变量和成员函数所需注意的问题。在本章中，我们使用了传统的</FONT><FONT SIZE=3>C/C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编程风格，即每一个程序都以一个名为</FONT><FONT SIZE=3>main</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的主函数为入口，过去常见的</FONT><FONT SIZE=3>MS-DOS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序即是这样的。众所周知，</FONT><FONT SIZE=3>Visual C++ 5.0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不支持</FONT><FONT SIZE=3>16</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>位</FONT><FONT SIZE=3>MS-DOS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编程，但这并不意味着我们必须放弃这种编程模式。事实上，我们仍然可以在</FONT><FONT SIZE=3>Visual C++ 5.0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中编译和调试在本章中出现的所有程序，方法是使用</FONT><FONT SIZE=3>Win32 Console Application (Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>控制台应用程序</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来编译它们，</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>控制台</FONT><FONT SIZE=3>API</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>提供了字符方式的应用程序的编程接口，并且，我们仍可以使用过去所熟知的以</FONT><FONT SIZE=3>main</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数为入口的编程方式。除此之外，</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>平台为控制台应用程序提供了虚拟的一个标准输入和输出设备</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>由于</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>程序共享屏幕和其它所有设备，因此不存在在</FONT><FONT SIZE=3>DOS</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的那种标准输入和输出设备</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这样，我们可以使用标准的</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言输入输出函数</FONT><FONT SIZE=3>scanf</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>printf</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，还可以使用标准的</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言输入和输出流</FONT><FONT SIZE=3>cin</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>cout</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。关于控制台应用程序的内容，可以参考本书的相关章节。</P>
</FONT><FONT FACE="Arial"><P>2.2.1 </FONT><FONT FACE="黑体" LANG="ZH-CN">类及其成员变量和成员函数的声明和定义</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，存在三种类类型：类、结构和联合，它们分别使用三个关键字来声明和定义类：</FONT><FONT SIZE=3>class</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>struct</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>union</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。表</FONT><FONT SIZE=3>2.1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>给出了不同类类型之间的差别。</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>2.1 </FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>三种不同类型的类：类、结构和联合</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=423>
<TR><TD WIDTH="40%" VALIGN="TOP">　</TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">类</FONT></TD>
<TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">结构</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">联合</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">声明和定义时使用的关键字</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">class</FONT></TD>
<TD WIDTH="13%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">struct</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">union</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">默认的成员访问权限</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">私有</FONT></TD>
<TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">公有</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">公有</FONT></TD>
</TR>
<TR><TD WIDTH="40%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">使用限制</FONT></TD>
<TD WIDTH="12%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">无</FONT></TD>
<TD WIDTH="13%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">无</FONT></TD>
<TD WIDTH="35%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">同时只能使用一个成员</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">由于联合的特殊性，我们将在后面的内容中讲述它。下面给出一个使用</FONT><FONT SIZE=3>class</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来定义类的示例：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>class CCircle</P>
<P>{</P>
<P>public:</P>
<P>&#9;unsigned Radius;</P>
<P>&#9;CPoint Center;</P>
<P>};</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">下面我们使用关键字</FONT><FONT SIZE=3>struct</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来定义类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>struct CPoint</P>
<P>{</P>
<P>&#9;unsigned x;</P>
<P>&#9;unsigned y;</P>
<P>};</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>请不要忘了在类定义的第二个大括号“}”之后加上一个分号，否则编译时会出现一堆莫名其妙的错，并且没有一个错误会告诉你是在定义类的时候少加了一个分号</FONT><FONT SIZE=3>(</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>也许它会告诉你别的什么地方少了一个分号，但事实上那里什么错误也没有</FONT><FONT SIZE=3>)</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。也许有人认为这并非是一个值得强调的问题，然而事实上绝大多数初学者</FONT><FONT SIZE=3>(</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>甚至包括一些有经验的程序员</FONT><FONT SIZE=3>)</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>都会由于疏忽大意而犯了这样的错误，并且在修正它的时候花费了大量的时间却依然没有发现所有的问题实际上只是由一个小分号造成的。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">细心的读者会注意到，在类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义中我们使用了</FONT><FONT SIZE=3>public</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字，而在类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义中却没有使用。这是因为在使用</FONT><FONT SIZE=3>struct</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>定义的类中，成员的默认访问权限为公有，因此不需要使用</FONT><FONT SIZE=3>public</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字，而对于使用</FONT><FONT SIZE=3>class</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字来定义的类，由于其成员的默认访问权限为私有，因此必须使用关键字</FONT><FONT SIZE=3>public</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来将成员</FONT><FONT SIZE=3>Radius</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Center</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的访问权限设置为公有。一般来说，一个类中总是包括了一定数量的公有成员，没有公有成员的类由于没有提供任何接口，事实上没有什么用。</P>
<P ALIGN="JUSTIFY">对于同一个类，可以使用关键字</FONT><FONT SIZE=3>class</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来定义，也可以使用关键字</FONT><FONT SIZE=3>struct</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来定义。对于上面的例子，我们将类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>改用关键字</FONT><FONT SIZE=3>struct</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来定义，而将类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>改用关键字</FONT><FONT SIZE=3>class</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来定义如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>struct CCircle</P>
<P>{</P>
<P>&#9;unsigned Radius;</P>
<P>&#9;CPoint Center;</P>
<P>};</P>

<P>class CPoint</P>
<P>{</P>
<P>public:</P>
<P>&#9;unsigned x,y;</P>
<P>};</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">现在我们来考虑一下，如果在同一个文件中定义类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，并采用如上面的代码，会遇到什么问题。我们看到，在类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中定义了类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实例对象</FONT><FONT SIZE=3>Center</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，然而，在定义实例对象</FONT><FONT SIZE=3>Center</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的时候，我们还没有给出类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义，这时，在编译时就会出现错误。因此，我们应该采用下面的顺序：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>struct CPoint</P>
<P>{</P>
<P>&#9;unsigned x;</P>
<P>&#9;unsigned y;</P>
<P>};</P>

<P>class CCircle</P>
<P>{</P>
<P>public:</P>
<P>&#9;unsigned Radius;</P>
<P>&#9;CPoint Center;</P>
<P>};</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">以确保在使用类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这前已经对它进行了定义。如果我们在类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中添加一个成员函数</FONT><FONT SIZE=3>IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来判断一个点是否在圆内，如下面的代码所示：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>struct CPoint</P>
<P>{</P>
<P>&#9;unsigned x;</P>
<P>&#9;unsigned y;</P>
<P>&#9;bool IsInCircle(CCircle *Circle)</P>
<P>&#9;{</P>
<P>&#9;&#9;return ( ((x-Circle-&gt;Center.x)*(x-Circle-&gt;Center.x)</P>
<P>&#9;             +(y-Circle-&gt;Center.y)*(y-Circle-&gt;Center.y))</P>
<P>&#9;             &lt;=Circle-&gt;Radius*Circle-&gt;Radius );</P>
<P>&#9;}</P>
<P>};</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这真是一件很不幸的事情。为什么这样说呢？请看上面的代码，我们在</FONT><FONT SIZE=3>IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数中又使用到了类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，而按照我们在前面所给出的代码，类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是在类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>之后进行定义的，那么，将类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>放到类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>之后定义行不行呢？答案是不行的，不要忘了我们还在类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中定义了一个类型为</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的数据成员</FONT><FONT SIZE=3>Center</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">使用类的声明可以解决上面所遇到的两难问题。为了在定义类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>之前先引用类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的类名，我们可以在类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>之前添加如下的代码：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>Class CCircle;</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>不能在末尾加上一对大括号，因为这样的话，上面的代码就会被当作一个类的定义，这时，在同一文件作用域中就会出现了同一类的两个定义，而这在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中是不允许的，一个类可以有多个声明，但是它只能有一个定义，对于函数也是这样。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">上面的代码和类的定义的差别在于它没有一对大括号“{}”，这样，我们就可以在定义类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>先定义指向一个类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的对象的指针和引用。但是，这时</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的代码不能像上面那样写，这是因为在成员函数</FONT><FONT SIZE=3>IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中我们使用了类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中定义的数据成员，而在此之前编译器只知道用以使用一个名为</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的类，但是不知道这个类中包括了什么样的成员，因此上面的代码在编译时通不过。</P>
<P ALIGN="JUSTIFY">如果解决所遇到的新问题呢？回过头来看类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义，我们在定义类的同时定义了成员函数</FONT><FONT SIZE=3>IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，联想到</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言中的函数，我们可以很自然的想到，可不可以选声明成员函数</FONT><FONT SIZE=3>IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，然后再定义它呢？如果可以这样的话，我们就可以在类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义中先声明成员函数</FONT><FONT SIZE=3>IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，然后在定义了类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>之后再添加成员</FONT><FONT SIZE=3>IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义。</P>
<P ALIGN="JUSTIFY">事实上我们正是基于这个想法来解决问题的。我们的确可以先在类</FONT><FONT SIZE=3>CPoint</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义中声明成员函数</FONT><FONT SIZE=3>IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，然后在后面添加它的定义，完整的代码如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;iostream.h&gt;</P>

<P>class CCircle;</P>

<P>struct CPoint</P>
<P>{</P>
<P>&#9;unsigned x;</P>
<P>&#9;unsigned y;</P>
<P>&#9;bool IsInCircle(CCircle *Circle);</P>
<P>};</P>

<P>class CCircle</P>
<P>{</P>
<P>public:</P>
<P>&#9;unsigned Radius;</P>
<P>&#9;CPoint Center;</P>
<P>};</P>

<P>bool CPoint::IsInCircle(CCircle *Circle)</P>
<P>{</P>
<P>&#9;return ( ((x-Circle-&gt;Center.x)*(x-Circle-&gt;Center.x)</P>
<P>&#9;         +(y-Circle-&gt;Center.y)*(y-Circle-&gt;Center.y))</P>
<P>&#9;         &lt;=Circle-&gt;Radius*Circle-&gt;Radius );</P>
<P>}</P>

<P>void main()</P>
<P>{</P>
<P>&#9;CPoint Center;</P>
<P>&#9;CPoint Point;</P>
<P>&#9;CCircle Circle;</P>
<P>&#9;Center.x=0;</P>
<P>&#9;Center.y=0;</P>
<P>&#9;Point.x=2;</P>
<P>&#9;Point.y=3;</P>
<P>&#9;Circle.Radius=3;</P>
<P>&#9;Circle.Center=Center;</P>
<P>&#9;if (Point.IsInCircle(&amp;Circle))</P>
<P>&#9;&#9;cout&lt;&lt;"The poi</FONT><FONT FACE="隶书" LANG="ZH-CN" SIZE=1>nt is in </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>the circle."&lt;&lt;endl;</P>
<P>&#9;else</P>
<P>&#9;&#9;cout&lt;&lt;"The Point is not in the circle."&lt;&lt;endl;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">我们先看一下函数</FONT><FONT SIZE=3>IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义和一般的函数的定义有什么不同。我们看到，在函数名</FONT><FONT SIZE=3>IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>前使用了作用域限定符“</FONT><FONT SIZE=3>::</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”，即出现在函数定义处的完整的函数名为</FONT><FONT SIZE=3>CCircle::IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这说明了函数</FONT><FONT SIZE=3>IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的一个成员。如果仅使用函数名</FONT><FONT SIZE=3>IsInCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，则编译器不会把它当作类</FONT><FONT SIZE=3>CCircle</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员，而是将它当作一个具有文件作用域的全局函数。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">同在类定义内部定义的成员函数一样，在函数外定义的成员函数一样可以直接的访问类中的数据成员和调用其它的成员函数，而无论它们本身是私有的还是公有的。但是，在类定义内部定义的成员函数和在类定义外部定义的成员函数还是有差别的。对于在类定义内部定义的成员函数，编译器总是将它作为一个内联函数来进行编译，无论你是否使用了</FONT><FONT SIZE=3>inline</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字。而对于在类定义外部定义的成员函数，除非你显式使用了</FONT><FONT SIZE=3>inline</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字，编译不会将它作为一个内联函数来编译。但如果加上了</FONT><FONT SIZE=3>inline</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字，则编译器以同样的方式对待在类定义外部定义的成员函数。一般来说，对于比较短少的成员函数，在可能情况下，我们大多在类定义内部定义它们，而对于代码量比较大的成员函数，则几乎都是在类定义的外部来定义它们，否则，代码的可读性会变得很糟糕。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>请仔细分析下面的代码：</LI></P>
</FONT><FONT FACE                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                的整型成员，我们的确无需返回指向它的指针，使用下面的</FONT><FONT SIZE=3>geti</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>成员函数更好：</P></DIR>
</DIR>


<UL>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>int geti()</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return i;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>}</LI></P></UL>
<DIR>
<DIR>

</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">但是，对于一个结构庞大的对象，基于运行效率的考虑，我们可以不得不返回指向成员的指针，因为当</FONT><FONT SIZE=3>C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>为了返回对象时对这么一个庞大的对象的成员进行逐一拷贝会需要大量的时间。当然，我们可以这样修改</FONT><FONT SIZE=3>geti</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>函数：</P></DIR>
</DIR>


<UL>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>const int* geti()</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return &amp;i;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>}</LI></P></UL>
<DIR>
<DIR>

</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">但是用户使用下面的代码却是合法的：</P></DIR>
</DIR>


<UL>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>int *i=(int*)myCls.geti();</LI></P></UL>
<DIR>
<DIR>

</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">我们没有办法强制使用类</FONT><FONT SIZE=3>MyClass</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的编程者不这样做，尽管我们建设他们不要这样做，但是，编程者应该知道由此可能导致的后果。而我们也的确没有更好的办法来避免出现这样的情况。即使我们愿意牺牲拷贝对象所耗费的时间，在一些情况下，编程者仍然可以将函数的返回值强制为一个引用，这时，由于</FONT><FONT SIZE=3>C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>编译所进行的优化，我们仍然可能通过该引用来修改类中的私有成员的值。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">　</P></DIR>
</DIR>

</FONT><FONT FACE="Arial"><P>2.2.2 </FONT><FONT FACE="黑体" LANG="ZH-CN">成员函数和</FONT><FONT FACE="Arial">this</FONT><FONT FACE="黑体" LANG="ZH-CN">指针</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">类的成员函数可以是静态的，也可以是非静态的。静态的成员函数和静态的成员变量以及它们之间的关系我们将在下一小节中讲述，对于非静态成员函数，由于它可以使用对象中的非静态数据，</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为类的每一个实例对象维护了不同的非静态数据成员，这样，我们很自然的想到一个问题，类的成员函数是如何区分不同的实例对象的数据成员的呢？事实上，对于每一个类的非静态成员函数，都有一个隐含的</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针，该指针指向调用该成员函数的实例对象。</P>
<P ALIGN="JUSTIFY">当成员函数使用对象中的非静态成员</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>无论是成员变量还是成员函数</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，它事实上是通过</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针来调用该成员的。请看下面的代码：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>class MyClass</P>
<P>{</P>
<P>public:</P>
<P>&#9;void seti(int newi)</P>
<P>&#9;{</P>
<P>&#9;&#9;i=newi;</P>
<P>&#9;}</P>
<P>private:</P>
<P>&#9;int i;</P>
<P>};</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">对编译器而言，成员函数</FONT><FONT SIZE=3>seti</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义事实上如下面的代码所示：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>void seti(int newi)</P>
<P>{</P>
<P>&#9;this-&gt;i=newi;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">对于以不同方式定义的成员函数，</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针具有不同的类型，在上面的</FONT><FONT SIZE=3>seti</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数中，</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针的类型为</FONT><FONT SIZE=3>MyClass* const</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这表明，</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针是一个常指针，程序中可能通过</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针来修改类中的成员的值，但不可以修改</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针本身的值，也就是说，不可以对</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针重新赋值，以使它指向另一个对象。</P>
<P ALIGN="JUSTIFY">假设我们在类</FONT><FONT SIZE=3>MyClass</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>定义了另一个成员函数</FONT><FONT SIZE=3>geti</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，如下面的代码所示：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>int geti() const</P>
<P>{</P>
<P>&#9;return i;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在上面的代码中，</FONT><FONT SIZE=3>const</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字表明函数</FONT><FONT SIZE=3>geti</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不会修改调用该成员函数的实例对象中的成员的值。对于编译器而言，上面的成员函数</FONT><FONT SIZE=3>geti</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是这样的：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>int geti() const</P>
<P>{</P>
<P>&#9;return this-&gt;i;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">由于使用了</FONT><FONT SIZE=3>const</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字，则</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针的类型为</FONT><FONT SIZE=3>const MyClass* const</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这表明不但不能修改</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针本身，也不能通过</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针修改对象中的成员。举一个例子，如果我们按如下方式定义</FONT><FONT SIZE=3>seti</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>void seti(int newi) const</P>
<P>{</P>
<P>&#9;i=newi;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的代码将会导致编译错误“</FONT><FONT SIZE=3>l-value specifies const object</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”。</P>
<P ALIGN="JUSTIFY">一般情况下我们不需要显式地使用</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针。下面的代码显示了</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针的一个典型应用：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;windows.h&gt;</P>
<P>#include &lt;stdio.h&gt;</P>
<P>#include &lt;iostream.h&gt;</P>

<P>class MyPosition;</P>

<P>class MyScreen</P>
<P>{</P>
<P>public:</P>
<P>&#9;void PrintMyPosition(MyPosition* pMyPosition);</P>
<P>};</P>

<P>class MyPosition</P>
<P>{</P>
<P>public:</P>
<P>&#9;int x,y;</P>
<P>&#9;void DisplayMyPosition(MyScreen* pMyScreen);</P>
<P>};</P>

<P>void MyScreen::PrintMyPosition(MyPosition* pMyPosition)</P>
<P>{</P>
<P>&#9;HANDLE hConsoleOutput=GetStdHandle(STD_OUTPUT_HANDLE);</P>
<P>&#9;COORD dwCursorPosition={0, 24};</P>
<P>&#9;char sz[80];</P>
<P>&#9;sprintf(sz, "My position is (%d,%d).", pMyPosition-&gt;x, pMyPosition-&gt;y);</P>
<P>&#9;DWORD cWritten;</P>
<P>&#9;WriteConsoleOutputCharacter(hConsoleOutput, sz, lstrlen(sz), </P>
<P>&#9;                            dwCursorPosition, &amp;cWritten);</P>
<P>&#9;dwCursorPosition.X=pMyPosition-&gt;x;</P>
<P>&#9;dwCursorPosition.Y=pMyPosition-&gt;y;</P>
<P>&#9;SetConsoleCursorPosition(hConsoleOutput,dwCursorPosition);</P>
<P>}</P>

<P>void MyPosition::DisplayMyPosition(MyScreen* pMyScreen)</P>
<P>{</P>
<P>&#9;pMyScreen-&gt;PrintMyPosition(this);</P>
<P>}</P>

<P>void main()</P>
<P>{</P>
<P>&#9;MyPosition mypos;</P>
<P>&#9;MyScreen mysrn;</P>
<P>&#9;cout&lt;&lt;"Enter a position (e.g. 4 10): ";</P>
<P>&#9;int x,y;</P>
<P>&#9;cin&gt;&gt;x&gt;&gt;y;</P>
<P>&#9;mypos.x=x;</P>
<P>&#9;mypos.y=y;</P>
<P>&#9;mypos.DisplayMyPosition(&amp;mysrn);</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">请注意类</FONT><FONT SIZE=3>MyPosition</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的</FONT><FONT SIZE=3>DisplayMyPosition</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数，它使用一个指向</FONT><FONT SIZE=3>MyScreen</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象的指针作为参数。在</FONT><FONT SIZE=3>DisplayMyPosition</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数的实现中，调用了</FONT><FONT SIZE=3>MyScreen</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象的</FONT><FONT SIZE=3>PrintMyPosition</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数，</FONT><FONT SIZE=3>PrintMyPosition</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数需要一个指向</FONT><FONT SIZE=3>MyPosition</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象的指针作为其参数，这里，我们希望将指向调用</FONT><FONT SIZE=3>DisplayMyPosition</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员函数的对象本身的指针作为参数进行传递，这时就必须使用</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针。将指向对象自身的指针作为参数传递给其它函数，在实际编程中是一个很常用的技巧，在这些场合，</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针得到了广泛的运用，在以后编程的过程中，我们会经常看到这样的用法。</P>
<P ALIGN="JUSTIFY">除了示范</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针的用法以外，上面的代码还示范了如何在控制台窗口中定位输出字符串的位置。运行上面的程序，它首先要求用户输入一个坐标值，然后，在屏幕的最底行</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这里假定用户使用</FONT><FONT SIZE=3>80<FONT FACE="Symbol">&#180;</FONT>
25</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的控制台窗口大小</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，最后，将下一次显示输出的位置定位于用户所输入的坐标值所指定的点。整个程序运行的结果如图所示。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image248.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image248.gif" WIDTH=423 HEIGHT=280></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>2.3 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>在控制台窗口中进行定位</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>上面的程序代码不能在</FONT><FONT SIZE=3>MS-DOS</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>环境下进行编译和链接，因为我们在程序中显式的调用了</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>控制台</FONT><FONT SIZE=3>API</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>函数</FONT><FONT SIZE=3>(</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>如</FONT><FONT SIZE=3>SetConsoleCursorPosition</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>WriteConsoleOutputCharacter</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>等</FONT><FONT SIZE=3>)</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，它们属于</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>应用程序接口的一部分。为了使用这些函数，我们在程序的最开始包含了头文件</FONT><FONT SIZE=3>windows.h</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。因此，上面的程序尽管具有和普通的</FONT><FONT SIZE=3>MS-DOS</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>环境下的</FONT><FONT SIZE=3>C/C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>程序代码相一致的结构，但它是一个</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>应用程序，只能运行于</FONT><FONT SIZE=3>32</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>位</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>环境。我们可以从上面的函数中看出</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>控制台应用程序和传统的</FONT><FONT SIZE=3>MS-DOS</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>字符模式应用程序之间的本质区别。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">　</P>
</FONT><FONT FACE="Arial"><P>2.2.3 </FONT><FONT FACE="黑体" LANG="ZH-CN">静态成员</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">前面说过，无论是类中的成员变量还是成员函数，都可以声明为静态的。类的静态成员在工作起来和非静态成员有很大的差别，因此我们在这里用单独的一个小节来讲述它们。</P>
<P ALIGN="JUSTIFY">先看一个静态数据成员的例子。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;iostream.h&gt;</P>

<P>class MyClass</P>
<P>{</P>
<P>&#9;public:</P>
<P>&#9;static int i;</P>
<P>};</P>

<P>int MyClass::i;</P>

<P>void main()</P>
<P>{</P>
<P>&#9;MyClass cls1;</P>
<P>&#9;MyClass cls2;</P>
<P>&#9;cls1.i=1;</P>
<P>&#9;cout&lt;&lt;"cls1.i="&lt;&lt;cls1.i&lt;&lt;"  cls2.i="&lt;&lt;cls2.i&lt;&lt;endl;</P>
<P>&#9;cls2.i=2;</P>
<P>&#9;cout&lt;&lt;"cls1.i="&lt;&lt;cls1.i&lt;&lt;"  cls2.i="&lt;&lt;cls2.i&lt;&lt;endl;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的示例程序的运行结果如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>cls1.i=1  cls2.i=1</P>
<P>cls1.i=2  cls2.i=2</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">为什么会出现这样的结果呢？这就是静态数据成员和非静态数据成员的一个极大的不同之处。对于同一类的所有实例对象，</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>只为它们维护了一份静态变量的拷贝，通过每一个对象对这些静态变量进行操作，事实上都是对同一个数据区域进行操作。这就可以解释上面的运行结果了，无论我们使用表达式</FONT><FONT SIZE=3>cls1.i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>还是表达式</FONT><FONT SIZE=3>cls2.i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，它们都是对同一个</FONT><FONT SIZE=3>i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进行操作，很自然，使用表达式</FONT><FONT SIZE=3>cls1.i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>修改了静态成员</FONT><FONT SIZE=3>i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的值，表达式</FONT><FONT SIZE=3>cls2.i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的值会立即反映所作的修改。</P>
<P ALIGN="JUSTIFY">为了更清晰的说明问题，使用下面的代码替换前面的</FONT><FONT SIZE=3>main</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>主函数：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>void main()</P>
<P>{</P>
<P>&#9;MyClass cls1;</P>
<P>&#9;MyClass cls2;</P>
<P>&#9;cout&lt;&lt;"Address of cls1.i is "&lt;&lt;&amp;cls1.i&lt;&lt;endl;</P>
<P>&#9;cout&lt;&lt;"Address of cls2.i is "&lt;&lt;&amp;cls2.i&lt;&lt;endl;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">运行修改后的程序，得到如下的结果：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>Address of cls1.i is 0x0041A0B0</P>
<P>Address of cls2.i is 0x0041A0B0</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">这下子就真象大白了。无论是</FONT><FONT SIZE=3>cls1.i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，还是</FONT><FONT SIZE=3>cls2.i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，它们都对应于同一块内存区域。那么，使用</FONT><FONT SIZE=3>cls1.i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>还是</FONT><FONT SIZE=3>cls2.i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>还有什么意义呢？的确是没有什么意义。更能够说明问题的使用方法是用</FONT><FONT SIZE=3>MyClass::i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来代替</FONT><FONT SIZE=3>cls1.i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>cls2.i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这种容易令人混淆的表达式。事实上，即使你使用了如下格式的表达式</P>
</FONT><I><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>objectname</I>.<I>staticmember</I>;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">位于成员选择运算符“</FONT><FONT SIZE=3>.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”前面的部分也永远不会被求值。考虑如下的代码：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>GetMyClass().i=1;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这里我们假设函数</FONT><FONT SIZE=3>GetMyClass</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的返回值为一个类型为</FONT><FONT SIZE=3>MyClass</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实例对象，由于编译器不对</FONT><FONT SIZE=3>GetMyClass()</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进行求值，事实上函数</FONT><FONT SIZE=3>GetMyClass</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>永远也不会被调用，位于函数中的任何代码都不会被执行。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">现在回过去看前面的例子，我们注意到，在编译该示例程序的时候，出现了两条警告信息：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>'cls1' : unreferenced local variable</P>
<P>'cls2' : unreferenced local variable</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">由于编译器不对表达式</FONT><FONT SIZE=3>cls1.i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>cls2.i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中运算符“</FONT><FONT SIZE=3>.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”前面的部分进行求值，而是把它们看作</FONT><FONT SIZE=3>MyClass::i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这样，对象</FONT><FONT SIZE=3>cls1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>cls2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>实际上没有使用，因此编译器给出上面的两条错误信息。</P>
<P ALIGN="JUSTIFY">这里我们还可能得出一条结论，即是说，即使没有定义类的任何实例对象，也可以使用类中声明的静态数据成员。这个问题可以这样解释，类中的静态成员事实上不是类的实例对象的一部分，它们是单独的对象，尽管我们在类中声明了类的静态成员，但它们事实上具有文件作用域，因此我们必须在类定义的外部定义该成员变量。这就是为什么要在上面的程序代码文件中添加语句</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>int MyClass::i;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">的原因。</P>
<P ALIGN="JUSTIFY">不同于非静态数据成员，可以在定义类的静态成员的时候同时进行初始化，对于上面的静态成员</FONT><FONT SIZE=3>i</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，使用下面的定义语句是合法的：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>int MyClass::i=0;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面我们来讲述类中的静态成员函数。前面已经讲过，不像非静态成员函数那样，静态成员函数没有隐含的</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针，因此，它们只能访问类中的静态数据成员、枚举和嵌套类型。而且，同静态数据成员一样，调用静态成员函数不需要有类的实例对象。看下面的例子：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;iostream.h&gt;</P>

<P>class MyClass</P>
<P>{</P>
<P>public:</P>
<P>&#9;static int Count()</P>
<P>&#9;{</P>
<P>&#9;&#9;return nCount;</P>
<P>&#9;}</P>
<P>&#9;static void Add(int NewElement)</P>
<P>&#9;{</P>
<P>&#9;&#9;nCount++;</P>
<P>&#9;}</P>
<P>private:</P>
<P>&#9;static int nCount;</P>
<P>};</P>

<P>int MyClass::nCount=0;</P>

<P>void main()</P>
<P>{</P>
<P>&#9;cout&lt;&lt;"Count="&lt;&lt;MyClass::Count()&lt;&lt;endl;</P>
<P>&#9;for (int i=1; i&lt;=5; i++)</P>
<P>&#9;{</P>
<P>&#9;&#9;MyClass::Add(i);</P>
<P>&#9;}</P>
<P>&#9;cout&lt;&lt;"Count="&lt;&lt;MyClass::Count()&lt;&lt;endl;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">我们没有定义一个类</FONT><FONT SIZE=3>MyClass</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实例对象，但仍可以使用其中的所有公有的静态数据成员和静态成员函数。上面的示例程序的运行结果如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>Count=0</P>
<P>Count=5</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">同非静态成员函数相比，静态成员函数的使用受到如下的限制：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">1.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不能在静态成员函数中直接访问类中的非静态成员；</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">2.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不能将静态成员函数定义为虚函数</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关于虚函数将在后面的内容中讲到</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>可以仅在类中声明其静态成员函数，然后在类的外部添加其定义，但这并不是必须的。可以在类中声明静态成员函数的同时定义它们。</LI></P>
<P ALIGN="JUSTIFY"><LI>同静态数据成员一样，如果使用成员选择运算符“</FONT><FONT SIZE=3>.</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>”和“</FONT><FONT SIZE=3>-&gt;</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>”来调用类的静态成员函数，表达式中运算符“</FONT><FONT SIZE=3>.</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>”和“</FONT><FONT SIZE=3>-&gt;</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>”前面的表达式不会被求值，如果在这一部分进行了函数调用，则这些函数永远也不会真正的被调用。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">　</P>
</FONT><FONT FACE="Arial"><P>2.2.4 </FONT><FONT FACE="黑体" LANG="ZH-CN">联合</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">前面说到，联合实际上也是一种类型的类。但与使用</FONT><FONT SIZE=3>class</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字和</FONT><FONT SIZE=3>struct</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字定义的类不同，联合中的所有数据成员共享同一块内存区域。这就是说，当你修改了联合中的一个数据成员的值，那么，其中所有数据成员的值都会因此而受到影响，请看下面的例子：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;iostream.h&gt;</P>
<P>#include &lt;iomanip.h&gt;</P>

<P>union Numeric</P>
<P>{</P>
<P>&#9;short iValue;</P>
<P>&#9;long lValue;</P>
<P>};</P>

<P>void main()</P>
<P>{</P>
<P>&#9;Numeric num;</P>
<P>&#9;num.lValue=1000000000;</P>
<P>&#9;cout&lt;&lt;"num.lValue=0x"&lt;&lt;setiosflags(ios::uppercase)&lt;&lt;hex&lt;&lt;num.lValue&lt;&lt;endl;</P>
<P>&#9;cout&lt;&lt;"num.iValue=0x"&lt;&lt;setiosflags(ios::uppercase)&lt;&lt;hex&lt;&lt;num.iValue&lt;&lt;endl;</P>
<P>&#9;num.iValue=10000;</P>
<P>&#9;cout&lt;&lt;"num.lValue=0x"&lt;&lt;setiosflags(ios::uppercase)&lt;&lt;hex&lt;&lt;num.lValue&lt;&lt;endl;</P>
<P>&#9;cout&lt;&lt;"num.iValue=0x"&lt;&lt;setiosflags(ios::uppercase)&lt;&lt;hex&lt;&lt;num.iValue&lt;&lt;endl;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的示例程序的运行结果如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>num.lValue=0x3B9ACA00</P>
<P>num.iValue=0xCA00</P>
<P>num.lValue=0x3B9A2710</P>
<P>num.iValue=0x2710</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">为了便于说明问题，我们使用十六进制格式来表示</FONT><FONT SIZE=3>iValue</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>lValue</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>成员的值，我们看到，如果在程序中修改了</FONT><FONT SIZE=3>lValue</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的值，那么相应的</FONT><FONT SIZE=3>iValue</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的值也会发生改变，反之亦然。</P>
<P ALIGN="JUSTIFY">使用下面的代码替换上面的</FONT><FONT SIZE=3>main</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>主函数，我们不难得出答案：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>void main()</P>
<P>{</P>
<P>&#9;Numeric num;</P>
<P>&#9;cout&lt;&lt;"Address of iValue: "&lt;&lt;&amp;num.iValue&lt;&lt;endl;</P>
<P>&#9;cout&lt;&lt;"Address of lValue: "&lt;&lt;&amp;num.lValue&lt;&lt;endl;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">运行得如下的结果：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>Address of iValue: 0x0012FF7C</P>
<P>Address of lValue: 0x0012FF7C</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">该结果证实了我们在前面所说的内容：联合中的所有成员共享同一块内存区域。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">同使用关键字</FONT><FONT SIZE=3>class</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>struct</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>定义的类一样，在联合中也可以定义成员函数，这里限于篇幅，就不再举例说明了。</P>
<P ALIGN="JUSTIFY">但要注意，使用联合存在如下的限制：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">1.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>联合中不可以包括虚函数，因为联合不可以使用其它的类、结构和联合作为其基类，也不可以作为其它的类、结构和联合的基类。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">2.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>联合中不可以包括以下数据成员：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">(1)&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>具有构造函数和析构函数的类；</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">(2)&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>具有自定义赋值运算符的类；</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">(3)&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>静态数据成员。</P>
</FONT><FONT FACE="Arial"><P>2.2.5 </FONT><FONT FACE="黑体" LANG="ZH-CN">构造函数和析构函数</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">前面我们不只一次提到构造函数和析构函数，本节中对这两个概念进行进一步的阐述。</P>
<P ALIGN="JUSTIFY">构造函数在创建类的实例对象时被调用，以对类中的数据进行初始化，在</FONT><FONT SIZE=3>2.2.1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>节最后的示例代码中我们给出了一个使用构造函数来初始化类中的数据成员的例子。</P>
<P ALIGN="JUSTIFY">在对象创建的时候，构造函数依次完成以下操作：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">1.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果类是从一个虚基类派生，则构造函数初始化对象的虚拟基指针；</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">2.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>按声明的顺序调用基类及成员的构造函数；</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">3.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果在类中声明了虚函数，或者类从基类中继承了虚函数，则初始化对象的虚函数指针，虚函数指针指向类的虚函数表，从而保证在虚函数调用时能够进行正确的绑定；</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">4.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>运行包括在构造函数中的代码。</P>
<P ALIGN="JUSTIFY">构造函数名和类名相同，并且不具有任何返回类型，即使是</FONT><FONT SIZE=3>void</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>也不可以。可以在构造函数中使用</FONT><FONT SIZE=3>return</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语句，但不可以通过构造函数返回任何类型的值。</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>允许定义多个使用不同参数列表的构造函数。这里有两种特殊的构造函数，缺省构造函数和拷贝构造函数。缺省构造函数不带任何类型的参数，而拷贝构造函数带有一个单个参数，该参数的类型为一个对相同类的实例对象的引用。</P>
<P ALIGN="JUSTIFY">如果编程者在类中没有显式的定义一个缺省构造函数，则编译器会为类生成一个缺省构造函数，如果编程者在类中没有显式的定义一个拷贝构造函数，则编译器会为类生成一个拷贝构造函数。由编译器生成的构造函数者被当作是类的公有成员函数。</P>
<P ALIGN="JUSTIFY">编译器提供的缺省构造函数创建对象，并初始化虚拟基表和虚拟函数表，如果基类和成员提供了可用的构造函数，缺省构造函数还将调用基类和成员的构造函数，其顺序如前所述。除此之外，由编译器生成的缺省构造函数不进行其它的操作。</P>
<P ALIGN="JUSTIFY">编译器提供的拷贝构造函数创建新的对象，并将当作参数传递给拷贝构造函数的对象中的成员逐个的拷贝到新的对象中。如果基类或成员提供了相应的构造函数，则调用这些构造函数，否则执行按位拷贝。</P>
<P ALIGN="JUSTIFY">作为一个实用的例子，下面的示例代码给出了一个简单的矩阵类，并为矩阵类定义了最基本的运算，包括矩阵加法、减法、乘法以及矩阵的转置运算，除此之外，该类还提供了另一些有用的功能，如矩阵的流式输出等。在示例代码中使用了友元函数和操作符重载的概念，如果对这些概念不够熟悉，可以先略过它们，在本章的后面内容中将有关于操作符重载和友元函数的相关内容。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>class matrix</P>
<P>{</P>
<P>public:</P>
<P>&#9;matrix(int rsize,int csize,float init=0);</P>
<P>&#9;matrix(matrix&amp; A);</P>
<P>&#9;~matrix();</P>
<P>&#9;friend matrix operator+(matrix&amp; A,matrix&amp; B);</P>
<P>&#9;friend matrix operator-(matrix&amp; A,matrix&amp; B);</P>
<P>&#9;friend matrix operator*(matrix&amp; A,matrix&amp; B);</P>
<P>&#9;friend ostream&amp; operator&lt;&lt;(ostream&amp; out,matrix&amp; A);</P>
<P>&#9;matrix&amp; operator=(matrix&amp; A);</P>
<P>&#9;float&amp; operator()(int midx,int nidx);</P>
<P>&#9;matrix transpose();</P>
<P>protected:</P>
<P>&#9;float *elem;</P>
<P>&#9;int m;</P>
<P>&#9;int n;</P>
<P>};</P>

<P>ostream&amp; operator&lt;&lt;(ostream&amp; out,matrix&amp; A)</P>
<P>{</P>
<P>&#9;int width=out.width();</P>
<P>&#9;for(int i=1;i&lt;=A.m;i++)</P>
<P>&#9;{</P>
<P>&#9;&#9;for(int j=1;j&lt;=A.n;j++)</P>
<P>&#9;&#9;&#9;out&lt;&lt;setw(width)&lt;&lt;A(i,j);</P>
<P>&#9;&#9;out&lt;&lt;endl;</P>
<P>&#9;}</P>
<P>&#9;return out;</P>
<P>}</P>

<P>matrix::matrix(int row,int col,float init)</P>
<P>{</P>
<P>&#9;m=row;</P>
<P>&#9;n=col;</P>
<P>&#9;elem=new float[row*col];</P>
<P>&#9;for(int i=0;i&lt;row*col;i++)</P>
<P>&#9;&#9;*(elem+i)=init;</P>
<P>}</P>

<P>matrix::~matrix()</P>
<P>{</P>
<P>&#9;delete []elem;</P>
<P>}</P>

<P>matrix operator+(matrix&amp; A,matrix&amp; B)</P>
<P>{</P>
<P>&#9;matrix result(A.m,A.n);</P>
<P>&#9;for(int i=1;i&lt;=result.m;i++)</P>
<P>&#9;&#9;for(int j=1;j&lt;=result.n;j++)</P>
<P>&#9;&#9;&#9;result(i,j)=A(i,j)+B(i,j);</P>
<P>&#9;return result;</P>
<P>}</P>

<P>matrix operator-(matrix&amp; A,matrix&amp; B)</P>
<P>{</P>
<P>&#9;matrix result(A.m,A.n);</P>
<P>&#9;for(int i=1;i&lt;=result.m;i++)</P>
<P>&#9;&#9;for(int j=1;j&lt;=result.n;j++)</P>
<P>&#9;&#9;&#9;result(i,j)=A(i,j)-B(i,j);</P>
<P>&#9;return result;</P>
<P>}</P>

<P>matrix operator*(matrix&amp; A,matrix&amp; B)</P>
<P>{</P>
<P>&#9;matrix result(A.m,B.n,0);</P>
<P>&#9;for(int i=1;i&lt;=result.m;i++)</P>
<P>&#9;&#9;for(int j=1;j&lt;=result.n;j++)</P>
<P>&#9;&#9;&#9;for(int k=1;k&lt;=A.n;k++)</P>
<P>&#9;&#9;&#9;&#9;result(i,j)+=A(i,k)*B(k,j);</P>
<P>&#9;return result;</P>
<P>}</P>

<P>matrix&amp; matrix::operator=(matrix&amp; A)</P>
<P>{</P>
<P>&#9;m=A.m;</P>
<P>&#9;n=A.n;</P>
<P>&#9;elem=new float[m*n];</P>
<P>&#9;for(int i=1;i&lt;=m;i++)</P>
<P>&#9;&#9;for(int j=1;j&lt;=n;j++)</P>
<P>&#9;&#9;&#9;operator ()(i,j)=A(i,j);</P>
<P>&#9;return *this;</P>
<P>}</P>

<P>matrix::matrix(matrix&amp; A)</P>
<P>{</P>
<P>&#9;m=A.m;</P>
<P>&#9;n=A.n;</P>
<P>&#9;elem=new float[m*n];</P>
<P>&#9;for(int i=1;i&lt;=m;i++)</P>
<P>&#9;&#9;for(int j=1;j&lt;=n;j++)</P>
<P>&#9;&#9;&#9;operator ()(i,j)=A(i,j);</P>
<P>}</P>

<P>matrix matrix::transpose()</P>
<P>{</P>
<P>&#9;matrix result(n,m);</P>
<P>&#9;for(int i=1;i&lt;=n;i++)</P>
<P>&#9;&#9;for(int j=1;j&lt;=m;j++)</P>
<P>&#9;&#9;&#9;result(i,j)=operator()(j,i);</P>
<P>&#9;return result;</P>
<P>}</P>

<P>float&amp; matrix::operator()(int row,int col)</P>
<P>{</P>
<P>&#9;static float err=.0;</P>
<P>&#9;if (row&gt;0 &amp;&amp; col&gt;0 &amp;&amp; row&lt;=m &amp;&amp; col&lt;=n)</P>
<P>&#9;&#9;return *(elem+(row-1)*n+col-1);</P>
<P>&#9;else</P>
<P>&#9;&#9;return err;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">一个构造函数可以带有任意类型的参数表，对于可以不使用任何参数的构造函数，编译器将它当作一个缺省构造函数，对于可以使用一个对同类型的实例对象的引用作为参数的构造函数，编译器将它当作一个拷贝构造函数。在上面的例子中，由于函数</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>matrix(int rsize=0,int csize=0,float init=0);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">可以不使用任何参数，因此可以将它作为类的缺省构造函数，由于函数</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>matrix(matrix&amp; A);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">使用了一个对</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>实例对象的引用作为参数，因此它被当作一个拷贝构造函数。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">我们提供自定义的缺省构造函数和拷贝构造函数的唯一目的是为了进行特殊的初始化操作。考虑类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，其缺省                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                FONT SIZE=3>Win32 Release</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>版本，这样会产生很多的假象，从而掩盖了程序中确实存在的问题。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>
</DIR>

<P ALIGN="JUSTIFY">解决这个问题的办法是提供自定义的拷贝构造函数。试将下面的代码段放到类</FONT><FONT SIZE=3>MyClass</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义中：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>MyClass(MyClass&amp; cls)</P>
<P>{</P>
<P>&#9;p=new float;</P>
<P>&#9;*p=*(cls.p);</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这时再以</FONT><FONT SIZE=3>Win32 Debug</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编译和运行程序，就不会出现如图</FONT><FONT SIZE=3>2.4</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示的错误了，而且，由下面的运行结果可知，两个实例对象</FONT><FONT SIZE=3>cls1</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>cls2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员指针</FONT><FONT SIZE=3>p</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>也指向了不同的内存地址。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>Address of cls1.p: 0x00430D20</P>
<P>Address of cls2.p: 0x00430D50</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">现在回到类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，请观察它的拷贝构造函数</FONT><FONT SIZE=3>matrix::matrix(matrix&amp; A)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，在其中使用了与上面的类</FONT><FONT SIZE=3>MyClass</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的拷贝构造函数</FONT><FONT SIZE=3>MyClass::MyClass(MyClass&amp; cls)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>相类似的技巧。</P>
<P ALIGN="JUSTIFY">下面我们来考虑一样在那些情况下需要调用拷贝构造函数。</P>
<P ALIGN="JUSTIFY">第一种情况如前面的</FONT><FONT SIZE=3>MyClass</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的示例代码，我们以主函数中使用了下面的代码：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>MyClass ch2=ch1;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的代码导致编译器调用类</FONT><FONT SIZE=3>MyClass</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的拷贝构造函数，如果用户没有在类</FONT><FONT SIZE=3>MyClass</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中显式定义拷贝构造函数</FONT><FONT SIZE=3>MyClass::MyClass(MyClass&amp; cls)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，则使用编译器缺省生成的拷贝构造函数。</P>
<P ALIGN="JUSTIFY">第二种情况是使用下面的代码：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>MyClass ch2(ch1);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这种情况和第一种情况几乎一样。</P>
<P ALIGN="JUSTIFY">第三种情况最为复杂。在某些情况下，编译器需要创建一些临时对象，考虑前面定义的类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，由于我们在类中定义了运算符“</FONT><FONT SIZE=3>*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”，因此，在程序中可以出现这样的表达式：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>A*B*C</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这里我们假定</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的三个实例对象，且它们满足矩阵乘法运算的要求，即</FONT><FONT SIZE=3>A.n=B.m</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><FONT SIZE=3>B.n=C.m</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。这时，编译器先调用函数</FONT><FONT SIZE=3>operator*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>计算</FONT><FONT SIZE=3>(A*B)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，然后，由于表达式中没有指定一个对象用来保存</FONT><FONT SIZE=3>A*B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的计算结果，因此，编译器创建一个临时对象，我们这时使用</FONT><FONT SIZE=3>temporary</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来指代这个临时对象，然后使用拷贝构造函数将函数</FONT><FONT SIZE=3>operator*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的返回值拷贝到对象</FONT><FONT SIZE=3>temporary</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，最后，再调用函数</FONT><FONT SIZE=3>operator*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>计算</FONT><FONT SIZE=3>temporary*B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的值。这里，尽管我们没有显式的调用拷贝构造函数，但拷贝构造函数还是被调用了多次，如果使用由编译器提供了拷贝构造函数，那么，在析构函数</FONT><FONT SIZE=3>matrix::~matrix()</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中释放使用</FONT><FONT SIZE=3>new</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>运算符动态分配给成员</FONT><FONT SIZE=3>elem</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的内存时就会出现指针挂起的问题。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">因此，如果在类中使用了成员指针，一般来说，我们需要给出自定义的拷贝构造函数，以保证不会出现指针挂起的问题。</P>
<P ALIGN="JUSTIFY">关于构造函数最后简单的说一点，这就是我们可以在构造函数中使用自定义的参数表。以类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的构造函数为例，我们可以以下面的三种方式调用其构造函数：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>// 创建一个 0<FONT FACE="Symbol">&#180;</FONT>
0 的矩阵，事实上没有多大的意义</P>
<P>matrix M()</P>
<P>// 创建一个 2<FONT FACE="Symbol">&#180;</FONT>
2 的方阵，由于 init 取默认值，方阵的所有元素被初始化为 0</P>
<P>matrix M(2,2)</P>
<P>// 创建一个 2<FONT FACE="Symbol">&#180;</FONT>
3 的矩阵，并将所有元素初始化为 1</P>
<P>matrix M(2,3,1)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">下面现在我们简单介绍一下析构函数，析构函数在释放对象时被调用，对象的释放发生在以下的几种情况下：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">1.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>使用运算符</FONT><FONT SIZE=3>new</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>分配的对象被显式的使用运算符</FONT><FONT SIZE=3>delete</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>删除；</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">2.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>一个具有块作用域的本地</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>自动</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>对象超出其作用域；</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">3.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>临时对象的生存期结束；</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">4.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>程序结束运行；</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">5.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>使用完全限定名显式调用对象的析构函数；</P>
<P ALIGN="JUSTIFY">析构函数的函数为类名前加波浪号“</FONT><FONT SIZE=3>~</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”，如前面的例子，类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的析构函数被命名为</FONT><FONT SIZE=3>~matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，同构造函数一样，析构函数不可以有任何返回值，哪怕是</FONT><FONT SIZE=3>void</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>也不可以。不同的是，析构函数不得带有任何参数，但是，析构函数可以被声明为虚函数，这样，即使不知道对象的确切类型，也可以通过析构函数完全的释放对象。</P>
<P ALIGN="JUSTIFY">我们常常的析构函数中释放在构造函数中所动态分配的内存，例如前面的类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的示例，我们在析构函数</FONT><FONT SIZE=3>matrix::~matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中释放了在构造函数中使用运算符</FONT><FONT SIZE=3>new</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为指针</FONT><FONT SIZE=3>elem</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>分配的内存。在</FONT><FONT SIZE=3>Windows</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序中，我们还常常需要在类的析构函数中释放对象所占用的其它系统资源。</P>
</FONT><FONT FACE="Arial"><P>2.2.6 </FONT><FONT FACE="黑体" LANG="ZH-CN">友元</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">在上一节的类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中出现了一个新的关键字</FONT><FONT SIZE=3>friend</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，在一个类的定义中对一个函数使用</FONT><FONT SIZE=3>friend</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字说明了该函数是类的一个友元函数。友元函数不属于为类的成员，因此类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的友元函数</FONT><FONT SIZE=3>operator+</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义是</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>matrix operator+(matrix&amp; A,matrix&amp; B)</P>
<P>{</P>
<P>&#9;...</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">而不是</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>matrix matrix::operator+(matrix&amp; A,matrix&amp; B)</P>
<P>{</P>
<P>&#9;...</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">友元函数虽然不是类的成员，但却有访问类的受保护成员和私有成员的权限，这就是</FONT><FONT SIZE=3>friend</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字的作用。在一些情况下这是必须的，事实上，我们在类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>定义的大多数友元运算符函数都可以定义为类的成员函数，但运算符函数</FONT><FONT SIZE=3>operator&lt;&lt;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是一个例外，因为定义为成员函数的二元运算符函数只能带一个参数，该参数的类型指定了位于运算符右边的操作数的类型，而位于运算符左边的操作数必须是类的一个实例对象，而对于运算符“</FONT><FONT SIZE=3>&lt;&lt;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”，由于左边的操作数是一个对类</FONT><FONT SIZE=3>ostream</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实例对象的引用，因此它不可以被重载为类的成员函数，而我们又需要在函数</FONT><FONT SIZE=3>operator&lt;&lt;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中访问类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实例对象</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的受保护成员</FONT><FONT SIZE=3>m</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>n</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，因此，我们必须将函数</FONT><FONT SIZE=3>operator&lt;&lt;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>声明为类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的友元函数，这样，我们既可以使用类</FONT><FONT SIZE=3>ostream</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的对象作为运算符“</FONT><FONT SIZE=3>&lt;&lt;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”的左操作数，又可以在运算符函数</FONT><FONT SIZE=3>operator&lt;&lt;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中访问类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的受保护成员。从这个角度来说，友元函数的确为我们带来了很大的便利之处。但我们要提醒的是，不要滥用友元函数，因为如果大量的使用友元函数，那么当初把这些成员的访问权限设置为受保护或私有也就失去了应有的意义了。一般来说，我们只将</FONT><FONT SIZE=3>friend</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字应用于运算符重载函数以及一些和类关系极为密切的类和函数上。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">除了将具有文件作用域的全局函数指定为的类的友元外，还可以将其它某个类的成员函数指定为类的友元，请看下面的例子：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;iostream.h&gt;</P>

<P>class A;</P>

<P>class B</P>
<P>{</P>
<P>public:</P>
<P>&#9;int&amp; geti();</P>
<P>&#9;B();</P>
<P>&#9;B(B&amp;);</P>
<P>&#9;~B();</P>
<P>&#9;B&amp; operator=(B&amp;);</P>
<P>private:</P>
<P>&#9;A *pA;</P>
<P>&#9;friend class A;</P>
<P>};</P>

<P>class A</P>
<P>{</P>
<P>public:</P>
<P>&#9;void addout(B&amp; b)</P>
<P>&#9;{</P>
<P>&#9;&#9;cout&lt;&lt;"The address of A in B is "&lt;&lt;b.pA&lt;&lt;endl;</P>
<P>&#9;}</P>
<P>private:</P>
<P>&#9;int i;</P>
<P>&#9;friend int&amp; B::geti();</P>
<P>};</P>

<P>void main()</P>
<P>{</P>
<P>&#9;B b;</P>
<P>&#9;A a;</P>
<P>&#9;b.geti()=1;</P>
<P>&#9;a.addout(b);</P>
<P>&#9;cout&lt;&lt;"b.pA-&gt;i="&lt;&lt;b.geti()&lt;&lt;endl;</P>
<P>}</P>

<P>B::B()</P>
<P>{</P>
<P>&#9;pA=new A;</P>
<P>}</P>

<P>B::B(B&amp; b)</P>
<P>{</P>

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 LANG="ZH-CN" SIZE=3>视结构，在需要频繁的访问文档和视中的成员时，使文档类和视类互为友元要更为方便。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>友元关系不可以被继承。假设类</FONT><FONT SIZE=3>A</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>是类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的友元，而类</FONT><FONT SIZE=3>C</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>从类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>派生，如果我们没有在类</FONT><FONT SIZE=3>C</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中显式地使用下面的语句：</LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>friend class A;</LI></P></UL>
<DIR>
<DIR>

</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">那么，尽管类</FONT><FONT SIZE=3>A</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>是类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的友元，但这种关系不会被继承到类</FONT><FONT SIZE=3>C</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，也就是说，类</FONT><FONT SIZE=3>C</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和类</FONT><FONT SIZE=3>A</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>没有友元关系，类</FONT><FONT SIZE=3>A</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的成员函数不可以直接访问类</FONT><FONT SIZE=3>C</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的受保护成员和私有成员。</P></DIR>
</DIR>


<UL>
<P ALIGN="JUSTIFY"><LI>不存在“友元的友元”这种关系。假设类</FONT><FONT SIZE=3>A</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>是类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的友元，而类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>是类</FONT><FONT SIZE=3>C</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的友元，即是说类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的成员函数可以访问类</FONT><FONT SIZE=3>C</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的受保护成员和私有成员，而类</FONT><FONT SIZE=3>A</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的成员函数可以访问类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的受保护成员和私有成员；但是，类</FONT><FONT SIZE=3>A</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的成员函数不可以直接访问类</FONT><FONT SIZE=3>C</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的受保护成员和私有成员，即是说友元关系不存在传递性。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">　</P>
</FONT><FONT FACE="Arial"><P>2.2.7 </FONT><FONT FACE="黑体" LANG="ZH-CN">运算符重载</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">由于</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的函数重载的实现相对比较简单，而且易于理解，因此本章不再讲述</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的函数重载。这里使用一个小节的内容来简单的讲述</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的运算符重载。</P>
<P ALIGN="JUSTIFY">由于类也是一种数据类型，因此很自然的，我们希望能够像使用</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>基本数据类型一样，使用运算符来实现以类作为操作数的运算，如前一节中的例子，对于类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实例对象，我们希望使用下面的这些表达式来直观的进行矩阵的运算：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>A+B+C;</P>
<P>A*B*C;</P>
<P>A-B*C;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">而不是去调用相应的函数。再比如对于字符串</FONT><FONT SIZE=3>a</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和字符串</FONT><FONT SIZE=3>b</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，我们希望使用表达式</FONT><FONT SIZE=3>a+b</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来进行字符串的连接，就象在</FONT><FONT SIZE=3>Visual Basic</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Delphi</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中那样，而不是使用</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言的标准库函数</FONT><FONT SIZE=3>strcat (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>尽管我们所重载的运算符函数内部仍可能是使用</FONT><FONT SIZE=3>strcat</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来实现的</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，因为前一种方法很显然要直观得多。</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>2.3 </FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>允许重载的运算符</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=346>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">运算符</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">名称</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">类型</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">,</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">逗号运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">!</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">逻辑否</FONT><FONT SIZE=1>(NOT)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">一元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">!=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">不等于运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">%</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">取模运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">%</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">取模</FONT><FONT SIZE=1>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>赋值运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">&amp;</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">按位和</FONT><FONT SIZE=1>(AND)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">&amp;</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">取地址运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">一元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">&amp;&amp;</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">逻辑和</FONT><FONT SIZE=1>(AND)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">&amp;=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">按位和</FONT><FONT SIZE=1>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>赋值运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">()</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">函数调用运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">C</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">*</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">乘法运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">*</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">指针间接引用运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">一元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">*=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">乘法</FONT><FONT SIZE=1>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>赋值运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">+</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">加法运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">++</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">递增运算符</FONT><FONT SIZE=1>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>注</FONT><FONT SIZE=1>)</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">一元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">+=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">加法</FONT><FONT SIZE=1>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>赋值运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">-</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">减法运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">-</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">一元负号</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">一元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">--</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">递减运算符</FONT><FONT SIZE=1>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>注</FONT><FONT SIZE=1>)</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">一元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">-=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">减法</FONT><FONT SIZE=1>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>赋值运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="RIGHT">续表</FONT><FONT FACE="Arial" SIZE=1>2.3</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=346>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">运算符</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">名称</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">类型</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">-&gt;</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">成员选择运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">-&gt;*</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">指针成员选择运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">/</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">除法运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">/=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">除法</FONT><FONT SIZE=1>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>赋值运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">&lt;</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">小于运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">&lt;&lt;</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">左移运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">&lt;&lt;=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">左移赋值运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">&lt;=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">小于等于运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">赋值运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">==</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">等于运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">&gt;</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">大于运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">&gt;=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">大于等于运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">&gt;&gt;</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">右移运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">&gt;&gt;=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">右移</FONT><FONT SIZE=1>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>赋值运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">[]</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">数据下标运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">C</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">^</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">异或</FONT><FONT SIZE=1>(Exclusive OR)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">^=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">异或</FONT><FONT SIZE=1>(Exclusive OR)/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>赋值运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">|</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">按位或</FONT><FONT SIZE=1>(Inclusive OR)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT></TD>
</TR>
<TR><TD WIDTH="18%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">|=</FONT></TD>
<TD WIDTH="57%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">按位或</FONT><FONT SIZE=1>(Inclusive OR)/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>赋值运算符</FONT></TD>
<TD WIDTH="25%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">预处理符号</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">运算符的重载是通过对运算符函数的重载来实现的，对于每一个运算符</FONT><FONT SIZE=3>@</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中都对应于一个运算符函数</FONT><FONT SIZE=3>operator@</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，其中的符号“</FONT><FONT SIZE=3>@</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”表示表</FONT><FONT SIZE=3>2.3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中所列出的运算符，例如运算符“</FONT><FONT SIZE=3>+</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”所对应的运算符函数为</FONT><FONT SIZE=3>operator+</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，而数组下标运算符“</FONT><FONT SIZE=3>[]</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”所对应的运算符为</FONT><FONT SIZE=3>operator[]</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。运算符函数的一般原型为：</P>
</FONT><I><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>type</I> operator@(<I>arglist</I>);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">其中</FONT><I><FONT SIZE=3>type</I></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为运算结果的类型，</FONT><I><FONT SIZE=3>arglist</I></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为操作数列表。大多数情况下，运算符函数可以重载为类的成员函数，也可以重载为全局函数。在两种不同情况，同一运算符的重载形式所对应的参数表略有差别。以前面的类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的加法运算符为例，我们将加法运算符函数重载为全局函数，并把它作为类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的友元，以便它可以直接的访问类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的受保护成员，其定义如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>matrix operator+(matrix&amp; A,matrix&amp; B);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的运算将类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实例对象</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>进行相加，然后返回一个类型为</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的运算结果。</P>
<P ALIGN="JUSTIFY">如果上面的运算符函数被重载为类的成员函数，那么它的定义应该是这样的：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>matrix matrix::operator+(matrix&amp; B);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">其中参数</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>代表“</FONT><FONT SIZE=3>+</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”右边的操作数，而“</FONT><FONT SIZE=3>+</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”左边的操作数总是重载该运算符函数的类的一个实例对象或其引用，在成员函数</FONT><FONT SIZE=3>operator+</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的内部，通过隐含的</FONT><FONT SIZE=3>this</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指针来对它进行引用。考虑下面的表达式</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>C=A+B;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">如果运算符函数</FONT><FONT SIZE=3>operator+</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被重载为友元全局函数</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>matrix operator+(matrix&amp; A, matrix&amp; B);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">则上面的表达式被编译器解释为</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>C=operator+(A, B);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">如果</FONT><FONT SIZE=3>operator+</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>被重载为类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>matrix matrix::operator+(matrix&amp; B);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">则该表达式被解释为</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>C=A.operator+(B);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">初看起来，无论把操作符</FONT><FONT SIZE=3>operator+</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>重载为友元全局函数还是成员函数，都可以实现同样的功能。的确，在很多情况下是这样的，但是有些情况下，我们只能选择其中之一。考虑矩阵的数乘运算，我们可能希望使用下面的表达式</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>B=3*A;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">从数学意义上说，上面的表达式将</FONT><FONT SIZE=3>3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>乘以</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的每一个元素，然后将结果赋值给</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。假设</FONT><FONT SIZE=3>operator*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>matrix matrix::operator*(matrix&amp; A);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">即是说我们将</FONT><FONT SIZE=3>operator*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数定义为类的成员函数，这时，编译器如何解释上面的代码呢？下面的解释方法是行不通的：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>B=3.operator*(A);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">因为</FONT><FONT SIZE=3>3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>不是类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的一个实例对象，而且，编译器在这种情况下并不会对左边的操作数作任何类型转换，也就是说，即使你为类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>定义了一个构造函数</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>matrix::matrix(int);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">编译器仍然不会将前面的表达式解释为</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>B=matrix(3).operator*(A);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">因此，将运算符函数定义为类的成员函数是不可能实现我们的要求的，这时，我们需要将函数</FONT><FONT SIZE=3>operator*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>定义为全局函数，并且，将它作为类</FONT><FONT SIZE=3>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的友元，如下所示：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>matrix operator*(int k, matrix&amp; A);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这时，编译器将前面的表达式解释为</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>B=operator*(3, A);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">由于存在合适的函数原型，因此编译器将调用上面所定义的函数</FONT><FONT SIZE=3>operator*</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来进行运算，并将结果赋予</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">上面的叙述容易给人一种感觉，即是说将运算符函数定义为友元函数要比将它们定义为类的成员函数好得多。事实上很多情况下也是这样，然而，并不是所有的函数都能够被定义为友元函数，以下的函数只能被定义为类的成员函数：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">operator=</P>
<P ALIGN="JUSTIFY">operator()</P>
<P ALIGN="JUSTIFY">operator[]</P>
<P ALIGN="JUSTIFY">operator-&gt;</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>函数</FONT><FONT SIZE=3>operator=</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>只能定义为类的成员函数，但是其它的二元重合赋值运算符，如</FONT><FONT FACE="Symbol" SIZE=3>??</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>、</FONT><FONT FACE="Symbol" SIZE=3>??</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>、</FONT><FONT FACE="Symbol" SIZE=3>??</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和</FONT><FONT FACE="Symbol" SIZE=3>??</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>等却不受此限，请看下面的代码：</LI></P>
</FONT><FONT FACE="                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                ZH-CN" SIZE=3><P ALIGN="JUSTIFY">两个函数中</FONT><FONT SIZE=3>C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中是不同的重载形式。</P>
<P ALIGN="JUSTIFY">由编译器自动生成的运算符函数</FONT><FONT SIZE=3>operator</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>所进行的默认操作是将两个对象中的数据进行按成员拷贝，有一点需要强调的是，对于其中的指针成员，拷贝的是指针本身，而不是指针所指向的内容。如果在类中使用了指针成员，这是一个必须注意的问题，一般来说，在这种情况下，我们必须提供自定义的拷贝构造函数和以</FONT><FONT SIZE=3>type&amp;</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>为参数的赋值运算符重载函数，否则很容易引起指针挂起的问题。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P></DIR>
</DIR>

<P ALIGN="JUSTIFY">表</FONT><FONT SIZE=3>2.5</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>总结了不同运算符的重载方法。比较特殊的是递增运算符<FONT FACE="Symbol">&#43;</FONT>
<FONT FACE="Symbol">&#43;</FONT>
和递减运算符<FONT FACE="Symbol">&#45;</FONT>
<FONT FACE="Symbol">&#45;</FONT>
，特殊的原因是它们有两种不同的形式，即前缀形式和后缀形式。如果区别运算符“</FONT><FONT SIZE=3>++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”和“<FONT FACE="Symbol">&#45;</FONT>
<FONT FACE="Symbol">&#45;</FONT>
”的两种不同形式呢？我们为此作如下的约定，对于前缀形式的递增</FONT><FONT SIZE=3>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>递减运算符，以和一般的一元运算符同样的方式将它们重载为</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>type&amp; type::operator++()</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>2.5 </FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>不同运算符的重载方法小结</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=523>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">运算符</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">以友元函数方式进行重载</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">以成员函数方式进行重载</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">一元运算符</FONT><FONT SIZE=1>@</P>
<P ALIGN="JUSTIFY">(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>不包括递增运算符</FONT><FONT SIZE=1>++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>和递减运算符</FONT><FONT FACE="Symbol" SIZE=1>??</FONT><FONT SIZE=1>)</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">type operator@(arg)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">表达式</FONT><FONT SIZE=1>A@</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>或</FONT><FONT SIZE=1>@A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>等价于</FONT><FONT SIZE=1>operator@(A)</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">type operator@()</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">表达式</FONT><FONT SIZE=1>A@</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>或</FONT><FONT SIZE=1>@A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>等价于</FONT><FONT SIZE=1>A.operator@()</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">二元运算符</FONT><FONT SIZE=1>@</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">type operator@(arg1, arg2)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">表达式</FONT><FONT SIZE=1>A@B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>等价于</FONT><FONT SIZE=1>operator@(A, B)</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">type operator@(arg)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">表达式</FONT><FONT SIZE=1>A@B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>等价于</FONT><FONT SIZE=1>A.operator@(B)</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">赋值运算符</FONT><FONT SIZE=1>=</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">C</FONT></TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">type&amp; operator=(arg)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">表达式</FONT><FONT SIZE=1>A=B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>等价于</FONT><FONT SIZE=1>A.operator=(B)</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">函数调用运算符</FONT><FONT SIZE=1>()</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">　</TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">type operator()(arg, ...)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">表达式</FONT><FONT SIZE=1>A(arg, ...)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>等价于</FONT><FONT SIZE=1>A.operator()(arg, ...)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">注意：</P>
</FONT><FONT SIZE=1><P ALIGN="JUSTIFY">1.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>函数调用运算符被当作一个二元运算符，然而函数调用运算符函数的参数表却可以拥有多个参数。</P>
</FONT><FONT SIZE=1><P ALIGN="JUSTIFY">2.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>函数调用运算符作用于一个类的实例对象，而不是一个函数名。</P>
<P ALIGN="JUSTIFY">关于函数调用运算符可以参见前面的类</FONT><FONT SIZE=1>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>的实现。假设</FONT><FONT SIZE=1>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>是类</FONT><FONT SIZE=1>matrix</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>的一个实例对象，则表达式</FONT><FONT SIZE=1>A(1,2)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>返回矩阵</FONT><FONT SIZE=1>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>中第一行第二列的元素。</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">下标运算符</FONT><FONT SIZE=1>[]</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">　</TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">type operator[](arg)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">表达式</FONT><FONT SIZE=1>A[arg]</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>等价于</FONT><FONT SIZE=1>A.operator[](arg)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">注意：</P>
<P ALIGN="JUSTIFY">除了可以为整数以外，下标运算符函数的参数</FONT><FONT SIZE=1>arg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>还可以为任何类型，比如，你可以创建一个以字符串为下标的数据列表。</FONT></TD>
</TR>
<TR><TD WIDTH="24%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">成员函数运算符</FONT><FONT SIZE=1>-&gt;</FONT></TD>
<TD WIDTH="30%" VALIGN="TOP">　</TD>
<TD WIDTH="46%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">type operator-&gt;(arg)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">表达式</FONT><FONT SIZE=1>A-&gt;arg</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>等价于</FONT><FONT SIZE=1>A.operator-&gt;(arg)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">注意：</P>
<P ALIGN="JUSTIFY"><A NAME="xxqqWholeArea">可以重载成员选择运算符</A>“</FONT><FONT SIZE=1>-&gt;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>”，但不可以重载另一个成员选择运算符“</FONT><FONT SIZE=1>.</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>”。</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>type&amp; operator++(type&amp;)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">或</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>type type::operator--()</P>
<P>type operator--(type&amp;)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">要注意的是，如果使用将</FONT><FONT SIZE=3>operator++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>operator--</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>重载为全局友元函数，则参数要使用引用类型，这是因为一般来说，运算符“</FONT><FONT SIZE=3>++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”和“<FONT FACE="Symbol">&#45;</FONT>
<FONT FACE="Symbol">&#45;</FONT>
”都需要修改操作符本身。</P>
<P ALIGN="JUSTIFY">对于后缀形式的递增</FONT><FONT SIZE=3>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>递减运算符，我们约定使用下面的方式来进行重载：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>type&amp; type::operator++(int)</P>
<P>type&amp; operator++(type&amp;, int)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">或</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>type type::operator--(int)</P>
<P>type operator--(type&amp;, int)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">也就是说，我们使用一个额外的整型参数来表明所需调用的是后缀形式的递增</FONT><FONT SIZE=3>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>递减运算符。这样，表达式</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>++A</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">对于编译器等价于</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>A.operator++()</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">或</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>operator++(A)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">而表达式</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>A++</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">对于编译器等价于</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>A.operator++(0)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">或</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>operator++(A, 0)</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">运算符“<FONT FACE="Symbol">&#45;</FONT>
<FONT FACE="Symbol">&#45;</FONT>
”与此类似。</P>
<P ALIGN="JUSTIFY">这样，编译器就能有效的区分前缀形式的递增</FONT><FONT SIZE=3>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>递减运算符和后缀形式的递增</FONT><FONT SIZE=3>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>递减运算符，对于</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>而言，传递给后缀形式的递增</FONT><FONT SIZE=3>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>递减运算符函数的整型参数为</FONT><FONT SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，事实上，我们可以显式的调用后缀形式的递增</FONT><FONT SIZE=3>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>递减运算符函数，如</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>A.operator++(3);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">或</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>operator++(A, 3);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这时，所传递的整型参数可以不是</FONT><FONT SIZE=3>0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，而且，后缀形式的运算符函数</FONT><FONT SIZE=3>operator++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>也的确可以使用这个参数，这时，“</FONT><FONT SIZE=3>++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”运算符看起来有点像一个二元运算符，但是，要记住，后缀形式的运算符函数</FONT><FONT SIZE=3>operator++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>只是一个约定，对于</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来说，无论使用的是前缀形式还是后缀形式，递增</FONT><FONT SIZE=3>/</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>递减运算符都是一个一元运算符，下面的表达式在</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中是通不过的：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>A++3;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">不要想当然的将它解释为</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>A.operator++(3);</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">或</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>operator++(A, 3);</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P></UL>


<UL>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>由表</FONT><FONT SIZE=3>2.3</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>可以知道，用于动态分配内存的运算符</FONT><FONT SIZE=3>new</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>delete</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>也可以被重载，但是，</FONT><FONT SIZE=3>C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>对这两个运算符的默认实现非常之好，而且，由于</FONT><FONT SIZE=3>Win32</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>平台的</FONT><FONT SIZE=3>32</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>位平坦内存管理机制，在系统物理内存不足时会自动使用磁盘交换文件，因此，在绝大多数情况下，我们不需要、也不应该重载</FONT><FONT SIZE=3>new</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>delete</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>运算符，而且，不正确或者说不完善的重载</FONT><FONT SIZE=3>new</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>delete</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>有可能在动态分配内存时带来难以预料的严重后果。也鉴于这个原因，本书中不再讲述重载</FONT><FONT SIZE=3>new</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>delete</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>运算符的细节，若读者在程序中的确需要重载它们的话，请参考</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的联机文档或其它的</FONT><FONT SIZE=3>C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>文献。</LI></P></UL>


<UL>
<P ALIGN="JUSTIFY"><LI>重载运算符时应该遵从惯例，比如说，我们可以重载运算符“</FONT><FONT SIZE=3>+</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>”来连接两个字符串，这是合乎我们的日常思维方式的。同样，</FONT><FONT SIZE=3>C++</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>允许我们使用运算符“<FONT FACE="Symbol">&#45;</FONT>
”来连接两个字符串，但是，这样的重载方式不会给编程带来方便，它们只会混淆程序员的思维，因此是应该避免的。</LI></P></UL>

</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER">第三节</FONT><FONT SIZE=4> </FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>类的继承</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">类的派生</FONT><FONT SIZE=3>(derivation)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和继承</FONT><FONT SIZE=3>(inheritance)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是面向对象程序设计中的一个很重要的概念。通过这种被称作继承的机制，可以从已有的类派生出新的类，新的类包括了已有类的全部接口</FONT><FONT SIZE=3>(interface)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，而且还可以包括特有的新的接口，从而实现我们在</FONT><FONT SIZE=3>2.1.3</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>小节中提出的继承结构。本节讲述使用</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编程语言来实现继承机制的具体的语法细节。</P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，若我们从类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生出新的类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，那么，称类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的基类</FONT><FONT SIZE=3>(base class)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，而类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的派生类</FONT><FONT SIZE=3>(derived class)</P>
</FONT><FONT FACE="Arial"><P>2.3.1 </FONT><FONT FACE="黑体" LANG="ZH-CN">单一派生</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">所谓的单一派生是指一个派生类只能有一个直接基类。什么叫直接基类呢？假设我们从类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生出类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，然后又从类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生出类</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，那么，类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>就是类</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的直接基类，与之相对比，我们称类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>为类</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的间接基类。这一关系可以用图</FONT><FONT SIZE=3>2.5</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>表示。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image250.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image250.gif" WIDTH=89 HEIGHT=140></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>2. 5 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>单一继承结构</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">下面的代码实现了上面的结构：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>class A</P>
<P>{</P>
<P>&#9;// 在此添加类A的实现</P>
<P>&#9;// ...</P>
<P>};</P>

<P>class B:public A</P>
<P>{</P>
<P>&#9;// 在此添加类 B 特有的实现</P>
<P>&#9;// ...</P>
<P>};</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">由上面的代码可以看出，类的单一派生使用如下的语法：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>class <I>class-name</I> : <I>access-specifier base-class</P>
</I><P>{</P>
<P>&#9;// 派生类的新增成员</P>
<P>};</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">其中</FONT><I><FONT SIZE=3>class-name</I></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是派生类的类名，</FONT><I><FONT SIZE=3>access-specifier</I></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指定了基类的继承方式，可以使用的关键字包括</FONT><FONT SIZE=3>public (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如前面的例子所示</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>private</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>protected</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，它们的作用我们将在下面作说明，</FONT><I><FONT SIZE=3>base-class</I></FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是基类的类名。</P>
<P ALIGN="JUSTIFY">同指定类中的成员的访问权限相仿，我们可以使用访问限定关键字指定派生类对基类成员的访问权限。对于使用不同方式</FONT><FONT SIZE=3>(public</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>private</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>protected)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生的类，对于基类中以不同方式</FONT><FONT SIZE=3>(public</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>private</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>protected)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>定义的成员的访问限制是不同的。我们在前面讲述类中成员的访问限制时已在前面的表</FONT><FONT SIZE=3>2.2</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中已经给出了不同派生方式不区别，为了叙述方便，这里将与本节有关的内容重新列于表</FONT><FONT SIZE=3>2.6</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>2. 6 </FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>不同派生方式得到的派生类对基类成员的访问权限</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=499>
<TR><TD WIDTH="31%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">基类成员所使用的关键字</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">在派生类中基类的继承方式</FONT></TD>
<TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">派生类对基类成员访问权限</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP" ROWSPAN=3>
<FONT SIZE=1><P ALIGN="JUSTIFY">public<BR>
(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>公有成员</FONT><FONT SIZE=1>)</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">public</FONT></TD>
<TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">相当于使用了</FONT><FONT SIZE=1>public</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>关键字</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">protected</FONT></TD>
<TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">相当于使用了</FONT><FONT SIZE=1>protected</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>关键字</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">private</FONT></TD>
<TD WIDTH="36%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">相当于使用了</FONT><FONT SIZE=1>private</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>关键字</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP" ROWSPAN=3 HEIGHT=15>
<FONT SIZE=1><P ALIGN="JUSTIFY">protected<BR>
(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>受保护成员</FONT><FONT SIZE=1>)</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP" HEIGHT=15>
<FONT SIZE=1><P ALIGN="JUSTIFY">public</FONT></TD>
<TD WIDTH="36%" VALIGN="TOP" HEIGHT=15>
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">相当于使用了</FONT><FONT SIZE=1>protected</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>关键字</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP" HEIGHT=7>
<FONT SIZE=1><P ALIGN="JUSTIFY">protected</FONT></TD>
<TD WIDTH="36%" VALIGN="TOP" HEIGHT=7>
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">相当于使用了</FONT><FONT SIZE=1>protected</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>关键字</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP" HEIGHT=9>
<FONT SIZE=1><P ALIGN="JUSTIFY">private</FONT></TD>
<TD WIDTH="36%" VALIGN="TOP" HEIGHT=9>
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">相当于使用了</FONT><FONT SIZE=1>private</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>关键字</FONT></TD>
</TR>
<TR><TD WIDTH="31%" VALIGN="TOP" ROWSPAN=3 HEIGHT=14>
<FONT SIZE=1><P ALIGN="JUSTIFY">private<BR>
(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>私有成员</FONT><FONT SIZE=1>)</FONT></TD>
<TD WIDTH="33%" VALIGN="TOP" HEIGHT=14>
<FONT SIZE=1><P ALIGN="JUSTIFY">public</FONT></TD>
<TD WIDTH="36%" VALIGN="TOP" HEIGHT=14>
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">不可访问</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP" HEIGHT=6>
<FONT SIZE=1><P ALIGN="JUSTIFY">protected</FONT></TD>
<TD WIDTH="36%" VALIGN="TOP" HEIGHT=6>
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">不可访问</FONT></TD>
</TR>
<TR><TD WIDTH="33%" VALIGN="TOP" HEIGHT=12>
<FONT SIZE=1><P ALIGN="JUSTIFY">private</FONT></TD>
<TD WIDTH="36%" VALIGN="TOP" HEIGHT=12>
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">不可访问</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">从表</FONT><FONT SIZE=3>2.6</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以看出，无论使用哪种方式生成的派生类，其成员函数都可以访问基类中除了以</FONT><FONT SIZE=3>private</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键进行限定的以外的其它成员。但是，对于以</FONT><FONT SIZE=3>public</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>方式生成的派生类，在基类中使用</FONT><FONT SIZE=3>public</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>protected</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字限定的成员，在派生类中仍相当于使用了</FONT><FONT SIZE=3>public</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>protected</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字；对于以</FONT><FONT SIZE=3>protected</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>方式生成的派生类，在基类中使用</FONT><FONT SIZE=3>public</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>protected</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字限定的成员，在派生类中都相当于使用了</FONT><FONT SIZE=3>protected</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字；而对于以</FONT><FONT SIZE=3>private</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>方式生成的派生类，它们都相当于使用了</FONT><FONT SIZE=3>private</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P></UL>


<UL>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>无论使用的是哪种继承方式，在基类中以</FONT><FONT SIZE=3>private</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>关键字进行限定的成员在派生类中都是不可以访问的，这和以</FONT><FONT SIZE=3>protected</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>关键字定义的成员有着很大的区别，因此，如果希望成员能够为派生类所访问，而同时又不希望被类外部的其它函数直接访问，那么应该使用的访问限定符是</FONT><FONT SIZE=3>protected</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，而不是</FONT><FONT SIZE=3>private</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">　</P>
</FONT><FONT FACE="Arial"><P>2.3.2 </FONT><FONT FACE="黑体" LANG="ZH-CN">多重继承</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">前面说过，当一个派生类只有一个基类时，我们称这种继承方式为单一继承。事实上，在</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，我们还允许一个派生类具有多于一个的基类，这种派生方式被称为多重继承</FONT><FONT SIZE=3>(multiple inheritance)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。多重继承是单一继承的自然扩展，两者既有同一性，又有特殊性。图</FONT><FONT SIZE=3>2.6</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>给出了一个多重继承的示例。在这个示例中，类</FONT><FONT SIZE=3>Software</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>由两个类</FONT><FONT SIZE=3>OperatingSystem</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Application</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生，而类</FONT><FONT SIZE=3>Computer</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>又由类</FONT><FONT SIZE=3>Software</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和另一个类</FONT><FONT SIZE=3>Hardware</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生。</P>
<P ALIGN="JUSTIFY">实现该示例的</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>语言代码如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image251.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image251.gif" WIDTH=400 HEIGHT=159></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>2. 6 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>多重继承结构</P>
<P>#include &lt;string.h&gt;</P>
<P>#include &lt;iostream.h&gt;</P>
<P>#include &lt;iomanip.h&gt;</P>

<P>class OperatingSystem</P>
<P>{</P>
<P>private:</P>
<P>&#9;char OsName[80];</P>
<P>public:</P>
<P>&#9;const char *GetOsName() const</P>
<P>&#9;{</P>
<P>&#9;&#9;return OsName;</P>
<P>&#9;}</P>
<P>&#9;OperatingSystem()</P>
<P>&#9;{</P>
<P>&#9;}</P>
<P>&#9;OperatingSystem(char *OsName)</P>
<P>&#9;{</P>
<P>&#9;&#9;strcpy(OperatingSystem::OsName,OsName);</P>
<P>&#9;}</P>
<P>};</P>

<P>class Application</P>
<P>{</P>
<P>private:</P>
<P>&#9;char *(AppName[80]);</P>
<P>&#9;char n;</P>
<P>public:</P>
<P>&#9;const char *GetAppName(int i) const</P>
<P>&#9;{</P>
<P>&#9;&#9;return AppName[i];</P>
<P>&#9;}</P>
<P>&#9;int AddAppName(char *AppName)</P>
<P>&#9;{</P>
<P>&#9;&#9;char *NewAppName=new char[80];</P>
<P>&#9;&#9;strcpy(NewAppName,AppName);</P>
<P>&#9;&#9;Application::AppName[++n]=NewAppName;</P>
<P>&#9;&#9;return n;</P>
<P>&#9;}</P>
<P>&#9;int GetAppCount()</P>
<P>&#9;{</P>
<P>&#9;&#9;return n;</P>
<P>&#9;}</P>
<P>&#9;Application()</P>
<P>&#9;{</P>
<P>&#9;&#9;n=0;</P>
<P>&#9;}</P>
<P>&#9;~Application()</P>
<P>&#9;{</P>
<P>&#9;&#9;for (int i=1;i&lt;=n;i++)</P>
<P>&#9;&#9;&#9;delete AppName[i];</P>
<P>&#9;}</P>
<P>};</P>

<P>class Software : public OperatingSystem, public Application</P>
<P>{</P>
<P>public:</P>
<P>&#9;Software(char *OsName)</P>
<P>&#9;&#9;: OperatingSystem(OsName),Application()</P>
<P>&#9;{</P>
<P>&#9;}</P>
<P>};</P>

<P>class Hardware</P>
<P>{</P>
<P>private:</P>
<P>&#9;char CpuType[80];</P>
<P>public:</P>
<P>&#9;void SetCpuType(char* CpuType)</P>
<P>&#9;{</P>
<P>&#9;&#9;strcpy(Hardware::CpuType,CpuType);</P>
<P>&#9;}</P>
<P>&#9;char *GetCpuType()</P>
<P>&#9;{</P>
<P>&#9;&#9;return CpuType;</P>
<P>&#9;}</P>
<P>&#9;Hardware()</P>
<P>&#9;{</P>
<P>&#9;}</P>
<P>};</P>

<P>class ComputerSystem : public Hardware, public Software</P>
<P>{</P>
<P>public:</P>
<P>&#9;ComputerSystem(char *CpuType,char *OsName)</P>
<P>&#9;&#9;: Hardware(),Software(OsName)</P>
<P>&#9;{</P>
<P>&#9;&#9;SetCpuType(CpuType);</P>
<P>&#9;}</P>
<P>};</P>

<P>void main()</P>
<P>{</P>
<P>&#9;ComputerSystem MyComputer("AMD K6-200","Windows NT 4.0");</P>
<P>&#9;cout&lt;&lt;"My computer's CPU: "&lt;&lt;MyComputer.GetCpuType()&lt;&lt;endl;</P>
<P>&#9;cout&lt;&lt;"Operating System: "&lt;&lt;MyComputer.GetOsName()&lt;&lt;endl;</P>
<P>&#9;MyComputer.AddAppName("Microsoft Visual C++");</P>
<P>&#9;MyComputer.AddAppName("Microsoft Word 97");</P>
<P>&#9;cout&lt;&lt;MyComputer.GetAppCount()&lt;&lt;" applications:"&lt;&lt;endl;</P>
<P>&#9;for (int i=1;i&lt;=MyComputer.GetAppCount();i++)</P>
<P>&#9;&#9;cout&lt;&lt;"\t"&lt;&lt;MyComputer.GetAppName(i)&lt;&lt;endl;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">声明使用了多重继承结构的类的语法如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>class <I>class-name</I> : <I>access-specifier1 base-class1</I>, <I>access-specifier2 base-class2</I>, ...</P>
<P>{</P>
<P>&#9;// 派生类的新增成员</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">多个直接基类之间以逗号作为分隔符。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P></UL>


<UL>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>在构造类</FONT><FONT SIZE=3>class-name</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的对象时，编译器将按声明类时使用的基类的顺序</FONT><FONT SIZE=3>(</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>即按</FONT><FONT SIZE=3>base-class1</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，</FONT><FONT SIZE=3>base-class2</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，</FONT><FONT SIZE=3>...</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的顺序</FONT><FONT SIZE=3>)</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>依次构造所有直接基类的子对象，然后构造派生类；而在释放类</FONT><FONT SIZE=3>class-name</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的对象恰恰相反。因此，如果类</FONT><FONT SIZE=3>class-name</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的构造不依赖其基类子对象的构造的先后次序，那么我们可以使用任意的顺序来给出类</FONT><FONT SIZE=3>class-name</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的所有直接基类。反之，我们必须考虑在</FONT><FONT SIZE=3>class-name</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的声明中基类的给出顺序。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">我们看到类</FONT><FONT SIZE=3>Software</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的构造函数使用了下面的语法格式：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>Software::Software(char *OsName) : OperatingSystem(OsName),Application()</P>
<P>{</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的定义表明在构造类</FONT><FONT SIZE=3>Software</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的对象之前，先以</FONT><FONT SIZE=3>OsName</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>作为参数构造类型为</FONT><FONT SIZE=3>OperatingSystem</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的子对象，以空参数构造类型为</FONT><FONT SIZE=3>Application</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的子对象，然后再构造类</FONT><FONT SIZE=3>Software</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。类</FONT><FONT SIZE=3>ComputerSystem</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的构造函数也具有类似的结构。</P>
<P ALIGN="JUSTIFY">现在我们来看一种特殊情况，请观察下面的代码：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;iostream.h&gt;</P>
<P>#include &lt;iomanip.h&gt;</P>

<P>class A</P>
<P>{</P>
<P>public:</P>
<P>&#9;int a;</P>
<P>};</P>

<P>class B : public A</P>
<P>{</P>
<P>public:</P>
<P>&#9;void SetA(int i)</P>
<P>&#9;{</P>
<P>&#9;&#9;a=i;</P>
<P>&#9;}</P>
<P>&#9;int GetA()</P>
<P>&#9;{</P>
<P>&#9;&#9;return a;</P>
<P>&#9;}</P>
<P>};</P>

<P>class C : public A</P>
<P>{</P>
<P>public:</P>
<P>&#9;void SetA(int i)</P>
<P>&#9;{</P>
<P>&#9;&#9;a=i;</P>
<P>&#9;}</P>
<P>&#9;int GetA()</P>
<P>&#9;{</P>
<P>&#9;&#9;return a;</P>
<P>&#9;}</P>
<P>};</P>

<P>class D : public B, public C</P>
<P>{</P>
<P>};</P>

<P>void main()</P>
<P>{</P>
<P>&#9;D d;</P>
<P>&#9;d.B::SetA(3);</P>
<P>&#9;d.C::SetA(1);</P>
<P>&#9;cout&lt;&lt;d.B::GetA()&lt;&lt;endl;</P>
<P>&#9;cout&lt;&lt;d.C::GetA()&lt;&lt;endl;</P>
<P>}</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P></UL>


<UL>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>上面的类</FONT><FONT SIZE=3>D</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>可以导致成员名的二义性，这是因为在类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和类</FONT><FONT SIZE=3>C</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中包含了同名成员函数</FONT><FONT SIZE=3>GetA</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>SetA</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>。关于二义性的详细讨论将在本节的后面部分进行。</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">在上面的例子中，类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和类</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>都从类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>派生，而类</FONT><FONT SIZE=3>D</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>从类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和类</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>通过多重继承机制派生。这样，类</FONT><FONT SIZE=3>D</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中就包括了两个不同的类型为</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的子对象，上面的程序的运行结果如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>3</P>
<P>1</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的结果表明，我们分别通过类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和类</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数修改从基类继承的成员</FONT><FONT SIZE=3>a</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的内容时，它们是分别对两个不同的子对象进行的。很自然的想到，如果我们在</FONT><FONT SIZE=3>main</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数中使用如</FONT><FONT SIZE=3>d.a</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>之类的表达式将会导致二义性，因为编译器不知道应该访问的是来自类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员</FONT><FONT SIZE=3>a</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>呢，还是来自类</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员</FONT><FONT SIZE=3>a</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">在很多情况下，我们并不需要两个类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的子对象，这时，可以将</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>声明为虚基类，从而保证在多重派生时，只有一个类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的子对象存在。声明派生类时通过在基类的前面加上</FONT><FONT SIZE=3>virtual</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字可以将一个基类声明为虚基类。为了便于对比，我们给出修改后的代码如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;iostream.h&gt;</P>
<P>#include &lt;iomanip.h&gt;</P>

<P>class A</P>
<P>{</P>
<P>public:</P>
<P>&#9;int a;</P>
<P>};</P>

<P>class B : virtual public A</P>
<P>{</P>
<P>public:</P>
<P>&#9;void SetA(int i)</P>
<P>&#9;{</P>
<P>&#9;&#9;a=i;</P>
<P>&#9;}</P>
<P>&#9;int GetA()</P>
<P>&#9;{</P>
<P>&#9;&#9;return a;</P>
<P>&#9;}</P>
<P>};</P>

<P>class C : virtual public A</P>
<P>{</P>
<P>public:</P>
<P>&#9;void SetA(int i)</P>
<P>&#9;{</P>
<P>&#9;&#9;a=i;</P>
<P>&#9;}</P>
<P>&#9;int GetA()</P>
<P>&#9;{</P>
<P>&#9;&#9;return a;</P>
<P>&#9;}</P>
<P>};</P>

<P>class D : public B, public C</P>
<P>{</P>
<P>};</P>

<P>void main()</P>
<P>{</P>
<P>&#9;D d;</P>
<P>&#9;d.B::SetA(3);</P>
<P>&#9;d.C::SetA(1);</P>
<P>&#9;cout&lt;&lt;d.B::GetA()&lt;&lt;endl;</P>
<P>&#9;cout&lt;&lt;d.C::GetA()&lt;&lt;endl;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的程序的运行结果如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>1</P>
<P>1</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">我们看到，无论是通过类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>还是类</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的子对象来修改成员</FONT><FONT SIZE=3>a</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的值，它们实际上都是对同一个子对象进行操作。这时，如果使用</FONT><FONT SIZE=3>d.a</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的表达式是不会导致二义性的，因为在类</FONT><FONT SIZE=3>D</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实例对象中只存在一个类型</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的子对象。</P>
<P ALIGN="JUSTIFY">相比非虚基类而言，虚基类将占用更小的内存空间，但是，如上所述，所有对于虚基类子对象的操作都是对同一个子对象进行的，这在某些情况下正是我们所不期望的。另外，使用虚基类将会给程序带来额外的开销，虽然就一般情况而言，这种开销对程序的运行效率所产生的影响非常之小。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">由于在使用多重继承时，派生类可以以不同的途径来从基类中继承成员名，因此就有可能出现二义性。如下面的例子：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;iostream.h&gt;</P>
<P>#include &lt;iomanip.h&gt;</P>

<P>class A</P>
<P>{</P>
<P>public:</P>
<P>&#9;int a()</P>
<P>&#9;{</P>
<P>&#9;&#9;return 1;</P>
<P>&#9;}</P>
<P>};</P>

<P>class B</P>
<P>{</P>
<P>public:</P>
<P>&#9;float a()</P>
<P>&#9;{</P>
<P>&#9;&#9;return float(1.2345);</P>
<P>&#9;}</P>
<P>};</P>

<P>class C : public A, public B</P>
<P>{</P>
<P>};</P>

<P>void main()</P>
<P>{</P>
<P>&#9;C c;</P>
<P>&#9;cout&lt;&lt;c.a()&lt;&lt;endl;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">由于在类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中都包括了名为</FONT><FONT SIZE=3>a</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的公有成员函数，而类</FONT><FONT SIZE=3>C</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>由类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>通过多重继承机制派生，这样，如果我们使用了</FONT><FONT SIZE=3>c.a()</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>这样的表达式，编译器无法知道我们想调用的究竟是由类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>继承过来的函数</FONT><FONT SIZE=3>a</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>呢，还是从类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>继承过来的函数</FONT><FONT SIZE=3>a</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这样就导致了二义性。在上面的这种情况下，编译器将生成一个错误。</P>
<P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">然而我们可以使用作用域限定符“</FONT><FONT SIZE=3>::</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”来明确的告诉编译器调用的函数</FONT><FONT SIZE=3>a</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是从类</FONT><FONT SIZE=3>A</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>继承的还是从类</FONT><FONT SIZE=3>B</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>继承的，在前面讲述虚基类时我们已经给出了一个这样的例子。按下面的方法来修改</FONT><FONT SIZE=3>main</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>函数的代码：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>void main()</P>
<P>{</P>
<P>&#9;C c;</P>
<P>&#9;cout&lt;&lt;c.A::a()&lt;&lt;endl;</P>
<P>&#9;cout&lt;&lt;c.B::a()&lt;&lt;endl;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">编译器能够正确的编译上面的代码，而且，程序的运行结果也是完全正确的。然而，尽管可以使用作用域限定符来解决二义性的问题，但是，我们仍然不建议这样做，在使用多重继承机制时，最好还是保证所有的成员都不存在二义性问题。</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P></UL>


<UL>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>下面的代码仍然会导致二义性：</LI></P></UL>


<UL>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>#include &lt;iostream.h&gt;</LI></P>
<P ALIGN="JUSTIFY"><LI>#include &lt;iomanip.h&gt;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI></LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>class A</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>private:</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>int a()</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return 1;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;}</LI></P>
<P ALIGN="JUSTIFY"><LI>}</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI></LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>class B</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>public:</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>float a()</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return float(1.2345);</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;}</LI></P>
<P ALIGN="JUSTIFY"><LI>}</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI></LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>class C : public A, public B</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
<P ALIGN="JUSTIFY"><LI>}</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI></LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>void main()</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>C c;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>cout&lt;&lt;c.a()&lt;&lt;endl;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>}</LI></P></UL>
<DIR>
<DIR>

</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">并不因为在类</FONT><FONT SIZE=3>C</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中无法访问类</FONT><FONT SIZE=3>A</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中的成员函数</FONT><FONT SIZE=3>a (</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>因为该成员函数的访问权限被限定为</FONT><FONT SIZE=3>private)</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>而使得编译器调用从类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>继承的成员函数</FONT><FONT SIZE=3>a</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，编译器在编译上面的代码时仍将给出二义性的错误。</P></DIR>
</DIR>


<UL>
<P ALIGN="JUSTIFY"><LI>下面的代码不会导致二义性：</LI></P></UL>


<UL>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>#include &lt;iostream.h&gt;</LI></P>
<P ALIGN="JUSTIFY"><LI>#include &lt;iomanip.h&gt;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI></LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>class A</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>public:</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>int a()</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return 1;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;}</LI></P>
<P ALIGN="JUSTIFY"><LI>}</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI></LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>class B : virtual public A</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>public:</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>float a()</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>return float(1.2345);</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;}</LI></P>
<P ALIGN="JUSTIFY"><LI>}</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI></LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>class C : virtual public A</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
<P ALIGN="JUSTIFY"><LI>}</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI></LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>class D : public B, public C</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
<P ALIGN="JUSTIFY"><LI>}</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI></LI></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>void main()</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>{</LI></P>
<P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>D d;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>cout&lt;&lt;d.a()&lt;&lt;endl;</LI></P>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY"><LI>}</LI></P></UL>
<DIR>
<DIR>

</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">如果同一个成员名在两个具有继承关系的类中进行了定义，那么，在派生类中所定义的成员名具有支配地位。在出现二义性时，如果存在具有支配地位的成员名，那么编译器将使用这一成员，而不是给出错误信息。以上面的代码为例，在类</FONT><FONT SIZE=3>A</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中都定义了具有相同参数的成员函数</FONT><FONT SIZE=3>a</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，这样，尽管类</FONT><FONT SIZE=3>D</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中可以以两种方式来解释成员函数名</FONT><FONT SIZE=3>a――</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>即来自类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>a</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>和来自类</FONT><FONT SIZE=3>C</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>a</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，但是，按照刚才所说的规则，类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的成员名</FONT><FONT SIZE=3>a</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>相比类</FONT><FONT SIZE=3>A</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的成员名</FONT><FONT SIZE=3>a (</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>即是类</FONT><FONT SIZE=3>C</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>中的成员名</FONT><FONT SIZE=3>a)</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>处于支配地位，这样，编译器将调用类</FONT><FONT SIZE=3>B</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>a</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>，而不产生二义性的错误。</P></DIR>
</DIR>

</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER">第四节</FONT><FONT SIZE=4> </FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>多态与虚函数</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">先考虑下面的代码：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;iostream.h&gt;</P>
<P>#include &lt;iomanip.h&gt;</P>

<P>class Creature</P>
<P>{</P>
<P>public:</P>
<P>&#9;char *KindOf()</P>
<P>&#9;{</P>
<P>&#9;&#9;return "Creature";</P>
<P>&#9;}</P>
<P>};</P>

<P>class Animal : public Creature</P>
<P>{</P>
<P>public:</P>
<P>&#9;char *KindOf()</P>
<P>&#9;{</P>
<P>&#9;&#9;return "Animal";</P>
<P>&#9;}</P>
<P>};</P>

<P>class Fish : public Creature</P>
<P>{</P>
<P>public:</P>
<P>&#9;char *KindOf()</P>
<P>&#9;{</P>
<P>&#9;&#9;return "Fish";</P>
<P>&#9;}</P>
<P>};</P>

<P>void main()</P>
<P>{</P>
<P>&#9;Animal animal;</P>
<P>&#9;Fish fish;</P>
<P>&#9;Creature *pCreature;</P>
<P>&#9;Animal *pAnimal=&amp;animal;</P>
<P>&#9;Fish *pFish=&amp;fish;</P>
<P>&#9;pCreature=pAnimal;</P>
<P>&#9;cout&lt;&lt;"pAnimal-&gt;KindOf(): "&lt;&lt;pAnimal-&gt;KindOf()&lt;&lt;endl;</P>
<P>&#9;cout&lt;&lt;"pCreature-&gt;KindOf(): "&lt;&lt;pCreature-&gt;KindOf()&lt;&lt;endl;</P>
<P>&#9;pCreature=pFish;</P>
<P>&#9;cout&lt;&lt;"pFish-&gt;KindOf(): "&lt;&lt;pFish-&gt;KindOf()&lt;&lt;endl;</P>
<P>&#9;cout&lt;&lt;"pCreature-&gt;KindOf(): "&lt;&lt;pCreature-&gt;KindOf()&lt;&lt;endl;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">程序的输出结果如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>pAnimal-&gt;KindOf(): Animal</P>
<P>pCreature-&gt;KindOf(): Creature</P>
<P>pFish-&gt;KindOf(): Fish</P>
<P>pCreature-&gt;KindOf(): Creature</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">我们看到，无论</FONT><FONT SIZE=3>pCreature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向的对象的类型是什么，使用表达式</FONT><FONT SIZE=3>pCreature-&gt;KindOf()</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>调用的总是在类</FONT><FONT SIZE=3>pCreature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中所定义的成员函数</FONT><FONT SIZE=3>KindOf</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。在这种情况下，我们更希望当</FONT><FONT SIZE=3>pCreature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向类</FONT><FONT SIZE=3>Animal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实例对象，该表达式调用的是类</FONT><FONT SIZE=3>Animal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中定义的成员函数</FONT><FONT SIZE=3>KindOf</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>；而当</FONT><FONT SIZE=3>pCreature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指向类</FONT><FONT SIZE=3>Fish</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的实例对象时，该表达式调用的是类</FONT><FONT SIZE=3>Fish</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中定义的成员函数</FONT><FONT SIZE=3>KindOf</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这也正是面向对象程序中的多态性的要求。</P>
</FONT><FONT FACE="Arial"><P>2.4.1 </FONT><FONT FACE="黑体" LANG="ZH-CN">虚函数</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">以</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中，我们是通过将一个函数定义成虚函数来实现运行时的多态的。如果一个函数被定义为虚函数，那么，即使是使用指向基类对象的指针来调用该成员函数，</FONT><FONT SIZE=3>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>也能保证所调用的是正确的特定于实际对象的成员函数。作为对比，我们使用虚函数的概念重写上面的程序代码如下：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include &lt;iostream.h&gt;</P>
<P>#include &lt;iomanip.h&gt;</P>

<P>class Creature</P>
<P>{</P>
<P>public:</P>
<P>&#9;virtual char *KindOf()</P>
<P>&#9;{</P>
<P>&#9;&#9;return "Creature";</P>
<P>&#9;}</P>
<P>};</P>

<P>class Animal : public Creature</P>
<P>{</P>
<P>public:</P>
<P>&#9;char *KindOf()</P>
<P>&#9;{</P>
<P>&#9;&#9;return "Animal";</P>
<P>&#9;}</P>
<P>};</P>

<P>class Fish : public Creature</P>
<P>{</P>
<P>public:</P>
<P>&#9;char *KindOf()</P>
<P>&#9;{</P>
<P>&#9;&#9;return "Fish";</P>
<P>&#9;}</P>
<P>};</P>

<P>void main()</P>
<P>{</P>
<P>&#9;Animal animal;</P>
<P>&#9;Fish fish;</P>
<P>&#9;Creature *pCreature;</P>
<P>&#9;Animal *pAnimal=&amp;animal;</P>
<P>&#9;Fish *pFish=&amp;fish;</P>
<P>&#9;pCreature=pAnimal;</P>
<P>&#9;cout&lt;&lt;"pAnimal-&gt;KindOf(): "&lt;&lt;pAnimal-&gt;KindOf()&lt;&lt;endl;</P>
<P>&#9;cout&lt;&lt;"pCreature-&gt;KindOf(): "&lt;&lt;pCreature-&gt;KindOf()&lt;&lt;endl;</P>
<P>&#9;pCreature=pFish;</P>
<P>&#9;cout&lt;&lt;"pFish-&gt;KindOf(): "&lt;&lt;pFish-&gt;KindOf()&lt;&lt;endl;</P>
<P>&#9;cout&lt;&lt;"pCreature-&gt;KindOf(): "&lt;&lt;pCreature-&gt;KindOf()&lt;&lt;endl;</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">将一个成员函数声明为虚成员函数的方法是在基类中声明成员函数时使用</FONT><FONT SIZE=3>virtual</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字。一旦一个函数在基类中第一次声明时使用了</FONT><FONT SIZE=3>virtual</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>了关键字，那么，当派生类重载该成员函数是，无论时否使用了</FONT><FONT SIZE=3>virtual</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字，该成员函数都将被看作一个虚函数，也就是说，虚函数的重载函数仍是虚函数。</P>
</FONT><FONT FACE="Arial"><P>2.4.2 </FONT><FONT FACE="黑体" LANG="ZH-CN">纯虚函数与抽象类</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">一个虚函数可以被声明为纯虚函数，方法是在函数的声明之后使用纯虚函数标识符“</FONT><FONT SIZE=3>=0</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>”，下面的代码在类</FONT><FONT SIZE=3>Creature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中将虚函数</FONT><FONT SIZE=3>KindOf</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>声明为纯虚函数：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>class Creature</P>
<P>{</P>
<P>public:</P>
<P>&#9;virtual char *KindOf()=0;</P>
<P>};</P>

<P>char *Creature::KindOf()</P>
<P>{</P>
<P>&#9;return "Creature";</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">使用下面的格式也是可以的：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>class Creature</P>
<P>{</P>
<P>public:</P>
<P>&#9;virtual char *KindOf()=0</P>
<P>&#9;{</P>
<P>&#9;&#9;return "Creature";</P>
<P>&#9;}</P>
<P>};</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">两种不同格式之间的区别已以本章的前面作了说明。</P>
<P ALIGN="JUSTIFY">包括了至少一个纯虚函数的类被看作抽象类，一个抽象类不可以用来创建对象，这只能用来为派生类提供了一个接口规范，派生类中必须重载基类中的纯虚函数，否则它仍将被看作一个抽象类。</P>
<P ALIGN="JUSTIFY">如果要直接调用抽象类中定义的纯虚函数，必须使用完全限定名，如上面的示例，要想直接调用抽象类</FONT><FONT SIZE=3>Creature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中定义的纯虚函数，应该使用下面的格式：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>cout&lt;&lt;pCreature-&gt;Creature::KindOf()&lt;&lt;endl;</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">上面的代码同时还给出了一种绕过虚函数机制的方法，即使用带有作用域限定符的完全限定函数名。</P>
<P ALIGN="JUSTIFY">抽象类具有下面的一些限制：</P>

<UL>
<P ALIGN="JUSTIFY"><LI>不可以用来创建对象</LI></P>
<P ALIGN="JUSTIFY"><LI>不可以作为函数返回值的类型</LI></P>
<P ALIGN="JUSTIFY"><LI>不可以作为函数参数的类型</LI></P>
<P ALIGN="JUSTIFY"><LI>不可以用来进行显式类型转换</LI></P></UL>

<P ALIGN="JUSTIFY">而且，如果在抽象类的构造函数中调用了纯虚函数，那么，其结果是不确定的。还有，由于抽象类的析构函数可以被声明为纯虚函数，这时，我们应该至少提供该析构函数的一个实现。一个很好的实现方式是的抽象类中提供一个默认的析构函数，该析构函数保证至少有析构函数的一个实现存在。如下面的例子所示：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>class classname</P>
<P>{</P>
<P>&#9;// 其它成员</P>
<P>public:</P>
<P>&#9;~classname()=0</P>
<P>&#9;{</P>
<P>&#9;&#9;// 在此添加析构函数的代码</P>
<P>&#9;}</P>
<P>};</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">由于派生类的析构函数不可能和抽象类的析构函数同名，因此，提供一个默认的析构函数的实现是完全必要的。这也是纯虚析构函数和其它纯虚成员函数的一个最大的不同之处。一般情况下，抽象类的析构函数是有派生类的实现对象释放时由派生类的析构函数隐含的所调用的。</P>
</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4><P ALIGN="CENTER">第五节</FONT><FONT SIZE=4> ClassView</FONT><FONT FACE="仿宋_GB2312" LANG="ZH-CN" SIZE=4>和</FONT><FONT SIZE=4>WizardBar</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT SIZE=3>Microsoft Developer Studio</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中提供了几个工具来使用得创建和组织类非常的方便。这些工具包括</FONT><FONT SIZE=3>ClassView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。其中</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>只能用于基于</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序，因此我们将在以后的部分中讲述它的使用，在本节中，只涉及了</FONT><FONT SIZE=3>ClassView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的部分内容。</P>
</FONT><FONT FACE="Arial"><P>2.5.1 </FONT><FONT FACE="黑体" LANG="ZH-CN">使用</FONT><FONT FACE="Arial">ClassView</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">使用</FONT><FONT SIZE=3>ClassView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>可以完成以下工作：</P>

<UL>
<P ALIGN="JUSTIFY"><LI>向工程中添加新类</LI></P>
<P ALIGN="JUSTIFY"><LI>向类中添加成员函数和成员变量</LI></P>
<P ALIGN="JUSTIFY"><LI>重载基类中的虚函数</LI></P>
<P ALIGN="JUSTIFY"><LI>添加消息处理程序</LI></P>
<P ALIGN="JUSTIFY"><LI>跳转到类或成员的定义</LI></P>
<P ALIGN="JUSTIFY"><LI>跳转到类或成员的引用</LI></P>
<P ALIGN="JUSTIFY"><LI>显示派生类或基类的图形</LI></P>
<P ALIGN="JUSTIFY"><LI>将类添加到</FONT><FONT SIZE=3>Gallery</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中以便以后重用</LI></P>
<P ALIGN="JUSTIFY"><LI>在成员函数中设置断点</LI></P>
<P ALIGN="JUSTIFY"><LI>使用访问类型组织类的成员</LI></P>
<P ALIGN="JUSTIFY"><LI>向</FONT><FONT SIZE=3>COM</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>接口中添加属性和方法</LI></P>
<P ALIGN="JUSTIFY"><LI>向</FONT><FONT SIZE=3>ActiveX</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>控件添加事件</LI></P>
<P ALIGN="JUSTIFY"><LI>在工程空间中创建新的文件夹</LI></P>
<P ALIGN="JUSTIFY"><LI>察看类及其成员的属性</LI></P></UL>

</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image252.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image252.gif" WIDTH=185 HEIGHT=198></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>2. 7 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>工程</FONT><FONT SIZE=1>ClassViewDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>的</FONT><FONT SIZE=1>ClassView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>窗格</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image253.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image253.gif" WIDTH=348 HEIGHT=312></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>2.8 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>新建类的对话框</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">为了进行下面的示例，首先创建一个空的</FONT><FONT SIZE=3>Win32 Console Application</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>工程，这里，我们假定工程名为</FONT><FONT SIZE=3>ClassViewDemo</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，当然，你也可以使用其它的工程名。</P>
<P ALIGN="JUSTIFY">在</FONT><FONT SIZE=3>Workspace</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>窗口中打开</FONT><FONT SIZE=3>ClassView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>窗格，如图</FONT><FONT SIZE=3>2.7</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示。下面我们使用</FONT><FONT SIZE=3>ClassView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>向工程中添加一个类</FONT><FONT SIZE=3>Creature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。方法如下：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">1.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>右击</FONT><FONT SIZE=3>ClassViewDemo classes</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>节点，选择</FONT><FONT SIZE=3>New Class</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>命令，出现如图</FONT><FONT SIZE=3>2.8</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的对话框。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">2.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT SIZE=3>Name</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处输入新的类名，确认在</FONT><FONT SIZE=3>Class Type</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中选择了</FONT><FONT SIZE=3>Generic Class</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，对于</FONT><FONT SIZE=3>Win32 Console Application</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，这也是唯一可用的选项。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">3.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>如果需要，可以在下面的</FONT><FONT SIZE=3>Base class(es)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中选择类</FONT><FONT SIZE=3>Creature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的基类和继承方式。这里，我们不需要为类</FONT><FONT SIZE=3>Creature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>指定基类。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">4.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>单击</FONT><FONT SIZE=3>File name</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处的</FONT><FONT SIZE=3>Change</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>按钮改变类的头文件和实现文件为</FONT><FONT SIZE=3>creature.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>creature.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">5.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>最后，单击</FONT><FONT SIZE=3>OK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>完成。</P>
<P ALIGN="JUSTIFY">这时，</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>自动生成了下面的两个文件：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">creature.h:</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>// creature.h: interface for the Creature class.</P>
<P>//</P>
<P>//////////////////////////////////////////////////////////////////////</P>

<P>#if !defined(AFX_CREATURE_H__90147538_FA97_11D1_BBF0_0000B4810A31__INCLUDED_)</P>
<P>#define AFX_CREATURE_H__90147538_FA97_11D1_BBF0_0000B4810A31__INCLUDED_</P>

<P>#if _MSC_VER &gt;= 1000</P>
<P>#pragma once</P>
<P>#endif // _MSC_VER &gt;= 1000</P>

<P>class Creature  </P>
<P>{</P>
<P>public:</P>
<P>&#9;Creature();</P>
<P>&#9;virtual ~Creature();</P>

<P>};</P>

<P>#endif // !defined(AFX_CREATURE_H__90147538_FA97_11D1_BBF0_0000B4810A31__INCLUDED_)</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">creature.cpp:</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>// creature.cpp: implementation of the Creature class.</P>
<P>//</P>
<P>//////////////////////////////////////////////////////////////////////</P>

<P>#include ""</P>
<P>#include "creature.h"</P>

<P>//////////////////////////////////////////////////////////////////////</P>
<P>// Construction/Destruction</P>
<P>//////////////////////////////////////////////////////////////////////</P>

<P>Creature::Creature()</P>
<P>{</P>

<P>}</P>

<P>Creature::~Creature()</P>
<P>{</P>

<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">这里，我们需要删掉</FONT><FONT SIZE=3>creature.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>文件中的</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include ""</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">一行。</P>
<P ALIGN="JUSTIFY">在上面的过程中，还自动生成的类</FONT><FONT SIZE=3>Creature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的构造函数和析构函数的框架，并且，其析构函数还被声明为虚函数。</P>
<P ALIGN="JUSTIFY">下面的步骤添加类</FONT><FONT SIZE=3>Creature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的成员函数</FONT><FONT SIZE=3>KindOf</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">1.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT SIZE=3>ClassView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中右击类</FONT><FONT SIZE=3>Creature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，选择</FONT><FONT SIZE=3>Add Member Function</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，弹出如图所示的对话框。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image254.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image254.gif" WIDTH=315 HEIGHT=156></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>2.9 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>添加成员函数</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">2.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT SIZE=3>Function Type</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处输入</FONT><FONT SIZE=3>char *</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。然后在对话框下方选择</FONT><FONT SIZE=3>Virtual</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>复选框，这导致</FONT><FONT SIZE=3>Static</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>复选框不可用，因为同一个成员函数不可能既是虚函数，又是静态函数，这时，在</FONT><FONT SIZE=3>Function Declaration</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处自动添加上了</FONT><FONT SIZE=3>virtual</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关键字。确认在</FONT><FONT SIZE=3>Access</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处选择了</FONT><FONT SIZE=3>Public</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，然后，在</FONT><FONT SIZE=3>Function Declaration</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处输入函数名</FONT><FONT SIZE=3>KindOf</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，单击</FONT><FONT SIZE=3>OK</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>完成。</P>
<P ALIGN="JUSTIFY">双击</FONT><FONT SIZE=3>ClassView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的</FONT><FONT SIZE=3>KindOf</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，</FONT><FONT SIZE=3>Microsoft Developer Studio</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>将打开文件</FONT><FONT SIZE=3>creature.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，将将插入点定位到函数</FONT><FONT SIZE=3>KindOf</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的定义处。在此添加下面的代码：</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>char* Creature::KindOf()</P>
<P>{</P>
<P>&#9;return "Creature";</P>
<P>}</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">下面以类似的方式生成类</FONT><FONT SIZE=3>Animal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，使其基类为</FONT><FONT SIZE=3>Creature</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，继承方式为</FONT><FONT SIZE=3>public</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。并将其头文件改为</FONT><FONT SIZE=3>animal.h</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，实现文件改为</FONT><FONT SIZE=3>animal.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。同样，在</FONT><FONT SIZE=3>animal.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中删除</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P>#include ""</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">一行。</P>
<P ALIGN="JUSTIFY">对于</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序，还可以使用</FONT><FONT SIZE=3>ClassView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来重载基类中的虚函数，这将在本书后面的章节中讲述。而对于非</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>应用程序，我们仍可以使用上面的添加成员函数的方法来重载基类中的虚函数，只不过这时必须手动的给出虚函数的返回类型和参数列表。</P>
<P ALIGN="JUSTIFY">使用上面的方法来生成为</FONT><FONT SIZE=3>Animal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的重载虚函数</FONT><FONT SIZE=3>KindOf</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，其代码已在上一节中给出。</P>
<P ALIGN="JUSTIFY">然后再新添加一个</FONT><FONT SIZE=3>C++ Source File――main.cpp</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，并在其中定义程序的主函数</FONT><FONT SIZE=3>main()</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">由于我们目前还没有接确到</FONT><FONT SIZE=3>MFC</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>编程，因此，现在还不能讲解</FONT><FONT SIZE=3>ClassView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的某此用法。在本书后面的章节中，我们将会在用到这些功能的时候讲解它们。</P>
</FONT><FONT FACE="Arial"><P>2.5.2 </FONT><FONT FACE="黑体" LANG="ZH-CN">使用</FONT><FONT FACE="Arial">WizardBar</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是</FONT><FONT SIZE=3>Microsoft Developer Studio</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的一个工具条，如图</FONT><FONT SIZE=3>2.10</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示。它提供了对</FONT><FONT SIZE=3>ClassView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>ClassWizard (</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>关于</FONT><FONT SIZE=3>ClassWizard</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的使用将在后面的章节中讲述</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的命令的快速访问。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image255.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image255.gif" WIDTH=389 HEIGHT=18></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>2.10 WizardBar</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>工具条中的显示的内容是与当前上下文相关联的，也就是说，随着当前上下文的改变，</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的显示也会改变。图</FONT><FONT SIZE=3>2.10</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>是在</FONT><FONT SIZE=3>ClassView</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中双击类</FONT><FONT SIZE=3>Animal</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的构造函数之后的</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
<P ALIGN="JUSTIFY">可以使用</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>来完成下面的这些操作：</P>

<UL>
<P ALIGN="JUSTIFY"><LI>跳转到函数的定义</FONT><FONT SIZE=3>(</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>实现</FONT><FONT SIZE=3>)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处</LI></P>
<P ALIGN="JUSTIFY"><LI>跳转到函数的声明处</LI></P>
<P ALIGN="JUSTIFY"><LI>跳转到类的定义处</LI></P>
<P ALIGN="JUSTIFY"><LI>添加窗口消息处理函数</LI></P>
<P ALIGN="JUSTIFY"><LI>添加虚函数</LI></P>
<P ALIGN="JUSTIFY"><LI>添加成员函数</LI></P>
<P ALIGN="JUSTIFY"><LI>添加新类</LI></P>
<P ALIGN="JUSTIFY"><LI>跳转到文件中的下一个函数</LI></P>
<P ALIGN="JUSTIFY"><LI>跳转到文件中的前一个函数</LI></P>
<P ALIGN="JUSTIFY"><LI>打开包含文件</LI></P>
<P ALIGN="JUSTIFY"><LI>获得关于</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的帮助</LI></P></UL>

</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中最左边的下拉列表框被称作类列表</FONT><FONT SIZE=3>(Class List)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，它列举了当前工程中所有可用的类；中间的下拉列表框被称作过滤器和成员列表</FONT><FONT SIZE=3>(Filter</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>和</FONT><FONT SIZE=3>Member List)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，对于</FONT><FONT SIZE=3>Visual C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>工程，可以通过过滤器和成员列表指定在</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中列出的内容，即是列出所有的类成员，还是与特定的资源</FONT><FONT SIZE=3>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>相关联的成员；最右边的部分被称作</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>行为控件，包括两个部分，一个按钮和位于按钮右边的下箭头。单击下箭头可以出现如图</FONT><FONT SIZE=3>2.11</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示的下拉菜单，菜单中各项的意义非常之直观，这里不再赘述。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image256.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image256.gif" WIDTH=146 HEIGHT=94></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>2. 11 WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>行为菜单</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY">注意在图</FONT><FONT SIZE=3>2.11</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中被以粗体显示的菜单项，这些项被称为</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>默认行为。在以下几种情况下，</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的默认行为被执行：</P>

<UL>
<P ALIGN="JUSTIFY"><LI>单击了下箭头左边的图标按钮</LI></P>
<P ALIGN="JUSTIFY"><LI>在</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的下拉列表中按下了回车键</LI></P>
<P ALIGN="JUSTIFY"><LI>在对话框编辑器中双击了某个控件</LI></P></UL>

<P ALIGN="JUSTIFY">当不同的</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>的下拉列表框获得输入焦点时，</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>采取不同的默认行为，如表所示。</P>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">表</FONT><FONT FACE="Arial" SIZE=1>2. 7 </FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>不同的下拉列表框具有输入焦点时</FONT><FONT FACE="Arial" SIZE=1>WizardBar</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=1>的不同默认行为</P></FONT>
<P ALIGN="CENTER"><CENTER><TABLE BORDER CELLSPACING=2 BORDERCOLOR="#808080" CELLPADDING=7 WIDTH=535>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">获得输入焦点的下拉列表框</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT SIZE=1><P ALIGN="JUSTIFY">WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>采用的默认行为</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">类列表</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">跳转到选定的类中以字母排序的第一个成员。如果类中没有实现任何函数和方法，则弹出一个对话框为类创建新的成员函数和方法。对于</FONT><FONT SIZE=1>C++</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>全局类</FONT><FONT SIZE=1>(global classes)</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>，该对话框提示创建新的类。</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">过滤器和成员列表</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">如果位于一个资源</FONT><FONT SIZE=1>ID</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>上，默认行为为跳转到以字母排序的第一个消息的处理函数处。如果没有创建任何消息处理函数，则弹出一个对话框以创建新的消息处理函数。</FONT></TD>
</TR>
<TR><TD WIDTH="32%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">成员列表</FONT></TD>
<TD WIDTH="68%" VALIGN="TOP">
<FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="JUSTIFY">默认行为为跳转到选定的成员的定义处。</FONT></TD>
</TR>
</TABLE>
</CENTER></P>

<FONT FACE="宋体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"></P>
<P ALIGN="JUSTIFY">为了更快的访问</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>提供的功能，可以为</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>类列表、过滤器列表、成员列表和行为按钮设置快捷键，当按下所设置的快捷键时，</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>中的相应元素获得输入焦点；也可以为在下拉列表中给出的其它</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>行为设置相应的快捷键，当这些快捷键被按下时，相应的行为将被执行。为</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>设置快捷键的方法如下：</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">1.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>选择</FONT><FONT SIZE=3>Tools</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>菜单下的</FONT><FONT SIZE=3>Customize</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>命令，打开如图</FONT><FONT SIZE=3>2.12</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>所示的对话框。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">2.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>在</FONT><FONT SIZE=3>Category</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>下拉列表框中选择</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。然后，在</FONT><FONT SIZE=3>Commands</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>列表框中选择需要设置快捷键的命令。这时，在</FONT><FONT SIZE=3>Description</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>处就会出现该命令的相应的简单的英文解释，因此，我们这里无需再对全部的命令给出详细的说明，其中对应于</FONT><FONT SIZE=3>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>类列表、过滤器列表、成员列表和行为按钮的命令分别为</FONT><FONT SIZE=3>WBActionButtonActive</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>WBClassComboActive</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>WBFilterComboActive</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>WBMemberComboActive</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>。</P>
</FONT><FONT SIZE=3><P ALIGN="JUSTIFY">3.&#9;</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>然后单击</FONT><FONT SIZE=3>Press new shortcut</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>，并按下新的快捷键，如果新的快捷键可用，则它将出现在</FONT><FONT SIZE=3>Press new shortcut</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>文本框中，单击</FONT><FONT SIZE=3>Assign</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=3>按钮，即可将新的快捷键与指定的命令相关联。</P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER"><IMG SRC="Image257.gif" tppabs="http://166.111.167.223/computer/cai/visual_c++_5.0_programming/Image257.gif" WIDTH=377 HEIGHT=234></P>
</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1><P ALIGN="CENTER">图</FONT><FONT SIZE=1>2. 12 </FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>为</FONT><FONT SIZE=1>WizardBar</FONT><FONT FACE="宋体" LANG="ZH-CN" SIZE=1>设置快捷键</P>

<UL>
</FONT><FONT FACE="黑体" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>注意：</LI></P></UL>


<UL>
</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3><P ALIGN="JUSTIFY"><LI>不可以使用那些已被系统保留的快捷键，如</FONT><FONT SIZE=3>ESC</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>F1</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>、</FONT><FONT SIZE=3>Ctrl+Alt+Del</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>等。</LI></P></UL>


<UL>
<P ALIGN="JUSTIFY"><LI>如果所设置的快捷键已被其它命令使用，则在</FONT><FONT SIZE=3>Press new shortcut</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>下方的</FONT><FONT SIZE=3>Currently assigned to</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>处将给出与该快捷键相关联的当前命令，如果这时按下</FONT><FONT SIZE=3>Assign</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>按钮，则该快捷键将与新设定的命令相关联，与原命令的关联将自动失效。单击</FONT><FONT SIZE=3>Reset All</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>可以恢复</FONT><FONT SIZE=3>Microsoft Developer Studio</FONT><FONT FACE="楷体_GB2312" LANG="ZH-CN" SIZE=3>原有的默认设置。</LI></P></UL>
</FONT></BODY>
</HTML>
