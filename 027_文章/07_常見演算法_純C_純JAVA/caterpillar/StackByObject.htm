<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>






  
  
  
  
  
  
  <link rel="stylesheet" href="stdlayout.css" tppabs="http://caterpillar.onlyfun.net/Gossip/AlgorithmGossip/css/stdlayout.css" type="text/css">






  
  
  
  
  
  
  <link rel="stylesheet" href="print.css" tppabs="http://caterpillar.onlyfun.net/Gossip/AlgorithmGossip/css/print.css" type="text/css">






  
  
  
  
  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type">






  
  
  
  
  
  
  <title>堆疊 - 使用 Java 作物件封裝</title>
</head>


<body>






<h3><a href="javascript:if(confirm('http://caterpillar.onlyfun.net/Gossip/index.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://caterpillar.onlyfun.net/Gossip/index.html'" tppabs="http://caterpillar.onlyfun.net/Gossip/index.html">From
Gossip@caterpillar</a></h3>






<h1><a href="AlgorithmGossip.htm" tppabs="http://caterpillar.onlyfun.net/Gossip/AlgorithmGossip/AlgorithmGossip.htm">Algorithm Gossip:&nbsp;堆疊 - 使用 Java 作物件封裝</a></h1>

<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">

  <tbody>

    <tr>

      <td style="width: 676px; vertical-align: top;"> 





      <h2>說明</h2>
      <small>

如果您使用C++或Java等支援物件導向的語言來實作堆疊，您可以使用類別的方式來包括堆疊的功能，將所有的堆疊操作由堆疊物件來處理，一旦包裝完成，則使用堆疊物件的時候，只要呼叫加入、刪除等方法，而無需處理堆疊的top或判斷是否為空等細節。</small><br>


      <h2>解法</h2>
      <small>

使用C++與使用Java來作類別包裝其實是類似的，在這邊我們使用Java實作，因為它的語法看來較簡潔；Java雖然沒有指標，但可以使用參考（Reference）來達到鏈結的效果，一個節點的類別包裝方式如下：<br>
      </small>

      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">class Node { </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private int data;&nbsp;&nbsp; // 節點資料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private Node next;&nbsp; // 下一個節點位置 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void setData(int data);&nbsp; // 節點資料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void setNext(Node next);&nbsp; // 下一個節點位置 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public int getData();&nbsp; // 傳回節點資料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public Node getNext();&nbsp; // 傳回下一個節點位置 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">}</span><br>


      </small></div>
      <small>

&nbsp;<br>


其中next是個物件參考名稱，它可以用來參考至（指向）下一個節點物件的記憶體位置，而堆疊類別可以如下包裝：<br>
      </small>

      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">class Stack { </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private Node top;&nbsp;&nbsp;&nbsp; // 堆疊頂端 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; private String name;&nbsp; // 只是個名稱 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 利用建構子建立堆疊 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public Stack(); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public Stack(String name); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 插入資料至頂端 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void add(int data); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 傳回頂端資料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public int printTop(); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 刪除頂端資料 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void del(); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; // 列出堆疊內容 </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp; public void list(); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">


      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">}</span><br>


      </small></div>
      <small>

&nbsp;<br>


利用物件導向來包裝資料結構，雖然在設計時需要花較多的心思，但設計完成之後，日後呼叫使用就簡單了，以後您只要注意主程式的邏輯設計就可以了。</small><br>



      <br>


      <h2> 實作</h2>



      <ul>
        <li> Java
  </li>
      </ul>



      <pre>import java.io.*; <br><br>// 節點 <br>class Node { <br>    private int data;   // 節點資料 <br>    private Node next;  // 下一個節點位置 <br><br>    public void setData(int data) {  // 節點資料 <br>        this.data = data; <br>    } <br><br>    public void setNext(Node next) {  // 下一個節點位置 <br>        this.next = next; <br>    } <br><br>    public int getData() {  // 傳回節點資料 <br>        return data; <br>    } <br><br>    public Node getNext() {  // 傳回下一個節點位置 <br>        return next; <br>    } <br>} <br><br>// 堆疊 <br>class Stack { <br>    private Node top; <br>    private String name;  // 只是個名稱 <br><br>    public Stack() { <br>        this("list"); <br>    } <br><br>    // 利用建構子建立堆疊 <br>    public Stack(String name) { <br>        this.name = name; <br>        top = null; <br>    } <br><br>    // 插入資料至頂端 <br>    public void add(int data) { <br>        Node newNode = new Node(); <br>        newNode.setData(data); <br>        newNode.setNext(top); <br>        top = newNode; <br>    } <br><br>    // 傳回頂端資料 <br>    public int printTop() { <br>        return top.getData(); <br>    } <br><br>    // 刪除頂端資料 <br>    public void del() { <br>        Node tmpNode; <br>        tmpNode = top; <br><br>        if(tmpNode == null) { <br>            System.out.println("\n堆疊已空！"); <br>            return; <br>        } <br><br>        top = top.getNext(); <br>        tmpNode = null; <br>    } <br><br>    // 列出堆疊內容 <br>    public void list() { <br>        Node tmpNode; <br>        tmpNode = top; <br><br>        System.out.print("\n堆疊內容："); <br>        while(tmpNode != null) { <br>            System.out.print(tmpNode.getData() + " "); <br>            tmpNode = tmpNode.getNext(); <br>        } <br>    } <br>} <br><br>public class StackShow { <br>    public static void main(String[] args) <br>                                  throws IOException { <br>        int input, select; <br>        BufferedReader buf; <br>        buf = new BufferedReader(<br>                       new InputStreamReader(System.in)); <br><br>        Stack s1 = new Stack("堆疊測試"); <br><br>        while(true) {  <br>            System.out.print("\n\n請輸入選項(-1結束)："); <br>            System.out.print("\n(1)插入值至堆疊"); <br>            System.out.print("\n(2)顯示堆疊頂端"); <br>            System.out.print("\n(3)刪除頂端值"); <br>            System.out.print("\n(4)顯示所有內容"); <br>            System.out.print("\n$c&gt;"); <br><br>            select = Integer.parseInt(buf.readLine()); <br><br>            if(select == -1) <br>                break; <br><br>            switch(select) { <br>                case 1: <br>                    System.out.print("\n輸入值："); <br>                    input = Integer.parseInt(buf.readLine()); <br>                    s1.add(input); <br>                    break; <br>                case 2: <br>                    System.out.print("\n頂端值：" +  <br>                                             s1.printTop()); <br>                    break; <br>                case 3: <br>                    s1.del(); <br>                    break; <br>                case 4: <br>                    s1.list(); <br>                    break; <br>                default: <br>                    System.out.print("\n選項錯誤！"); <br>            } <br>        } <br><br>        System.out.println(""); <br>    } <br>}</pre>

 </td>

      <td style="width: 250px; text-align: center; vertical-align: top;">
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <br>

      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js">
      </script></td>

    </tr>

  </tbody>
</table>

<br>






</body>
</html>
