<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>





  
  
  
  
  
  <link rel="stylesheet" href="stdlayout.css" tppabs="http://caterpillar.onlyfun.net/Gossip/AlgorithmGossip/css/stdlayout.css" type="text/css">





  
  
  
  
  
  <link rel="stylesheet" href="print.css" tppabs="http://caterpillar.onlyfun.net/Gossip/AlgorithmGossip/css/print.css" type="text/css">





  
  
  
  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type">





  
  
  
  
  
  <title>選擇、插入、氣泡排序</title>
</head>


<body>





<h3><a href="javascript:if(confirm('http://caterpillar.onlyfun.net/Gossip/index.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://caterpillar.onlyfun.net/Gossip/index.html'" tppabs="http://caterpillar.onlyfun.net/Gossip/index.html">From
Gossip@caterpillar</a></h3>





<h1><a href="AlgorithmGossip.htm" tppabs="http://caterpillar.onlyfun.net/Gossip/AlgorithmGossip/AlgorithmGossip.htm">Algorithm Gossip:&nbsp;選擇、插入、氣泡排序</a></h1>

<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">

  <tbody>

    <tr>

      <td style="width: 676px; vertical-align: top;"> 




      <h2>說明</h2>
      <small>
選擇排序（Selection sort）、插入排序（Insertion sort）與氣泡排序（Bubble sort）這三個排序方式是初學排序所必須知道的三個基本排序方式，它們由於速度不快而不實用（平均與最快的時間複雜度都是O(n<sup>2</sup>)），然而它們排序的方式確是值得觀察與探討的。</small><br>

      <h2>解法</h2>

      <ul>
        <li><small>選擇排序</small></li>
      </ul>

      <div style="margin-left: 40px;"><small>將要排序的對象分作兩部份，一個是已排序的，一個是未排序的，從後端未排序部份選擇一個最小值，並放入前端已排序部份的最後一個，例如：<br>

      </small></div>

      <small><br>
      </small>
      <div style="margin-left: 40px;"><small>排序前：70 80 31 37 10 1 48 60 33 80<br>

      <br>

      </small>
      <ol>
        <li><small>[1] 80 31 37 10 70 48 60 33 80 選出最小值1</small></li>
        <li><small>[1 10] 31 37 80 70 48 60 33 80 選出最小值10</small></li>
        <li><small>[1 10 31] 37 80 70 48 60 33 80 選出最小值31</small></li>
        <li><small>[1 10 31 33] 80 70 48 60 37 80 ......</small></li>
        <li><small>[1 10 31 33 37] 70 48 60 80 80 ......</small></li>
        <li><small>[1 10 31 33 37 48] 70 60 80 80 ......</small></li>
        <li><small>[1 10 31 33 37 48 60] 70 80 80 ......</small></li>
        <li><small>[1 10 31 33 37 48 60 70] 80 80 ......</small></li>
        <li><small>[1 10 31 33 37 48 60 70 80] 80 ......</small></li>
      </ol>
      <small>
      </small></div>

      <small><br>
      </small>
      <ul>
        <li><small>插入排序</small></li>
      </ul>

      <div style="margin-left: 40px;"><small>像是玩樸克一樣，我們將牌分作兩堆，每次從後面一堆的牌抽出最前端的牌，然後插入前面一堆牌的適當位置，例如：<br>

      </small></div>

      <small><br>
      </small>
      <div style="margin-left: 40px;"><small>排序前：92 77 67 8 6 84 55 85 43 67<br>

      <br>

      </small>
      <ol>
        <li><small>[77 92] 67 8 6 84 55 85 43 67 將77插入92前</small></li>
        <li><small>[67 77 92] 8 6 84 55 85 43 67 將67插入77前</small></li>
        <li><small>[8 67 77 92] 6 84 55 85 43 67 將8插入67前</small></li>
        <li><small>[6 8 67 77 92] 84 55 85 43 67 將6插入8前</small></li>
        <li><small>[6 8 67 77 84 92] 55 85 43 67 將84插入92前</small></li>
        <li><small>[6 8 55 67 77 84 92] 85 43 67 將55插入67前</small></li>
        <li><small>[6 8 55 67 77 84 85 92] 43 67 ......</small></li>
        <li><small>[6 8 43 55 67 77 84 85 92] 67 ......</small></li>
        <li><small>[6 8 43 55 67 67 77 84 85 92] ......</small></li>
      </ol>
      <small>
      </small></div>

      <small><br>
      </small>
      <ul>
        <li><small>氣泡排序法</small></li>
      </ul>

      <div style="margin-left: 40px;"><small>顧名思義，就是排序時，最大的元素會如同氣泡一樣移至右端，其利用比較相鄰元素的方法，將大的元素交換至右端，所以大的元素會不斷的往右移動，直到適當的位置為止。<br>

      </small></div>

      <div style="margin-left: 40px;"><small><br>

基本的氣泡排序法可以利用旗標的方式稍微減少一些比較的時間，當尋訪完陣列後都沒有發生任何的交換動作，表示排序已經完成，而無需再進行之後的迴圈比較與交換動作，例如：<br>
      <br>

排序前：95 27 90 49 80 58 6 9 18 50<br>
      <br>
      </small>


      <ol>
        <li><small>27 90 49 80 58 6 9 18 50 [95] 95浮出</small></li>
        <li><small>27 49 80 58 6 9 18 50 [90 95] 90浮出</small></li>
        <li><small>27 49 58 6 9 18 50 [80 90 95] 80浮出</small></li>
        <li><small>27 49 6 9 18 50 [58 80 90 95] ......</small></li>
        <li><small>27 6 9 18 49 [50 58 80 90 95] ......</small></li>
        <li><small>6 9 18 27 [49 50 58 80 90 95] ......</small></li>
        <li><small>6 9 18 [27 49 50 58 80 90 95] 由於接下來不會再發生交換動作，排序提早結束</small></li>
      </ol>

      <br>
      <small>
在上面的例子當中，還加入了一個觀念，就是當進行至i與i+1時沒有交換的動作，表示接下來的i+2至n已經排序完畢，這也增進了氣泡排序的效率。 </small><br>

      </div>


      <br>

      <h2> 實作</h2>


      <ul>
        <li> C
  </li>
      </ul>


      <pre>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;time.h&gt; <br>#define MAX 10 <br>#define SWAP(x,y) {int t; t = x; x = y; y = t;} <br><br>void selsort(int[]);  // 選擇排序 <br>void insort(int[]);   // 插入排序 <br>void bubsort(int[]);  // 氣泡排序 <br><br>int main(void) {  <br>    int number[MAX] = {0}; <br>    int i;  <br><br>    srand(time(NULL)); <br><br>    printf("排序前："); <br>    for(i = 0; i &lt; MAX; i++) { <br>        number[i] = rand() % 100; <br>        printf("%d ", number[i]); <br>    } <br><br>    printf("\n請選擇排序方式：\n"); <br>    printf("(1)選擇排序\n(2)插入排序\n(3)氣泡排序\n:"); <br>    scanf("%d", &amp;i); <br><br>    switch(i) { <br>        case 1: <br>            selsort(number); break; <br>        case 2: <br>            insort(number); break; <br>        case 3: <br>            bubsort(number); break; <br>        default: <br>            printf("選項錯誤(1..3)\n"); <br>    } <br><br>    return 0; <br>} <br><br>void selsort(int number[]) { <br>    int i, j, k, m; <br><br>    for(i = 0; i &lt; MAX-1; i++) { <br>        m = i; <br>        for(j = i+1; j &lt; MAX; j++) <br>            if(number[j] &lt; number[m]) <br>                m = j; <br><br>        if( i != m) <br>            SWAP(number[i], number[m]) <br><br>        printf("第 %d 次排序：", i+1); <br>        for(k = 0; k &lt; MAX; k++) <br>            printf("%d ", number[k]); <br>        printf("\n"); <br>    } <br> } <br><br> void insort(int number[]) { <br>    int i, j, k, tmp; <br><br>    for(j = 1; j &lt; MAX; j++) { <br>        tmp = number[j]; <br>        i = j - 1; <br>        while(tmp &lt; number[i]) { <br>            number[i+1] = number[i]; <br>            i--; <br>            if(i == -1) <br>                break; <br>        } <br>        number[i+1] = tmp; <br><br>        printf("第 %d 次排序：", j); <br>        for(k = 0; k &lt; MAX; k++) <br>            printf("%d ", number[k]); <br>        printf("\n"); <br>    } <br>} <br><br>void bubsort(int number[]) { <br>    int i, j, k, flag = 1; <br><br>    for(i = 0; i &lt; MAX-1 &amp;&amp; flag == 1; i++) { <br>        flag = 0; <br>        for(j = 0; j &lt; MAX-i-1; j++) { <br>            if(number[j+1] &lt; number[j]) { <br>                SWAP(number[j+1], number[j]); <br>                flag = 1; <br>            } <br>        } <br><br>        printf("第 %d 次排序：", i+1); <br>        for(k = 0; k &lt; MAX; k++) <br>            printf("%d ", number[k]); <br>        printf("\n"); <br>    } <br>} <br></pre>


      <p></p>


      <ul>
        <li> Java
  </li>
      </ul>


      <pre>public class BasicSort {<br>    public static void selectionSort(int[] number) {<br>        for(int i = 0; i &lt; number.length - 1; i++) { <br>            int m = i; <br>            for(int j = i + 1; j &lt; number.length; j++) <br>                if(number[j] &lt; number[m]) <br>                    m = j; <br><br>            if(i != m) <br>                swap(number, i, m);<br>        }<br>    }<br>    <br>    public static void injectionSort(int[] number) { <br>        for(int j = 1; j &lt; number.length; j++) { <br>            int tmp = number[j]; <br>            int i = j - 1; <br>            while(tmp &lt; number[i]) {<br>                number[i+1] = number[i]; <br>                i--; <br>                if(i == -1) <br>                    break; <br>            } <br>            <br>            number[i+1] = tmp; <br>        } <br>    }<br>    <br>    public static void bubbleSort(int[] number) {<br>        boolean flag = true; <br><br>        for(int i = 0; i &lt; number.length-1 &amp;&amp; flag; i++) { <br>            flag = false; <br>            for(int j = 0; j &lt; number.length-i-1; j++) { <br>                if(number[j+1] &lt; number[j]) { <br>                    swap(number, j+1, j); <br>                    flag = true; <br>                } <br>            } <br>        }<br>    }<br>    <br>    private static void swap(int[] number, int i, int j) {<br>        int t; <br>        t = number[i]; <br>        number[i] = number[j]; <br>        number[j] = t;<br>    }<br>}</pre>
 </td>

      <td style="width: 250px; text-align: center; vertical-align: top;">
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <br>

      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js">
      </script></td>

    </tr>

  </tbody>
</table>

<br>
</body>
</html>
