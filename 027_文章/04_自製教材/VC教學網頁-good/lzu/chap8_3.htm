<html>

<head>
<title>8.3 绘图程序</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
</head>

<body link="#3973DE" alink="#3973DE">
<font SIZE="5"><b><div align="center"><center>

<table border="0" width="615" cellspacing="0" cellpadding="0">
  <tr>
    </b><td><div align="center"><center><table border="0" width="615" cellpadding="0" cellspacing="0" height="20">
      <tr>
        <td width="377" bgcolor="#15397D" height="20"></td>
        <td width="238" bgcolor="#000000" height="20"><p align="right"></font><span style="text-decoration: none"><a href="javascript:if(confirm('http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/index.htm  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/index.htm'" tppabs="http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/index.htm"><font color="#FFFFFF">电脑报Visual 
        C++网络教程</font></a></span></td>
      </tr>
    </table>
    </center></div><font FACE="Times New Roman" SIZE="4"><b><p ALIGN="CENTER"></b></font><font color="#3973DE" FACE="Times New Roman" size="5">8.3 </font><font color="#3973DE" size="5">绘图程序</font><font FACE="Times New Roman" SIZE="4"></p>
    <p></font><font SIZE="3">在了解</font><font FACE="Times New Roman" SIZE="3">GDI</font><font SIZE="3">的一些基本知识之后，我们就可以着手编写绘图程序了。这个绘图程序可以让读者用鼠标器在窗口内任意涂写，并可以保存所画的内容。这里我们参考了</font><font FACE="Times New Roman" SIZE="3">Visual C++</font><font SIZE="3">的例子</font><font FACE="Times New Roman" SIZE="3">Scribble</font><font SIZE="3">，并作了一些修改和简化。</font><font FACE="Times New Roman" SIZE="3"><b></p>
    <p></b></font><font color="#3973DE" FACE="Times New Roman" SIZE="3">8.3.1 MDI</font><font SIZE="3" color="#3973DE">应用程序框架</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">首先用</font><font FACE="Times New Roman" SIZE="3">AppWizard</font><font SIZE="3">生成绘图程序的基本框架：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">选择</font><font FACE="Times New Roman" SIZE="3">File-&gt;New</font><font SIZE="3">，弹出</font><font FACE="Times New Roman" SIZE="3">New</font><font SIZE="3">对话框，选择</font><font FACE="Times New Roman" SIZE="3">MFC AppWizard(exe)</font><font SIZE="3">，并指定项目文件名为</font><font FACE="Times New Roman" SIZE="3">Draw</font><font SIZE="3">。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">在</font><font FACE="Times New Roman" SIZE="3">MFC 
    AppWizard-Step1</font><font SIZE="3">对话框中指定框架类型为</font><font FACE="Times New Roman" SIZE="3">Multiple Document(</font><font SIZE="3">多文档，这是缺省设置</font><font FACE="Times New Roman" SIZE="3">)</font><font SIZE="3">。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Step2,3</font><font SIZE="3">按缺省值。在</font><font FACE="Times New Roman" SIZE="3">MFC AppWizard Step 4 of 6</font><font SIZE="3">对话框中，点“</font><font FACE="Times New Roman" SIZE="3">Advanced...</font><font SIZE="3">”按钮，弹出</font><font FACE="Times New Roman" SIZE="3">Advanced Options</font><font SIZE="3">对话框。在</font><font FACE="Times New Roman" SIZE="3">File Extension</font><font SIZE="3">编辑框中指定文件名后缀为</font><font FACE="Times New Roman" SIZE="3">.drw</font><font SIZE="3">，按</font><font FACE="Times New Roman" SIZE="3">OK</font><font SIZE="3">关闭</font><font FACE="Times New Roman" SIZE="3">Advanced Options</font><font SIZE="3">对话框。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Step5</font><font SIZE="3">按缺省设置。在</font><font FACE="Times New Roman" SIZE="3">MFC AppWizard Step 6 of 6</font><font SIZE="3">中，在应用程序所包含的类列表中选择</font><font FACE="Times New Roman" SIZE="3">CDrawView</font><font SIZE="3">，并为其指定基类为</font><font FACE="Times New Roman" SIZE="3">CScrollView</font><font SIZE="3">，因为绘图程序需要卷滚文档。现在点</font><font FACE="Times New Roman" SIZE="3">Finish</font><font SIZE="3">按钮生成绘图所需的应用程序框架。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">在往框架里添加代码实现绘图程序之前，先看看多文档框架与单文档框架的差别。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>AppWizard</font><font SIZE="3">为多文档框架创建了以下类： </font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CAboutDlg</font><font SIZE="3">：“关于”对话框</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CChildFrame</font><font SIZE="3">：子框架窗口，用于容纳视图</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CDrawApp</font><font SIZE="3">：应用程序类</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CDrawDoc</font><font SIZE="3">：绘图程序视图类</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CDrawView</font><font SIZE="3">：绘图视图类</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CMainFrame</font><font SIZE="3">：主框架窗口，用来容纳子窗口，它是多文档应用程序的主窗口。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">在生成的类上，</font><font FACE="Times New Roman" SIZE="3">MDI</font><font SIZE="3">比</font><font FACE="Times New Roman" SIZE="3">SDI</font><font SIZE="3">多了一个</font><font FACE="Times New Roman" SIZE="3">CChildFrame</font><font SIZE="3">子框架窗口类，而且</font><font FACE="Times New Roman" SIZE="3">CMainFrame</font><font SIZE="3">的职责也不同了。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">另外，</font><font FACE="Times New Roman" SIZE="3">MDI</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">SDI</font><font SIZE="3">在初始化应用程序实例上也有所不同。</font><font FACE="Times New Roman" SIZE="3">MDI</font><font SIZE="3">应用程序</font><font FACE="Times New Roman" SIZE="3">InitInstance</font><font SIZE="3">函数如清单</font><font FACE="Times New Roman" SIZE="3">8.2</font><font SIZE="3">定义。<b></p>
    <p>清单</font><font FACE="Times New Roman" SIZE="3">8.2 </font><font SIZE="3">多文档程序的</font><font FACE="Times New Roman" SIZE="3">InitInstance</font><font SIZE="3">成员函数定义</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>BOOL CDrawApp::InitInstance()</p>
    <p>{</p>
    <p>//</font><font SIZE="3">一些初始化工作</font><font FACE="Times New Roman" SIZE="3">......</p>
    <p>// Register the application's document templates. Document templates</p>
    <p>// serve as the connection between documents, frame windows and views.</p>
    <p>CMultiDocTemplate* pDocTemplate;</p>
    <p>pDocTemplate = new CMultiDocTemplate(</p>
    <p>IDR_DRAWTYPE,</p>
    <p>RUNTIME_CLASS(CDrawDoc),</p>
    <p>RUNTIME_CLASS(CChildFrame), // custom MDI child frame</p>
    <p>RUNTIME_CLASS(CDrawView));</p>
    <p>AddDocTemplate(pDocTemplate);</p>
    <p>// create main MDI Frame window</p>
    <p>CMainFrame* pMainFrame = new CMainFrame;</p>
    <p>if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))</p>
    <p>return FALSE;</p>
    <p>m_pMainWnd = pMainFrame;</p>
    <p>// Enable drag/drop open</p>
    <p>m_pMainWnd-&gt;DragAcceptFiles();</p>
    <p>// Enable DDE Execute open</p>
    <p>EnableShellOpen();</p>
    <p>RegisterShellFileTypes(TRUE);</p>
    <p>// Parse command line for standard shell commands, DDE, file open</p>
    <p>CCommandLineInfo cmdInfo;</p>
    <p>ParseCommandLine(cmdInfo);</p>
    <p>// Dispatch commands specified on the command line</p>
    <p>if (!ProcessShellCommand(cmdInfo))</p>
    <p>return FALSE;</p>
    <p>// The main window has been initialized, so show and update it.</p>
    <p>pMainFrame-&gt;ShowWindow(m_nCmdShow);</p>
    <p>pMainFrame-&gt;UpdateWindow();</p>
    <p>return TRUE;</p>
    <p>}</p>
    <p></font><font SIZE="3">在注册文档模板时，首先创建一个</font><font FACE="Times New Roman" SIZE="3">CMultiDocTemplate</font><font SIZE="3">类型（在</font><font FACE="Times New Roman" SIZE="3">SDI</font><font SIZE="3">下是</font><font FACE="Times New Roman" SIZE="3">CSingleDocTemplate</font><font SIZE="3">）的模板对象，然后用</font><font FACE="Times New Roman" SIZE="3">AddDocTemplate</font><font SIZE="3">（）把它加入到文档模板链表中去。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CMultiDocTemplate</font><font SIZE="3">构造函数带四个参数，第一个参数是文档使用的资源</font><font FACE="Times New Roman" SIZE="3">ID</font><font SIZE="3">定义。第二个是文档类型，第三个是子窗口类型，第四个是视图类型。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">与</font><font FACE="Times New Roman" SIZE="3">SDI</font><font SIZE="3">不同，由于</font><font FACE="Times New Roman" SIZE="3">MDI</font><font SIZE="3">的主框架窗口并不直接与文档相对应，因此无法通过创建文档来创建主框架窗口，而需要自己去创建。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>//</font><font SIZE="3">定义一个主窗口类指针，并创建一个窗口的空的实例</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CMainFrame* pMainFrame = new CMainFrame;</p>
    <p>//</font><font SIZE="3">从资源文件中载入菜单、图标等信息，并创建窗口</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))</p>
    <p>return FALSE;</p>
    <p>//</font><font SIZE="3">将应用程序对象的主窗口指针数据成员设为当前创建的窗口</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>m_pMainWnd = pMainFrame;</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font></b><font color="#3973DE" FACE="Times New Roman" SIZE="3">8.3.2 </font><font SIZE="3" color="#3973DE">设计绘图程序的文档类</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Draw</font><font SIZE="3">需要保存用户在屏幕上涂写的每一个笔划。一副画由许多笔划组成，可以把它看作是笔划组成的链表。每一个笔划可以看作一个对象，它由许多点组成。这样，我们可以把绘图文档的数据看作是笔划对象</font><font FACE="Times New Roman" SIZE="3">CStroke</font><font SIZE="3">组成的链表。另外，我们还需要一些数据成员表示当前画图所使用的画笔和画笔的宽度。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">修改后的文档类声明文件如清单</font><font FACE="Times New Roman" SIZE="3">8-1</font><font SIZE="3">：<b></p>
    <p>清单</font><font FACE="Times New Roman" SIZE="3">8.3</font><font SIZE="3">文档类声明</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>// DrawDoc.h : interface of the CDrawDoc class</p>
    <p>//</p>
    <p>/////////////////////////////////////////////////////////////////////////////</p>
    <p>#if !defined(AFX_DRAWDOC_H__143330AE_85BC_11D1_9304_444553540000__INCLUDED_)</p>
    <p>#define AFX_DRAWDOC_H__143330AE_85BC_11D1_9304_444553540000__INCLUDED_</p>
    <p>#if _MSC_VER &gt;= 1000</p>
    <p>#pragma once</p>
    <p>#endif // _MSC_VER &gt;= 1000</p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>class CDrawDoc : public CDocument</p>
    <p>{</p>
    <p>protected: // create from serialization only</p>
    <p>CDrawDoc();</p>
    <p>DECLARE_DYNCREATE(CDrawDoc)</p>
    <p>// Attributes</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>public:</p>
    <p>UINT m_nPenWidth; // current user-selected pen width</p>
    <p>CPen m_penCur; // pen created according to</p>
    <p>// user-selected pen style (width)</p>
    <p>public:</p>
    <p>CTypedPtrList&lt;CObList,CStroke*&gt; m_strokeList; </p>
    <p>//</font><font SIZE="3">获取当前使用的画笔，为视图所使用</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CPen* GetCurrentPen() { return &amp;m_penCur; }</p>
    <p>protected:</p>
    <p>CSize m_sizeDoc;</p>
    <p>public:</p>
    <p>CSize GetDocSize() { return m_sizeDoc; }</p>
    <p>// Operations</p>
    <p>public:</p>
    <p>//</font><font SIZE="3">往链表里增加一个笔划</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CStroke* NewStroke();</p>
    <p>// Operations</p>
    <p>//</font><font SIZE="3">用于初始化文档</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>protected:</p>
    <p>void InitDocument();</b></p>
    <p>// Overrides</p>
    <p>// ClassWizard generated virtual function overrides</p>
    <p>//{{AFX_VIRTUAL(CDrawDoc)</p>
    <p>public:</p>
    <p>virtual BOOL OnNewDocument();</p>
    <p>virtual void Serialize(CArchive&amp; ar);</p>
    <p>//}}AFX_VIRTUAL</p>
    <p>// Implementation</p>
    <p>public:</p>
    <p>virtual ~CDrawDoc();</p>
    <p>#ifdef _DEBUG</p>
    <p>virtual void AssertValid() const;</p>
    <p>virtual void Dump(CDumpContext&amp; dc) const;</p>
    <p>#endif</p>
    <p>protected:</p>
    <p>// Generated message map functions</p>
    <p>protected:</p>
    <p>//{{AFX_MSG(CDrawDoc)</p>
    <p>// NOTE - the ClassWizard will add and remove member functions here.</p>
    <p>// DO NOT EDIT what you see in these blocks of generated code !</p>
    <p>//}}AFX_MSG</p>
    <p>DECLARE_MESSAGE_MAP()</p>
    <p>};</p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">这里我们使用 
    指针链表模板来保存指向每个笔划的指针：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CTypedPtrList&lt;CObList,CStroke*&gt; m_strokeList; </p>
    <p></font><font SIZE="3">其中“</font><font FACE="Times New Roman" SIZE="3">&lt;&gt;</font><font SIZE="3">”第一个参数表示链表基本类型，第二个参数代表链表中所存放的元素的类型。</p>
    <p>为了使用模板，还要修改</font><font FACE="Times New Roman" SIZE="3">stdafx.h</font><font SIZE="3">，在其中加入</font><font FACE="Times New Roman" SIZE="3">afxtempl..h</font><font SIZE="3">头文件，它包含了使用模板时所需的类型定义和宏：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>//.........</p>
    <p>#define VC_EXTRALEAN // Exclude rarely-used stuff from Windows headers</p>
    <p>#include &lt;afxwin.h&gt; // MFC core and standard components</p>
    <p>#include &lt;afxext.h&gt; // MFC extensions</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>#include &lt;afxtempl.h&gt; // MFC templates</b></p>
    <p>#include &lt;afxdisp.h&gt; // MFC OLE automation classes</p>
    <p>#ifndef _AFX_NO_AFXCMN_SUPPORT</p>
    <p>#include &lt;afxcmn.h&gt; // MFC support for Windows Common Controls</p>
    <p>#endif // _AFX_NO_AFXCMN_SUPPORT</p>
    <p>//......</p>
    <p></font><font SIZE="3">由于绘图程序需要卷滚文档，因此象前面的编辑那样，增加一个</font><font FACE="Times New Roman" SIZE="3">m_sizeDoc</font><font SIZE="3">数据成员存放文档的大小。另外，还需要提供一个</font><font FACE="Times New Roman" SIZE="3">GetDocSize()</font><font SIZE="3">来访问它。</font><font FACE="Times New Roman" SIZE="3">NewStroke()</font><font SIZE="3">用于往链表里增加一个笔划。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">现在，开始设计</font><font FACE="Times New Roman" SIZE="3">CStroke</font><font SIZE="3">类。笔划可以看作由一系列点组成，这样</font><font FACE="Times New Roman" SIZE="3">CStroke</font><font SIZE="3">可以用一个点的数组来表示。另外，还需要一些成员函数来访问这个数组。我们还希望笔划能够自己绘制自己，并用串行化机制保存自己的数据。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CStroke</font><font SIZE="3">类定义清单如</font><font FACE="Times New Roman" SIZE="3">8.4</font><font SIZE="3">，我们把它在</font><font FACE="Times New Roman" SIZE="3">CDrawDoc</font><font SIZE="3">类定义之前。<b></p>
    <p>清单</font><font FACE="Times New Roman" SIZE="3">8.4 CStroke</font><font SIZE="3">类定义</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>class CStroke : public CObject</p>
    <p>{</p>
    <p>public:</p>
    <p>CStroke(UINT nPenWidth);//</font><font SIZE="3">用笔的宽度构造一个画笔</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>//</font><font SIZE="3">用于串行化笔划对象</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>protected:</p>
    <p>CStroke(); //</font><font SIZE="3">串行化对象所需的不带参数的构造函数</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>DECLARE_SERIAL(CStroke)</p>
    <p>// Attributes</p>
    <p>protected:</p>
    <p>UINT m_nPenWidth; // one pen width applies to entire stroke</p>
    <p>public:</p>
    <p>//</font><font SIZE="3">用数组模板类保存笔划的所有点</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CArray&lt;CPoint,CPoint&gt; m_pointArray; // series of connected points</p>
    <p>//</font><font SIZE="3">包围笔划所有的点的一个最小矩形，关于它的作用以后会提到</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CRect m_rectBounding; // smallest rect that surrounds all</p>
    <p>// of the points in the stroke</p>
    <p>// measured in MM_LOENGLISH units</p>
    <p>// (0.01 inches, with Y-axis inverted)</p>
    <p>public:</p>
    <p>CRect&amp; GetBoundingRect() { return m_rectBounding; }</p>
    <p>//</font><font SIZE="3">结束笔划，计算最小矩形</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>void FinishStroke();</p>
    <p>// Operations</p>
    <p>public:</p>
    <p>//</font><font SIZE="3">绘制笔划</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>BOOL DrawStroke(CDC* pDC);</p>
    <p>public:</p>
    <p>virtual void Serialize(CArchive&amp; ar);</p>
    <p>};</font><font SIZE="3"><b></p>
    <p></b><font color="#3973DE">文档的初始化</font></font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">文档的初始化在</font><font FACE="Times New Roman" SIZE="3">OnNewDocument()</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">OnOpenDocument()</font><font SIZE="3">中完成。对于</font><font FACE="Times New Roman" SIZE="3">Draw</font><font SIZE="3">程序来说，两者的初始化相同，因此设计一个</font><font FACE="Times New Roman" SIZE="3">InitDocument()</font><font SIZE="3">函数用于文档初始化：</font><b><font FACE="Times New Roman" SIZE="3"></p>
    <p>void CDrawDoc::InitDocument()</p>
    <p>{</p>
    <p>m_nPenWidth=2;</p>
    <p>m_nPenCur.CreatePen(PS_SOLID,m_nPenWidth,RGB(0,0,0));</p>
    <p>//</font><font SIZE="3">缺省文档大小设置为</font><font FACE="Times New Roman" SIZE="3">800X900</font><font SIZE="3">个逻辑单位</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>m_sizeDoc = CSize(800,900);</p>
    <p>}</b></p>
    <p>InitDocument()</font><font SIZE="3">函数将笔的宽度初值设为</font><font FACE="Times New Roman" SIZE="3">2</font><font SIZE="3">，然后创建一个画笔对象。该对象在以后绘图是要用到。最后将文档尺寸大小设置为</font><font FACE="Times New Roman" SIZE="3">800X900</font><font SIZE="3">个逻辑单位。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">然后在</font><font FACE="Times New Roman" SIZE="3">OnNewDocument()</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">OnOpenDocument()</font><font SIZE="3">中调用它：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>void CDrawDoc::OnNewDocument()</p>
    <p>{</p>
    <p>if (!CDocument::OnNewDocument())</p>
    <p>return FALSE;</p>
    <p>// TODO: add reinitialization code here</p>
    <p>// (SDI documents will reuse this document)</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>InitDocument();</b></p>
    <p>return TRUE;</p>
    <p>}</p>
    <p>AppWizard</font><font SIZE="3">并没有生成</font><font FACE="Times New Roman" SIZE="3">OnOpenDocument()</font><font SIZE="3">的代码，因此要用</font><font FACE="Times New Roman" SIZE="3">ClassWizard</font><font SIZE="3">来生成</font><font FACE="Times New Roman" SIZE="3">OnOpenDocument()</font><font SIZE="3">的框架。生成框架后，在其中加入代码：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>BOOL CDrawDoc::OnOpenDocument(LPCTSTR lpszPathName) </p>
    <p>{</p>
    <p>if (!CDocument::OnOpenDocument(lpszPathName))</p>
    <p>return FALSE;</p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>// TODO: Add your specialized creation code here</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>InitDocument();</b></p>
    <p>return TRUE;</p>
    <p>}</font><font SIZE="3"><b></p>
    <p></b><font color="#3973DE">文档的清理</font></font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">在关闭文档的最后一个子窗口时，框架要求文档清理数据。文档清理在文档类的</font><font FACE="Times New Roman" SIZE="3">DeleteContents()</font><font SIZE="3">中完成。同样需要用</font><font FACE="Times New Roman" SIZE="3">ClassWizard</font><font SIZE="3">生成</font><font FACE="Times New Roman" SIZE="3">DeleteContents</font><font SIZE="3">的框架。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>void CDrawDoc::DeleteContents() </p>
    <p>{</p>
    <p>// TODO: Add your specialized code here and/or call the base class</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>while (!m_strokeList.IsEmpty())</p>
    <p>{</p>
    <p>delete m_strokeList.RemoveHead();</p>
    <p>}</b></p>
    <p>CDocument::DeleteContents();</p>
    <p>}</p>
    <p>DeleteContents()</font><font SIZE="3">从头到尾遍里链表中的所有对象指针，并通过指针删除对象，然后用</font><font FACE="Times New Roman" SIZE="3">RemoveHead()</font><font SIZE="3">删除该指针。<b></p>
    <p></b><font color="#3973DE">文档的串行化</font></font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">现在设计文档的</font><font FACE="Times New Roman" SIZE="3">Serialize</font><font SIZE="3">函数，实现文档数据的保存和载入：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>void CDrawDoc::Serialize(CArchive&amp; ar)</p>
    <p>{</p>
    <p>if (ar.IsStoring())</p>
    <p>{</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>ar &lt;&lt; m_sizeDoc;</b></p>
    <p>}</p>
    <p>else</p>
    <p>{</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>ar &gt;&gt; m_sizeDoc;</b></p>
    <p>}</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>m_strokeList.Serialize(ar);</b></p>
    <p>}</p>
    <p></font><font SIZE="3">文档的</font><font FACE="Times New Roman" SIZE="3">Serialize()</font><font SIZE="3">函数首先分别保存和载入文档大小，然后调用</font><font FACE="Times New Roman" SIZE="3">m_strokeList</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">Serialize()</font><font SIZE="3">方法。</font><font FACE="Times New Roman" SIZE="3">m_strokeList.Serialize()</font><font SIZE="3">又会自动调用存放在</font><font FACE="Times New Roman" SIZE="3">m_strokeList</font><font SIZE="3">中的每一个元素</font><font FACE="Times New Roman" SIZE="3">CStroke</font><font SIZE="3">的串行化方法</font><font FACE="Times New Roman" SIZE="3">CStroke.Serialize()</font><font SIZE="3">最终实现文档的串行化即文档所包含的对象的存储和载入。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">在</font><font FACE="Times New Roman" SIZE="3">DrawDoc.cpp</font><font SIZE="3">的末尾加上</font><font FACE="Times New Roman" SIZE="3">CStroke::Serialize()</font><font SIZE="3">函数的定义：</font><font FACE="Times New Roman" SIZE="3"><b></p>
    <p>void CStroke::Serialize(CArchive&amp; ar)</p>
    <p>{</p>
    <p>if (ar.IsStoring())</p>
    <p>{</p>
    <p>ar &lt;&lt; m_rectBounding;</p>
    <p>ar &lt;&lt; (WORD)m_nPenWidth;</p>
    <p>m_pointArray.Serialize(ar);</p>
    <p>}</p>
    <p>else</p>
    <p>{</p>
    <p>ar &gt;&gt; m_rectBounding;</p>
    <p>WORD w;</p>
    <p>ar &gt;&gt; w;</p>
    <p>m_nPenWidth = w;</p>
    <p>m_pointArray.Serialize(ar);</p>
    <p>}</p>
    <p>}</b></p>
    <p>CStroke</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">Serialize()</font><font SIZE="3">依次保存（载入）笔划的矩形边界、线宽度以及点数组。注意</font><font FACE="Times New Roman" SIZE="3">m_nPenWidth</font><font SIZE="3">是</font><font FACE="Times New Roman" SIZE="3">UINT</font><font SIZE="3">类型的，</font><font FACE="Times New Roman" SIZE="3">&gt;&gt;</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">&lt;&lt;</font><font SIZE="3">操作符并不支持</font><font FACE="Times New Roman" SIZE="3">UINT</font><font SIZE="3">类型但却支持</font><font FACE="Times New Roman" SIZE="3">WORD</font><font SIZE="3">，因此要作</font><font FACE="Times New Roman" SIZE="3">UINT</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">DWORD</font><font SIZE="3">之间的类型转换。点数组的串行化通过调用数组的每个</font><font FACE="Times New Roman" SIZE="3">CPoint</font><font SIZE="3">类元素的</font><font FACE="Times New Roman" SIZE="3">Serialize()</font><font SIZE="3">完成，</font><font FACE="Times New Roman" SIZE="3">CPoint</font><font SIZE="3">类是</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">类，它本身支持串行化。</font><font FACE="Times New Roman"><b></p>
    <p></b></font><font color="#3973DE" FACE="Times New Roman">8.3.3 </font><font color="#3973DE">设计绘图程序的视图类</font></p>
    <p><font SIZE="3"><b>　</p>
    <p></b><font color="#3973DE">视图类数据成员</font></font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">现在着手设计绘图程序的视图类。首先，需要在视图中增加两个数据成员：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>class CDrawView : public CScrollView</p>
    <p>{</p>
    <p>protected: // create from serialization only</p>
    <p>CDrawView();</p>
    <p>DECLARE_DYNCREATE(CDrawView)</p>
    <p>// Attributes</p>
    <p>public:</p>
    <p>CDrawDoc* GetDocument();</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>protected:</p>
    <p>CStroke* m_pStrokeCur; // the stroke in progress</p>
    <p>CPoint m_ptPrev; // the last mouse pt in the stroke in progress</b></p>
    <p>// </font><font SIZE="3">其它数据成员和成员函数</font><font FACE="Times New Roman" SIZE="3">......</p>
    <p>}</font><font SIZE="3">；</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>m_pStrokeCur</font><font SIZE="3">代表正在画的那一个笔划。</font><font FACE="Times New Roman" SIZE="3">m_ptPrev</font><font SIZE="3">保存鼠标上次移动位置。画图时，</font><font FACE="Times New Roman" SIZE="3">LineTo</font><font SIZE="3">从这个点到当前鼠标位置画一条直线。<b></p>
    <p></b><font color="#3973DE">视图初始化</font></font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">接下去，要初始化视图。由于是卷滚视图，因此要在</font><font FACE="Times New Roman" SIZE="3">OnInitialUpdate()</font><font SIZE="3">中设置卷滚范围。在用户选择</font><font FACE="Times New Roman" SIZE="3">File-&gt;New</font><font SIZE="3">菜单或</font><font FACE="Times New Roman" SIZE="3">File-&gt;Open</font><font SIZE="3">菜单时，框架调用</font><font FACE="Times New Roman" SIZE="3">OnInitialUpdate</font><font SIZE="3">函数。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>void CDrawView::OnInitialUpdate()</p>
    <p>{</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>SetScrollSizes(MM_LOENGLISH, GetDocument()-&gt;GetDocSize());</b></p>
    <p>CScrollView::OnInitialUpdate();</p>
    <p>}</p>
    <p></font><font SIZE="3">注意我们这里将映射模式设置为</font><font FACE="Times New Roman" SIZE="3">MM_LOENGLISH</font><font SIZE="3">，</font><font FACE="Times New Roman" SIZE="3">MM_LOENGLISH</font><font SIZE="3">以</font><font FACE="Times New Roman" SIZE="3">0.01</font><font SIZE="3">英寸为逻辑单位，</font><font FACE="Times New Roman" SIZE="3">y</font><font SIZE="3">轴方向向上递增，同</font><font FACE="Times New Roman" SIZE="3">MM_TEXT</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">y</font><font SIZE="3">轴递增方向相反。<b></p>
    <p></b><font color="#3973DE">视图绘制</font></font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">在</font><font FACE="Times New Roman" SIZE="3">CDrawView::OnDraw()</font><font SIZE="3">内完成视图绘制工作。在以前的文档视结构程序中，在需要绘图的时侯都是绘制整个窗口。如果窗口只有很小的一部分被覆盖，是否可以只绘制那些需要重画的部分？</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">回答是肯定的，而且大部分程序都这么做了。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">比如，象下图这种情况：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">图</font><font FACE="Times New Roman" SIZE="3">8-5 </font><font SIZE="3">窗口的重绘</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">当窗口</font><font FACE="Times New Roman" SIZE="3">2</font><font SIZE="3">从窗口</font><font FACE="Times New Roman" SIZE="3">1</font><font SIZE="3">上移开后，只需要重画阴影线所包围的区域就够了。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">当</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">通知窗口要重绘用户区时，并非整个用户区都需要重绘，需要重绘的区域称为“无效矩形区”，如上图中的阴影区域。用户区中出现一个无效矩形提示</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">在应用程序队列中放置</font><font FACE="Times New Roman" SIZE="3">WM_PAINT</font><font SIZE="3">消息。由于</font><font FACE="Times New Roman" SIZE="3">WM_PAINT</font><font SIZE="3">消息优先级最低，可调用</font><font FACE="Times New Roman" SIZE="3">UpdateWindows</font><font SIZE="3">直接立即向窗口发送</font><font FACE="Times New Roman" SIZE="3">WM_PAINT</font><font SIZE="3">消息，从而立即重绘。无效矩形区限制程序只能在该区域中绘图，越界的绘图将被裁剪掉。下面三个函数与无效矩形有关：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>InvalidateRect </font><font SIZE="3">产生一个无效矩形，并生成</font><font FACE="Times New Roman" SIZE="3">WM_PAINT</font><font SIZE="3">消息</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>ValidateRect </font><font SIZE="3">使无效矩形区有效</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>GetUpdateRect </font><font SIZE="3">获得无效矩形坐标（逻辑）</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Windows</font><font SIZE="3">为每个窗口保留一个</font><font FACE="Times New Roman" SIZE="3">PAINTSTRUCT</font><font SIZE="3">结构，其中包含无效矩形区域的坐标值。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">要想在自己的程序高效绘图、只绘制无效矩形，首先需要重载视图的</font><font FACE="Times New Roman" SIZE="3">OnUpdate</font><font SIZE="3">成员函数。</p>
    <blockquote>
      <blockquote>
        </font><b><font FACE="Arial" SIZE="3"><p></font><font FACE="Times New Roman" SIZE="3">virtual</b> 
        <b>void</b> <b>CView::OnUpdate(</b> <b>CView*</b> <i>pSender</i><b>,</b> <b>LPARAM</b> <i>lHint</i><b>,</b> 
        <b>CObject*</b> <i>pHint</i> <b>);</b></p>
      </blockquote>
    </blockquote>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">当调用文档的</font><font FACE="Times New Roman" SIZE="3">UpdateAllViews</font><font SIZE="3">时，框架会自动调用</font><font FACE="Times New Roman" SIZE="3">OnUpdate</font><font SIZE="3">函数，也可在视图类中直接调用该函数。</font><font FACE="Times New Roman" SIZE="3">OnUpdate</font><font SIZE="3">函数一般是这样处理的：访问文档，读取文档的数据，然后对视图的数据成员或控制进行更新，以反映文档的改动。可以用</font><font FACE="Times New Roman" SIZE="3">OnUpdate</font><font SIZE="3">函数使视图的某部分无效。以便触发视的</font><font FACE="Times New Roman" SIZE="3">OnDraw</font><font SIZE="3">，利用文档数据重绘窗口。缺省的</font><font FACE="Times New Roman" SIZE="3">OnUpdate</font><font SIZE="3">使窗口整个客户区都无效，在重新设计时，要利用提示信息</font><font FACE="Times New Roman" SIZE="3">lHint</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">pHint</font><font SIZE="3">定义一个较小的无效矩形。修改后的</font><font FACE="Times New Roman" SIZE="3">OnUpdate</font><font SIZE="3">成员函数如清单</font><font FACE="Times New Roman" SIZE="3">8.5</font><font SIZE="3">。<b></p>
    <p>清单</font><font FACE="Times New Roman" SIZE="3">8.5 </font><font SIZE="3">修改后的</font><font FACE="Times New Roman" SIZE="3">OnUpdate</font><font SIZE="3">成员函数</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>void CDrawView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) </p>
    <p>{</p>
    <p>// TODO: Add your specialized code here and/or call the base class</p>
    <p>// The document has informed this view that some data has changed.</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>if (pHint != NULL)</p>
    <p>{</p>
    <p>if (pHint-&gt;IsKindOf(RUNTIME_CLASS(CStroke)))</p>
    <p>{</p>
    <p>// The hint is that a stroke as been added (or changed).</p>
    <p>// So, invalidate its rectangle.</p>
    <p>CStroke* pStroke = (CStroke*)pHint;</p>
    <p>CClientDC dc(this);</p>
    <p>OnPrepareDC(&amp;dc);</p>
    <p>CRect rectInvalid = pStroke-&gt;GetBoundingRect();</p>
    <p>dc.LPtoDP(&amp;rectInvalid);</p>
    <p>InvalidateRect(&amp;rectInvalid);</p>
    <p>return;</p>
    <p>}</b></p>
    <p>}</p>
    <p>// We can't interpret the hint, so assume that anything might</p>
    <p>// have been updated.</p>
    <p>Invalidate(TRUE);</p>
    <p>return;</p>
    <p>}</p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">这里，传给</font><font FACE="Times New Roman" SIZE="3">pHint</font><font SIZE="3">指针的内容是指向需要绘制的笔画对象的指针。采用强制类型转换将它转换为笔划指针，然后取得包围该笔划的最小矩形。</font><font FACE="Times New Roman" SIZE="3">OnPrepareDC</font><font SIZE="3">用于调整视图坐标原点。由于</font><font FACE="Times New Roman" SIZE="3">InvalidateRect</font><font SIZE="3">需要设备坐标，因此调用</font><font FACE="Times New Roman" SIZE="3">LPToDP(&amp;rectInvalid)</font><font SIZE="3">将逻辑坐标转换为设备坐标。最后，调用</font><font FACE="Times New Roman" SIZE="3">InvalidateRect</font><font SIZE="3">是窗口部分区域“无效”，也就是视图在收到</font><font FACE="Times New Roman" SIZE="3">WM_PAINT</font><font SIZE="3">消息后需要重绘这一区域。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>InvalidateRect</font><font SIZE="3">函数原型为：</font><font FACE="Times New Roman" SIZE="3"></p>
    <blockquote>
      <blockquote>
        <p>void InvalidateRect( LPCRECT lpRect, BOOL bErase = TRUE );</p>
      </blockquote>
    </blockquote>
    <p></font><font SIZE="3">第一个参数是指向要重绘的矩形的指针，第二个参数告诉视图是否要删除区域内的背景。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">这样，当需要重画某一笔划时，只需要重画包围笔划的最小矩形部分就可以了，其他部分就不再重绘。这也是为什么在笔划对象中提供最小矩形信息的原因。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">如果</font><font FACE="Times New Roman" SIZE="3">pHint</font><font SIZE="3">为空，则表明是一般的重绘，此时需要重绘整个客户区。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">现在，在</font><font FACE="Times New Roman" SIZE="3">OnDraw</font><font SIZE="3">中，根据无效矩形绘制图形，而不是重绘全部笔划，见清单</font><font FACE="Times New Roman" SIZE="3">8.6</font><font SIZE="3">。<b></p>
    <p>清单</font><font FACE="Times New Roman" SIZE="3">8.6 </font><font SIZE="3">根据无效矩形绘制图形的</font><font FACE="Times New Roman" SIZE="3">OnDraw</font><font SIZE="3">成员函数</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>void CDrawView::OnDraw(CDC* pDC)</p>
    <p>{</p>
    <p>CDrawDoc* pDoc = GetDocument();</p>
    <p>ASSERT_VALID(pDoc);</p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>// Get the invalidated rectangle of the view, or in the case</p>
    <p>// of printing, the clipping region of the printer dc.</p>
    <p>CRect rectClip;</p>
    <p>CRect rectStroke;</p>
    <p>pDC-&gt;GetClipBox(&amp;rectClip);</p>
    <p>pDC-&gt;LPtoDP(&amp;rectClip);</p>
    <p>rectClip.InflateRect(1, 1); // avoid rounding to nothing</p>
    <p>// Note: CScrollView::OnPaint() will have already adjusted the</p>
    <p>// viewport origin before calling OnDraw(), to reflect the</p>
    <p>// currently scrolled position.</p>
    <p>// The view delegates the drawing of individual strokes to</p>
    <p>// CStroke::DrawStroke().</p>
    <p>CTypedPtrList&lt;CObList,CStroke*&gt;&amp; strokeList = pDoc-&gt;m_strokeList;</p>
    <p>POSITION pos = strokeList.GetHeadPosition();</p>
    <p>while (pos != NULL)</p>
    <p>{</p>
    <p>CStroke* pStroke = strokeList.GetNext(pos);</p>
    <p>rectStroke = pStroke-&gt;GetBoundingRect();</p>
    <p>pDC-&gt;LPtoDP(&amp;rectStroke);</p>
    <p>rectStroke.InflateRect(1, 1); // avoid rounding to nothing</p>
    <p>if (!rectStroke.IntersectRect(&amp;rectStroke, &amp;rectClip))</p>
    <p>continue;</p>
    <p>pStroke-&gt;DrawStroke(pDC);</p>
    <p>}</b></p>
    <p>// TODO: add draw code for native data here</p>
    <p>}</p>
    <p>OnDraw</font><font SIZE="3">首先调用</font><font FACE="Times New Roman" SIZE="3">GetClipBox</font><font SIZE="3">取得当前被剪裁区域（无效矩形区域），它把矩形复制导</font><font FACE="Times New Roman" SIZE="3">GetClipBox</font><font SIZE="3">的参数</font><font FACE="Times New Roman" SIZE="3">rectClip</font><font SIZE="3">中。然后将</font><font FACE="Times New Roman" SIZE="3">rectClip</font><font SIZE="3">的坐标由逻辑坐标转换为设备坐标。为了防止该矩形太小而无法包围其他内容，上下各放大一个单位。然后</font><font FACE="Times New Roman" SIZE="3">OnDraw</font><font SIZE="3">遍历笔划链表中的所有笔划，获取它们的最小矩形，用</font><font FACE="Times New Roman" SIZE="3">IntersectRect</font><font SIZE="3">看它是否与无效矩形相交。如果相交，说明笔划的部分或全部落在无效矩形中，此时调用笔划的</font><font FACE="Times New Roman" SIZE="3">DrawStroke</font><font SIZE="3">方法画出该笔划。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><b><font SIZE="3">图</font><font FACE="Times New Roman" SIZE="3">8-6</b> </font><font SIZE="3">根据包围笔划 的矩形是否与无效</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">矩形相交 ，判断笔划是否落入无效矩形中 </font><font FACE="Times New Roman" SIZE="3"><b></p>
    <p></b></font><font SIZE="3">为了获得笔划的最小包围矩形，需要在结束笔划时计算出包围笔划的最小矩形。因此为笔划提供两个方法：一个是</font><font FACE="Times New Roman" SIZE="3">FinishStroke()</font><font SIZE="3">，用于在笔划结束时计算最小矩形，见清单</font><font FACE="Times New Roman" SIZE="3">8.7</font><font SIZE="3">。<b></p>
    <p>清单</font><font FACE="Times New Roman" SIZE="3">8.7 CStroke::FinishStroke()</font><font SIZE="3">成员函数</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>void CStroke::FinishStroke()</p>
    <p>{</p>
    <p>// Calculate the bounding rectangle. It's needed for smart</p>
    <p>// repainting.</p>
    <p>if (m_pointArray.GetSize()==0)</p>
    <p>{</p>
    <p>m_rectBounding.SetRectEmpty();</p>
    <p>return;</p>
    <p>}</p>
    <p>CPoint pt = m_pointArray[0];</p>
    <p>m_rectBounding = CRect(pt.x, pt.y, pt.x, pt.y);</p>
    <p>for (int i=1; i &lt; m_pointArray.GetSize(); i++)</p>
    <p>{</p>
    <p>// If the point lies outside of the accumulated bounding</p>
    <p>// rectangle, then inflate the bounding rect to include it.</p>
    <p>pt = m_pointArray[i];</p>
    <p>m_rectBounding.left = min(m_rectBounding.left, pt.x);</p>
    <p>m_rectBounding.right = max(m_rectBounding.right, pt.x);</p>
    <p>m_rectBounding.top = max(m_rectBounding.top, pt.y);</p>
    <p>m_rectBounding.bottom = min(m_rectBounding.bottom, pt.y);</p>
    <p>}</p>
    <p>// Add the pen width to the bounding rectangle. This is necessary</p>
    <p>// to account for the width of the stroke when invalidating</p>
    <p>// the screen.</p>
    <p>m_rectBounding.InflateRect(CSize(m_nPenWidth, -(int)m_nPenWidth));</p>
    <p>return;</p>
    <p>}</p>
    <p></font><font SIZE="3">另一个是</font><font FACE="Times New Roman" SIZE="3">DrawStroke()</font><font SIZE="3">，用于绘制笔划：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>BOOL CStroke::DrawStroke(CDC* pDC)</p>
    <p>{</p>
    <p>CPen penStroke;</p>
    <p>if (!penStroke.CreatePen(PS_SOLID, m_nPenWidth, RGB(0,0,0)))</p>
    <p>return FALSE;</p>
    <p>CPen* pOldPen = pDC-&gt;SelectObject(&amp;penStroke);</p>
    <p>pDC-&gt;MoveTo(m_pointArray[0]);</p>
    <p>for (int i=1; i &lt; m_pointArray.GetSize(); i++)</p>
    <p>{</p>
    <p>pDC-&gt;LineTo(m_pointArray[i]);</p>
    <p>}</p>
    <p>pDC-&gt;SelectObject(pOldPen);</p>
    <p>return TRUE;</p>
    <p>}</p>
    <p></font><font SIZE="3"><b>　</p>
    <p></b><font color="#3973DE">鼠标绘图</font></font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">鼠标绘图基本过程是：用户按下鼠标左键时开始绘图，在鼠标左键按下且移动过程中不断画线跟踪鼠标位置，当松开鼠标左键结束绘图。因此，需要处理三个消息：</font><font FACE="Times New Roman" SIZE="3">WM_LBUTTONDOWN</font><font SIZE="3">、</font><font FACE="Times New Roman" SIZE="3">WM_MOUSEMOVE</font><font SIZE="3">、</font><font FACE="Times New Roman" SIZE="3">WM_LBUTTONUP</font><font SIZE="3">。用</font><font FACE="Times New Roman" SIZE="3">ClassWizard</font><font SIZE="3">为上述三个消息生成消息处理函数，并在其中手工加入代码，修改后的成员函数如下：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><b><font SIZE="3">　</p>
    <p ALIGN="JUSTIFY">清单</font><font FACE="Times New Roman" SIZE="3">8.8 </font><font SIZE="3">鼠标消息处理函数</font><font FACE="Times New Roman" SIZE="3">OnLButtonDown()</b></p>
    <p>void CDrawView::OnLButtonDown(UINT nFlags, CPoint point) </p>
    <p>{</p>
    <p>// TODO: Add your message handler code here and/or call default</p>
    <p>// Pressing the mouse button in the view window starts a new stroke</p>
    <p>// CScrollView changes the viewport origin and mapping mode.</p>
    <p>// It's necessary to convert the point from device coordinates</p>
    <p>// to logical coordinates, such as are stored in the document.</p>
    <p>CClientDC dc(this);</p>
    <p>OnPrepareDC(&amp;dc);</p>
    <p>dc.DPtoLP(&amp;point);</p>
    <p>m_pStrokeCur = GetDocument()-&gt;NewStroke();</p>
    <p>// Add first point to the new stroke</p>
    <p>m_pStrokeCur-&gt;m_pointArray.Add(point);</p>
    <p>SetCapture(); // Capture the mouse until button up.</p>
    <p>m_ptPrev = point; // Serves as the MoveTo() anchor point for the</p>
    <p>// LineTo() the next point, as the user drags the</p>
    <p>// mouse.</p>
    <p>return;</p>
    <p>}</p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">在鼠标左键按下，首先获得鼠标按下的位置坐标。由于它是设备坐标，因此先用</font><font FACE="Times New Roman" SIZE="3">DPToLP</font><font SIZE="3">将它转换为逻辑坐标。在此之前，要用</font><font FACE="Times New Roman" SIZE="3">OnPrepareDC()</font><font SIZE="3">对视图坐标原点进行调整。然后用</font><font FACE="Times New Roman" SIZE="3">CDrawDoc</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">NewStroke()</font><font SIZE="3">成员函数创建一个笔划对象，并将笔划对象加入到笔划链表中。然后，将当前点坐标加入道笔划对象内部的点数组中。以后，当鼠标移动时，</font><font FACE="Times New Roman" SIZE="3">OnMouseMove</font><font SIZE="3">就不断修改该笔划对象的内部数据成员（加入新的点到笔划对象的数组中）。另外，为了用</font><font FACE="Times New Roman" SIZE="3">LineTo</font><font SIZE="3">画出线条，需要将当前鼠标位置保存到</font><font FACE="Times New Roman" SIZE="3">m_ptPrev</font><font SIZE="3">中，以便出现一个新的点时，画一条从</font><font FACE="Times New Roman" SIZE="3">m_ptPrev</font><font SIZE="3">到新的点的直线。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">但是，由于用户的鼠标可以在屏幕上任意移动。当鼠标移出窗口外时，窗口无法收到鼠标消息。此时，如果松开了鼠标左键，应用程序由于无法接受到该条消息而不会终止当前笔划，这样就造成了错误。如何避免这种情况发生呢？解决的办法是要让窗口在鼠标移出窗口外时仍然能接受到鼠标消息。幸好，</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">提供了一个</font><font FACE="Times New Roman" SIZE="3">API</font><font SIZE="3">函数</font><font FACE="Times New Roman" SIZE="3">SetCapture()</font><font SIZE="3">解决了这一问题。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>CWnd::SetCapture()</font><font SIZE="3">用于捕获鼠标：无论鼠标光标位置在何处，都会将鼠标消息送给调用它的那一个窗口。在用完后，需要用</font><font FACE="Times New Roman" SIZE="3">ReleaseCapture()</font><font SIZE="3">释放窗口对鼠标的控制，否则其他窗口将无法接收到鼠标消息。这一工作当然最好在鼠标左键松开</font><font FACE="Times New Roman" SIZE="3">OnLButtonUp()</font><font SIZE="3">时来做。<b></p>
    <p>清单</font><font FACE="Times New Roman" SIZE="3">8.9 OnLButtonUp</font><font SIZE="3">消息处理函数</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>void CDrawView::OnLButtonUp(UINT nFlags, CPoint point) </p>
    <p>{</p>
    <p>// TODO: Add your message handler code here and/or call default</p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>// Mouse button up is interesting in the draw application</p>
    <p>// only if the user is currently drawing a new stroke by dragging</p>
    <p>// the captured mouse.</p>
    <p>if (GetCapture() != this)</p>
    <p>return; // If this window (view) didn't capture the mouse,</p>
    <p>// then the user isn't drawing in this window.</p>
    <p>CDrawDoc* pDoc = GetDocument();</p>
    <p>CClientDC dc(this);</p>
    <p>// CScrollView changes the viewport origin and mapping mode.</p>
    <p>// It's necessary to convert the point from device coordinates</p>
    <p>// to logical coordinates, such as are stored in the document.</p>
    <p>OnPrepareDC(&amp;dc); // set up mapping mode and viewport origin</p>
    <p>dc.DPtoLP(&amp;point);</p>
    <p>CPen* pOldPen = dc.SelectObject(pDoc-&gt;GetCurrentPen());</p>
    <p>dc.MoveTo(m_ptPrev);</p>
    <p>dc.LineTo(point);</p>
    <p>dc.SelectObject(pOldPen);</p>
    <p>m_pStrokeCur-&gt;m_pointArray.Add(point);</p>
    <p>// Tell the stroke item that we're done adding points to it.</p>
    <p>// This is so it can finish computing its bounding rectangle.</p>
    <p>m_pStrokeCur-&gt;FinishStroke();</p>
    <p>// Tell the other views that this stroke has been added</p>
    <p>// so that they can invalidate this stroke's area in their</p>
    <p>// client area.</p>
    <p>pDoc-&gt;UpdateAllViews(this, 0L, m_pStrokeCur);</p>
    <p>ReleaseCapture(); // Release the mouse capture established at</p>
    <p>// the beginning of the mouse drag.</p>
    <p>return;</p>
    <p>}</p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>OnLButtonUp</font><font SIZE="3">首先检查鼠标是否被当前窗口所捕获，如果不是则返回。然后画出笔划最后两点之间的极短的直线段。接着，调用</font><font FACE="Times New Roman" SIZE="3">CStroke::FinishStroke()</font><font SIZE="3">，请求</font><font FACE="Times New Roman" SIZE="3">CStroke</font><font SIZE="3">对象计算它的最小矩形。然后调用</font><font FACE="Times New Roman" SIZE="3">pDoc-&gt;UpdateAllViews(this, 0L, m_pStrokeCur)</font><font SIZE="3">通知其他视图更新显示。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">当一个视图修改了文档内容并更新显示时，一般的其它的对应于同一文档的视图也需要相应更新，这通过调用文档的成员函数</font><font FACE="Times New Roman" SIZE="3">UpdateAllViews</font><font SIZE="3">完成。</font><font FACE="Times New Roman" SIZE="3"></p>
    <blockquote>
      <blockquote>
        <p>void UpdateAllViews( CView* pSender, LPARAM lHint = 0L, CObject* pHint = </p>
        <p>NULL );</p>
        <b>
      </blockquote>
    </blockquote>
    <p></b>UpdateAllViews</font><font SIZE="3">带三个参数：</font><font FACE="Times New Roman" SIZE="3">pSender</font><font SIZE="3">指向修改文档的视图。由于该视图已经作了更新，所以不再需要更新。比如，在上面的例子中，</font><font FACE="Times New Roman" SIZE="3">OnLButtonUp</font><font SIZE="3">已经绘制了视图，因此不需要再次更新。如果为</font><font FACE="Times New Roman" SIZE="3">NULL</font><font SIZE="3">，则文档对应的所有视图都被更新。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>lHint</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">pHint</font><font SIZE="3">包含了更新视图时所需的附加信息。在本例中，其他视图只需要重画当前绘制中的笔划，因此</font><font FACE="Times New Roman" SIZE="3">OnLButtonUp</font><font SIZE="3">把当前笔划指针传给</font><font FACE="Times New Roman" SIZE="3">UpdateAllViews</font><font SIZE="3">函数。该函数调用文档所对应的除</font><font FACE="Times New Roman" SIZE="3">pSender</font><font SIZE="3">外的所有视图的</font><font FACE="Times New Roman" SIZE="3">OnUpdate</font><font SIZE="3">函数，并将</font><font FACE="Times New Roman" SIZE="3">lHint</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">pHint</font><font SIZE="3">传给</font><font FACE="Times New Roman" SIZE="3">OnUpdate</font><font SIZE="3">函数通知更新附加信息。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>OnLButtonUp</font><font SIZE="3">最后释放对鼠标的控制，这样别的应用程序窗口就可以获得鼠标消息了。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">结合上面讲到的知识，读者不难自行理解下面的</font><font FACE="Times New Roman" SIZE="3">OnMouseMove</font><font SIZE="3">函数。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>void CDrawView::OnMouseMove(UINT nFlags, CPoint point) </p>
    <p>{</p>
    <p>// TODO: Add your message handler code here and/or call default</p>
    <p>// Mouse movement is interesting in the Scribble application</p>
    <p>// only if the user is currently drawing a new stroke by dragging</p>
    <p>// the captured mouse.</p>
    <p>if (GetCapture() != this)</p>
    <p>return; // If this window (view) didn't capture the mouse,</p>
    <p>// then the user isn't drawing in this window.</p>
    <p>CClientDC dc(this);</p>
    <p>// CScrollView changes the viewport origin and mapping mode.</p>
    <p>// It's necessary to convert the point from device coordinates</p>
    <p>// to logical coordinates, such as are stored in the document.</p>
    <p>OnPrepareDC(&amp;dc);</p>
    <p>dc.DPtoLP(&amp;point);</p>
    <p>m_pStrokeCur-&gt;m_pointArray.Add(point);</p>
    <p>// Draw a line from the previous detected point in the mouse</p>
    <p>// drag to the current point.</p>
    <p>CPen* pOldPen = dc.SelectObject(GetDocument()-&gt;GetCurrentPen());</p>
    <p>dc.MoveTo(m_ptPrev);</p>
    <p>dc.LineTo(point);</p>
    <p>dc.SelectObject(pOldPen);</p>
    <p>m_ptPrev = point;</p>
    <p>return;</p>
    <p>}</p>
    <p></font><font SIZE="3">至此，绘图程序的文档、视图全部设计完了，现在编译运行程序。程序启动后，在空白窗口中徒手绘图，如图</font><font FACE="Times New Roman" SIZE="3">8-7</font><font SIZE="3">所示。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p align="center"></font><img src="T8_7.gif" tppabs="http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/vc++5.0/chap8/T8_7.gif" alt="T8_7.tif (267124 bytes)" WIDTH="470" HEIGHT="335"><font FACE="Times New Roman" SIZE="4"><b></p>
    </b></font><p align="center"><font SIZE="3">图</font><font FACE="Times New Roman" SIZE="3">8-7 </font><font SIZE="3">多文档绘图程序窗口</font></p>
    <div align="center"><center><table border="0" cellpadding="0" cellspacing="0" width="615">
      <tr>
        <td><a href="chap8_2.htm" tppabs="http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/vc++5.0/chap8/chap8_2.htm">上一页</a></td>
        <td><p align="right"><a href="chap8_4.htm" tppabs="http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/vc++5.0/chap8/chap8_4.htm">下一页</a></td>
      </tr>
    </table>
    </center></div><font SIZE="5"><hr noshade color="#3973DE" size="1">
    <p align="center"></font><font size="2" color="#000000">本教程由<a href="javascript:if(confirm('http://vcdynasty.yeah.net/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://vcdynasty.yeah.net/'" tppabs="http://vcdynasty.yeah.net/">Visual C++王朝（Where programmers come together）</a>协助制作<br>
    未经许可，请勿以任何形式复制</font></td>
    <b>
  </tr>
</table>
</center></div>

<p ALIGN="CENTER"></b><font SIZE="5">　</font><font FACE="Times New Roman" SIZE="5"></p>
</font><font FACE="Times New Roman" SIZE="3">

<p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
</font></b>

<p><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>

<p></font>　</p>
</body>
</html>
