<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>MFC编程</title>
</head>

<body link="#3973DE" alink="#000000">
<font SIZE="5"><b><div align="center"><center>

<table border="0" width="615" cellspacing="0" cellpadding="0">
  <tr>
    </b><td><div align="center"><center><table border="0" width="615" cellpadding="0" cellspacing="0" height="13">
      <tr>
        <td width="363" bgcolor="#15397D" height="13"></td>
        <td width="252" bgcolor="#000000" height="13"><p align="right"></font><small><span style="text-decoration: none"><a href="javascript:if(confirm('http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/index.htm  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/index.htm'" tppabs="http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/index.htm"><font color="#FFFFFF">电脑报Visual 
        C++网络教程</font></a></span></small></td>
      </tr>
    </table>
    </center></div><font FACE="Times New Roman" SIZE="3"><p align="center"></font><font color="#3973DE"><font FACE="Times New Roman" size="4">2.4 MFC</font><font size="4">编程</font></font><font FACE="Times New Roman" size="4"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">微软基础类库（</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">：</font><font FACE="Times New Roman" SIZE="3">Microsoft Foundation Class</font><font SIZE="3">）是微软为</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">程序员提供的一个面向对象的</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">编程接口，它大大简化了</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">编程工作。使用</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">类库的好处是：首先，</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">提供了一个标准化的结构，这样开发人员不必从头设计创建和管理一个标准</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">应用程序所需的程序，而是“站在巨人肩膀上”，从一个比较高的起点编程，故节省了大量的时间；其次，它提供了大量的代码，指导用户编程时实现某些技术和功能。</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">库充分利用了</font><font FACE="Times New Roman" SIZE="3">Microsoft</font><font SIZE="3">开发人员多年开发</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">程序的经验，并可以将这些经验融入到你自己开发的应用程序中去。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">对用户来说，用</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">开发的最终应用程序具有标准的、熟悉的</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">界面，这样的应用程序易学易用；另外，新的应用程序还能立即支持所有标准</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">特性，而且是用普通的、明确定义的形式。事实上，也就是在</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">应用程序界面基础上定义了一种新的标准――</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">标准。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">为了更好的理解</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">，我们有必要了解一下</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">的历史。</font><font FACE="Times New Roman" SIZE="3"><b></p>
    <p></b>2.4.1 MFC</font><font SIZE="3">历史</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">开始，</font><font FACE="Times New Roman" SIZE="3">Microsoft</font><font SIZE="3">建立了一个</font><font FACE="Times New Roman" SIZE="3">AFX</font><font SIZE="3">小组，</font><font FACE="Times New Roman" SIZE="3">AFX</font><font SIZE="3">代表</font><font FACE="Times New Roman" SIZE="3">Application Framework</font><font SIZE="3">，即应用程序框架。据说创建该小组原意是为了发布一个</font><font FACE="Times New Roman" SIZE="3">Borland C++</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">OWL</font><font SIZE="3">的竞争性产品，因为那时侯</font><font FACE="Times New Roman" SIZE="3">Borland </font><font SIZE="3">公司的应用程序框架</font><font FACE="Times New Roman" SIZE="3">OWL(object Windows Language)</font><font SIZE="3">已经做的相当成功。</font><font FACE="Times New Roman" SIZE="3">AFX</font><font SIZE="3">小组象</font><font FACE="Times New Roman" SIZE="3">OWL</font><font SIZE="3">那样，提出了一个高度抽象</font><font FACE="Times New Roman" SIZE="3">Windows API</font><font SIZE="3">的一个类库。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">他们采用自顶向下的设计方法，逐步将对象抽象出来，并施加到</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">上。然后，他们试着花了几个月时间用这个类库来编写应用程序，结果发现这个类库偏离</font><font FACE="Times New Roman" SIZE="3">Windows API</font><font SIZE="3">实在太远，过分抽象并没有太大的实用性，相反大大降低了应用程序的效率。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">于是，他们干脆放弃了整个</font><font FACE="Times New Roman" SIZE="3">AFX</font><font SIZE="3">类库，对类库进行重新设计。这次，他们采用了自底向上的方法，从已有的</font><font FACE="Times New Roman" SIZE="3">Windows API</font><font SIZE="3">着手，将类建立在</font><font FACE="Times New Roman" SIZE="3">Windows API</font><font SIZE="3">对象基础上，设计出后来成为</font><font FACE="Times New Roman" SIZE="3">MFC1.0</font><font SIZE="3">的一个类库。但是，你现在仍然可以看到</font><font FACE="Times New Roman" SIZE="3">AFX</font><font SIZE="3">时期的痕迹，许多源程序文件有</font><font FACE="Times New Roman" SIZE="3">afx</font><font SIZE="3">前缀，如</font><font FACE="Times New Roman" SIZE="3">afxabort.cpp,afxmem.cpp</font><font SIZE="3">。</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">延用了许多</font><font FACE="Times New Roman" SIZE="3">AFX</font><font SIZE="3">类库的宏，因此我们经常会看到以</font><font FACE="Times New Roman" SIZE="3">AFX</font><font SIZE="3">开头的宏。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>AFX</font><font SIZE="3">小组实际上做了两件工作：</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">类库和对</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">IDE</font><font SIZE="3">支持</font><font FACE="Times New Roman" SIZE="3">(</font><font SIZE="3">即资源编译器和操作向导</font><font FACE="Times New Roman" SIZE="3">)</font><font SIZE="3">。在</font><font FACE="Times New Roman" SIZE="3">1994</font><font SIZE="3">年</font><font FACE="Times New Roman" SIZE="3">4</font><font SIZE="3">月份之后，</font><font FACE="Times New Roman" SIZE="3">AFX</font><font SIZE="3">的名字停止使用，该小组成员成为</font><font FACE="Times New Roman" SIZE="3">Visual C++</font><font SIZE="3">开发组的一部分，即现在的</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">小组。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>MFC1.0</font><font SIZE="3">版于</font><font FACE="Times New Roman" SIZE="3">1992</font><font SIZE="3">年同</font><font FACE="Times New Roman" SIZE="3">Microsoft C/C++7.0</font><font SIZE="3">同时发布。它提供了对</font><font FACE="Times New Roman" SIZE="3">Windows 
    API</font><font SIZE="3">简单的抽象和封装，还没有我们现在常用的文档</font><font FACE="Times New Roman" SIZE="3">/</font><font SIZE="3">视结构特性。但它引入了</font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3">，通过</font><font FACE="Times New Roman" SIZE="3">CArchive</font><font SIZE="3">的持续化和其他一些</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">中仍然使用的特性，从而奠定了</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">的基础。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY">MFC2.0</font><font SIZE="3">在</font><font FACE="Times New Roman" SIZE="3">MFC1.0</font><font SIZE="3">基础上增加了文档</font><font FACE="Times New Roman" SIZE="3">/</font><font SIZE="3">视结构框架、</font><font FACE="Times New Roman" SIZE="3">OLE1.0</font><font SIZE="3">类、消息映射和公用对话框类，废弃了</font><font FACE="Times New Roman" SIZE="3">1.0</font><font SIZE="3">版中的</font><font FACE="Times New Roman" SIZE="3">CModalDialog</font><font SIZE="3">类并将它的功能移入到</font><font FACE="Times New Roman" SIZE="3">CDialog</font><font SIZE="3">中，并增加了工具条、对话条、分割视窗的支持。</font><font FACE="Times New Roman" SIZE="3">MFC2.1</font><font SIZE="3">随同</font><font FACE="Times New Roman" SIZE="3">Visual C++ 1.1 for NT</font><font SIZE="3">发布，它把</font><font FACE="Times New Roman" SIZE="3">MFC2.0</font><font SIZE="3">移植到了</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">上。</font><font FACE="Times New Roman" SIZE="3">MFC2.5</font><font SIZE="3">随同</font><font FACE="Times New Roman" SIZE="3">Visual C++1.5</font><font SIZE="3">一起发布，它引入了</font><font FACE="Times New Roman" SIZE="3">OLE 2.0</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">ODBC</font><font SIZE="3">类。它是最后的官方的</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位发行版，于</font><font FACE="Times New Roman" SIZE="3">93</font><font SIZE="3">年</font><font FACE="Times New Roman" SIZE="3">12</font><font SIZE="3">月发布。目前，在开发</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">程序时，</font><font FACE="Times New Roman" SIZE="3">Visual C++1.5</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">MFC 2.5</font><font SIZE="3">仍然有大量的用户。随后的</font><font FACE="Times New Roman" SIZE="3">MFC2.51</font><font SIZE="3">、</font><font FACE="Times New Roman" SIZE="3">2.52</font><font SIZE="3">纠正了</font><font FACE="Times New Roman" SIZE="3">MFC.25</font><font SIZE="3">中的一些错误，增加了标签式对话框、</font><font FACE="Times New Roman" SIZE="3">WinSock</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">MAPI(Microsoft </font><font SIZE="3">电子邮件应用程序接口</font><font FACE="Times New Roman" SIZE="3">)</font><font SIZE="3">支持。</font><font FACE="Times New Roman" SIZE="3">MFC3.1</font><font SIZE="3">同</font><font FACE="Times New Roman" SIZE="3">Visual C++2.1</font><font SIZE="3">一起于</font><font FACE="Times New Roman" SIZE="3">1995</font><font SIZE="3">年</font><font FACE="Times New Roman" SIZE="3">1</font><font SIZE="3">月份发布，它引入了</font><font FACE="Times New Roman" SIZE="3">Windows95</font><font SIZE="3">公共控件（包括动画、热键、图象列表、工具条提示等等）。</font><font FACE="Times New Roman" SIZE="3">MFC4.0</font><font SIZE="3">于</font><font FACE="Times New Roman" SIZE="3">1995</font><font SIZE="3">年</font><font FACE="Times New Roman" SIZE="3">12</font><font SIZE="3">月份同</font><font FACE="Times New Roman" SIZE="3">Visual C++4.0</font><font SIZE="3">一起发布。</font><font FACE="Times New Roman" SIZE="3">Microsoft</font><font SIZE="3">直接从</font><font FACE="Times New Roman" SIZE="3">Visual C++2.0</font><font SIZE="3">一下子跳过一个版本号，升级到了</font><font FACE="Times New Roman" SIZE="3">4.0</font><font SIZE="3">，以保持</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">版本号和</font><font FACE="Times New Roman" SIZE="3">Visual C++</font><font SIZE="3">版本号的一致性，但这种一致性又在</font><font FACE="Times New Roman" SIZE="3">Visual C++5.0</font><font SIZE="3">中打破了。在</font><font FACE="Times New Roman" SIZE="3">MFC4.0</font><font SIZE="3">中增加了</font><font FACE="Times New Roman" SIZE="3">CSynchronize,CMutex,CEvent,CMultiLock,CShellNew</font><font SIZE="3">以更好的支持多线程以及</font><font FACE="Times New Roman" SIZE="3">Windows 
    95</font><font SIZE="3">的其他一些特性。</font><font FACE="Times New Roman" SIZE="3">Visual C++</font><font SIZE="3">还引入了</font><font FACE="Times New Roman" SIZE="3">Component Gallery</font><font SIZE="3">（组件画廊）、</font><font FACE="Times New Roman" SIZE="3">STL</font><font SIZE="3">支持和大量的新特性。</font><font FACE="Times New Roman" SIZE="3">MFC4.1</font><font SIZE="3">最重要的特性是支持</font><font FACE="Times New Roman" SIZE="3">Win32s</font><font SIZE="3">。许多</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">开发者一直都在使用该版本。</font><font FACE="Times New Roman" SIZE="3">MFC4.1</font><font SIZE="3">修正了</font><font FACE="Times New Roman" SIZE="3">4.0</font><font SIZE="3">的一些错误并增加了</font><font FACE="Times New Roman" SIZE="3">Internet</font><font SIZE="3">特性。</font><font FACE="Times New Roman" SIZE="3">MFC4.2</font><font SIZE="3">增加了</font><font FACE="Times New Roman" SIZE="3">ISAPI</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">OCX</font><font SIZE="3">容器支持。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>MFC4.21</font><font SIZE="3">于</font><font FACE="Times New Roman" SIZE="3">1997</font><font SIZE="3">年</font><font FACE="Times New Roman" SIZE="3">3</font><font SIZE="3">月</font><font FACE="Times New Roman" SIZE="3">19</font><font SIZE="3">日同</font><font FACE="Times New Roman" SIZE="3">Visual C++5.0</font><font SIZE="3">一起发布，它是目前最新和最完善的</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">版本。它只增加了对微软的</font><font FACE="Times New Roman" SIZE="3">IntelliMouse(</font><font SIZE="3">智能鼠标器</font><font FACE="Times New Roman" SIZE="3">)</font><font SIZE="3">的支持。现在</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">版本号又不与</font><font FACE="Times New Roman" SIZE="3">Visual C++</font><font SIZE="3">匹配了。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>MFC</font><font SIZE="3">发行版列表如下：</font><b><font FACE="Times New Roman" SIZE="3"></p>
    <p>MFC Release MSVC Release 16</font><font SIZE="3">位或</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位 备注 </font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>1.0 16 </font><font SIZE="3">简单的 封装</font><font FACE="Times New Roman" SIZE="3">Windows</p>
    <p>2.0 1.0 16 </font><font SIZE="3">增加了文档</font><font FACE="Times New Roman" SIZE="3">/</font><font SIZE="3">视结构</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>2.1 1.1 for NT 32 </font><font SIZE="3">第一个</font><font FACE="Times New Roman" SIZE="3">NT</font><font SIZE="3">的发行版 </font><font FACE="Times New Roman" SIZE="3"></p>
    <p>2.5 1.5 16 OLE/ODBC,</font><font SIZE="3">最后一个</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>16</font><font SIZE="3">位版本</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>2.51 2.0 16 </font><font SIZE="3">修正错误 </font><font FACE="Times New Roman" SIZE="3"></p>
    <p>2.52 2.1 16 </font><font SIZE="3">增加标签式对话框</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>2.52b 2.2 16</p>
    <p>2.5c 4.0 16</p>
    <p>3.0 2.0 32 </font><font SIZE="3">标签式对话框、可停泊工具条</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>3.1 2.1 32 Winsock/MAPI, Windows</font><font SIZE="3">公共控 制 </font><font FACE="Times New Roman" SIZE="3"></p>
    <p>3.2 2.2 32</p>
    <p>4.0 4.0 32 Win 95, </font><font SIZE="3">线程类</font><font FACE="Times New Roman" SIZE="3">, OCX </font><font SIZE="3">容器 </font><font FACE="Times New Roman" SIZE="3"></p>
    <p>4.1 4.1 32 sweeper (WinInet) classes</p>
    <p>**</font><font SIZE="3">以上是最后支持</font><font FACE="Times New Roman" SIZE="3">Win32s</font><font SIZE="3">的版本</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>4.2 4.2 32 </font><font SIZE="3">修正错误</font><font FACE="Times New Roman" SIZE="3">, ISAPI classes</p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>4.2b internet dl 32 </font><font SIZE="3">修正错误</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>4.21 5.0 32 IntelliMouse&amp;trade; support.</p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <b><p></b></font><font color="#3973DE" FACE="Times New Roman" SIZE="3">2.4.2 MFC</font><font SIZE="3" color="#3973DE">类库概念和组成</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">类库是一个可以在应用中使用的相互关联的</font><font FACE="Times New Roman" SIZE="3">C++</font><font SIZE="3">类的集合。类库有些随编译器提供，如</font><font FACE="Times New Roman" SIZE="3">Borland C++ Turbo Vision</font><font SIZE="3">等；有的是由其他软件公司销售，如用于数据库开发的</font><font FACE="Times New Roman" SIZE="3">CodeBase</font><font SIZE="3">；有的则是由用户自己开发的。比如图象处理类库完成图象显示、格式转换、量化等；串行通信类库用于支持串行口输入输出。有些情况下用户可以直接利用类库中包含的类定义应用程序所需的变量，有时则需要从类库所提供的类中派生出新的类，这依赖于类库的设计和具体的应用程序。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Microsoft</font><font SIZE="3">提供了一个基础类库</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">，其中包含用来开发</font><font FACE="Times New Roman" SIZE="3">C++</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">C++ Windows</font><font SIZE="3">应用程序的一组类。基础类库的核心是以</font><font FACE="Times New Roman" SIZE="3">C++</font><font SIZE="3">形式封装了大部分的</font><font FACE="Times New Roman" SIZE="3">Windows API</font><font SIZE="3">。类库表示窗口、对话框、设备上下文、公共</font><font FACE="Times New Roman" SIZE="3">GDI</font><font SIZE="3">对象如画笔、调色板、控制框和其他标准的</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">部件。这些类提供了一个面向</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">中结构的简单的</font><font FACE="Times New Roman" SIZE="3">C++</font><font SIZE="3">成员函数的接口。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>MFC</font><font SIZE="3">可分为两个主要部分：（</font><font FACE="Times New Roman" SIZE="3">1</font><font SIZE="3">）基础类（</font><font FACE="Times New Roman" SIZE="3">2</font><font SIZE="3">）宏和全程函数。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>MFC</font><font SIZE="3">基础类</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>MFC</font><font SIZE="3"><font SIZE="3">中的类按功能来分可划分为以下几类：</font><font FACE="Times New Roman" SIZE="3"></p>
    <blockquote>
      <p></font><font SIZE="3">基类</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">应用程序框架类</font><font FACE="Times New Roman" SIZE="3"></p>
      </font><p><font SIZE="3">应用程序类</font><font FACE="Times New Roman" SIZE="3"></p>
      </font><p><font SIZE="3">命令相关类</font><font FACE="Times New Roman" SIZE="3"></p>
      </font><p><font SIZE="3">文档</font></font><font FACE="Times New Roman" SIZE="3">/</font><font SIZE="3"><font SIZE="3">视类</font><font FACE="Times New Roman" SIZE="3"></p>
      </font><p><font SIZE="3">线程类</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">可视对象类</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">窗口类</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">视类</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">对话框类</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">属性表 </font></font><font FACE="Times New Roman" SIZE="3"></p>
      <font SIZE="3"><p></font><font SIZE="3">控制类</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      <p></font></font><font SIZE="3"><font SIZE="3">菜单类</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      <p></font></font><font SIZE="3"><font SIZE="3">设备描述表</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      <p></font></font><font SIZE="3"><font SIZE="3">绘画对象类</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      <p></font></font><font SIZE="3"><font SIZE="3">通用类</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      <p></font></font><font SIZE="3"><font SIZE="3">文件</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      <p></font></font><font SIZE="3"><font SIZE="3">诊断</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      <p></font></font><font SIZE="3"><font SIZE="3">异常</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      <p></font></font><font SIZE="3"><font SIZE="3">收集</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      <p></font></font><font SIZE="3"><font SIZE="3">模板收集</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      <p></font></font><font SIZE="3"><font SIZE="3">其他支持类</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      </font><p>OLE2</font><font SIZE="3"><font SIZE="3">类</font><font FACE="Times New Roman" SIZE="3"></p>
      </font><p>OLE基类<font FACE="Times New Roman" SIZE="3"></p>
      </font><p>OLE可视编辑包装程序类<font FACE="Times New Roman" SIZE="3"></p>
      </font><p>OLE 可视编辑服务器程序类<font FACE="Times New Roman" SIZE="3"></p>
      </font><p>OLE数据传输类<font FACE="Times New Roman" SIZE="3"></p>
      </font><p>OLE<font SIZE="3">对话框类</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">其他</font></font><font FACE="Times New Roman" SIZE="3">OLE</font><font SIZE="3"><font SIZE="3">类</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">数据库类</font><font FACE="Times New Roman" SIZE="3"></p>
      </font><b>
    </blockquote>
    <p><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">宏和全局函数</font></b></font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">若某个函数或变量不是某个类的一个成员，那么它是一个全程函数或变量。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Microsoft</font><font SIZE="3">基本宏和全程函数提供以下功能：</font><font FACE="Times New Roman" SIZE="3"></p>
    <blockquote>
      <blockquote>
        <font SIZE="3"><p></font><font SIZE="3">数据类型</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
        <p></font></font><font SIZE="3"><font SIZE="3">运行时刻对象类型服务</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
        <p></font></font><font SIZE="3"><font SIZE="3">诊断服务</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
        <p></font></font><font SIZE="3"><font SIZE="3">异常处理</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
        </font><p>CString</font><font SIZE="3"><font SIZE="3">格式化及信息框显示</font><font FACE="Times New Roman" SIZE="3"></p>
        <p></font><font SIZE="3">消息映射</font><font FACE="Times New Roman" SIZE="3"></p>
        <p></font><font SIZE="3">应用消息和管理</font><font FACE="Times New Roman" SIZE="3"></p>
        <p></font><font SIZE="3">对象连接和嵌入（</font></font><font FACE="Times New Roman" SIZE="3">OLE</font><font SIZE="3"><font SIZE="3">）服务</font><font FACE="Times New Roman" SIZE="3"></p>
        <p></font><font SIZE="3">标准命令和</font></font><font FACE="Times New Roman" SIZE="3">Windows IDs</p>
      </blockquote>
    </blockquote>
    <p></font><font SIZE="3"><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">约定</b>：全程函数以“</font></font><font FACE="Times New Roman" SIZE="3">Afx</font><font SIZE="3">”为前缀，所有全程变量都是以“</font><font FACE="Times New Roman" SIZE="3">afx</font><font SIZE="3">”为前缀，宏不带任何特别前缀，但是全部大写。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">常见的全局函数和宏有：</font><font FACE="Times New Roman" SIZE="3">AfxGetApp</font><font SIZE="3">，</font><font FACE="Times New Roman" SIZE="3">AfxGetMainWnd</font><font SIZE="3">，</font><font FACE="Times New Roman" SIZE="3">AfxMessageBox</font><font SIZE="3">，</font><font FACE="Times New Roman" SIZE="3">DEBUG_NEW</font><font SIZE="3">等，我们会在后面的章节中用到并对它们进行介绍。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">从继承关系来看，又可将</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">中的类分成两大类：大多数的</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">类是从</font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3">继承下来；另外一些类则不是从</font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3">类继承下来，这些类包括：字符串类</font><font FACE="Times New Roman" SIZE="3">CString</font><font SIZE="3">，日期时间类</font><font FACE="Times New Roman" SIZE="3">CTime</font><font SIZE="3">，矩形类</font><font FACE="Times New Roman" SIZE="3">CRect</font><font SIZE="3">，点</font><font FACE="Times New Roman" SIZE="3">CPoint</font><font SIZE="3">等，它们提供程序辅助功能。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">由于</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">中大部分类是从</font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3">继承下来的，</font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3">类描述了几乎所有的</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">中其他类的一些公共特性，因此我们有必要理解</font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3">类。 </font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">我们首先查看一下</font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3">类的定义，</font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3">类定义如下清单</font><font FACE="Times New Roman" SIZE="3">2.1</font><font SIZE="3">所示：</font><font SIZE="3" FACE="Times New Roman"></p>
    <p></font><b><font SIZE="3">　</font><font SIZE="3" FACE="Times New Roman"></p>
    <p></font><font SIZE="3"><font SIZE="3">清单</font></font><font FACE="Times New Roman" SIZE="3">2.1CObject</font><font SIZE="3">类的定义</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>// class CObject is the root of all compliant objects</p>
    <p>class CObject</p>
    <p>{</p>
    <p>public:</p>
    <p>// Object model (types, destruction, allocation)</p>
    <p>virtual CRuntimeClass* GetRuntimeClass() const;</p>
    <p>virtual ~CObject(); // virtual destructors are necessary</p>
    <p>// Diagnostic allocations</p>
    <p>void* PASCAL operator new(size_t nSize);</p>
    <p>void* PASCAL operator new(size_t, void* p);</p>
    <p>void PASCAL operator delete(void* p);</p>
    <p>#if defined(_DEBUG) &amp;&amp; !defined(_AFX_NO_DEBUG_CRT)</p>
    <p>// for file name/line number tracking using DEBUG_NEW</p>
    <p>void* PASCAL operator new(size_t nSize, LPCSTR lpszFileName, int nLine);</p>
    <p>#endif</p>
    <p>// Disable the copy constructor and assignment by default so you will get</p>
    <p>// compiler errors instead of unexpected behaviour if you pass objects</p>
    <p>// by value or assign objects.</p>
    <p>protected:</p>
    <p>CObject();</p>
    <p>private:</p>
    <p>CObject(const CObject&amp; objectSrc); // no implementation</p>
    <p>void operator=(const CObject&amp; objectSrc); // no implementation</p>
    <p>// Attributes</p>
    <p>public:</p>
    <p>BOOL IsSerializable() const;</p>
    <p>BOOL IsKindOf(const CRuntimeClass* pClass) const;</p>
    <p>// Overridables</p>
    <p>virtual void Serialize(CArchive&amp; ar);</p>
    <p>// Diagnostic Support</p>
    <p>virtual void AssertValid() const;</p>
    <p>virtual void Dump(CDumpContext&amp; dc) const;</p>
    <p>// Implementation</p>
    <p>public:</p>
    <p>static const AFX_DATA CRuntimeClass classCObject;</p>
    <p>#ifdef _AFXDLL</p>
    <p>static CRuntimeClass* PASCAL _GetBaseClass();</p>
    <p>#endif</p>
    <p>};</p>
    <p>CObject</font><font SIZE="3">类为派生类提供了下述服务：</font><font FACE="Times New Roman" SIZE="3"></p>
    <blockquote>
      <font SIZE="3"><p></font><font SIZE="3">对象诊断</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      </font><p>MFC</font><font SIZE="3"><font SIZE="3">提供了许多诊断特性，它可以：</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">输出对象内部信息：</font></font><font FACE="Times New Roman" SIZE="3">CDumpContext</font><font SIZE="3">类与</font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3">的成员函数</font><font FACE="Times New Roman" SIZE="3">Dump</font><font SIZE="3"><font SIZE="3">配合，用于在调试程序时输出对象内部数据。</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">对象有效性检查：重载基类的</font></font><font FACE="Times New Roman" SIZE="3">AssertValid</font><font SIZE="3"><font SIZE="3">成员函数，可以为派生类的对象提供有效性检查。</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">运行时访问类的信息：</font><font FACE="Times New Roman" SIZE="3"></p>
      </font><p ALIGN="JUSTIFY">MFC<font SIZE="3">提供了一个非常有用的特性，它可以进行运行时的类型检查。如果从</font></font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3">派生出一个类，并使用了以下三个宏</font><font FACE="Times New Roman" SIZE="3">(IMPLEMENT_DYNAMIC</font><font SIZE="3">，</font><font FACE="Times New Roman" SIZE="3">I<font FACE="Arial" SIZE="2">MPLEMENT_ DYNCREATE</font></font><font SIZE="3">或</font><font FACE="Times New Roman" SIZE="3">IMPLEMENT_SERIAL<font SIZE="3">)</font><font SIZE="3">之一，就可以：</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      <p></font></font><font SIZE="3"><font SIZE="3">运行时访问类名</font></font><font FACE="Times New Roman" SIZE="3"><font FACE="Times New Roman" SIZE="3"></p>
      <p></font></font><font SIZE="3"><font SIZE="3">安全可靠的把通用的</font></font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3"><font SIZE="3">指针转化为派生类的指针</font><font FACE="Times New Roman" SIZE="3"></p>
      </font><p>比如，我们定义一个主窗口类<font FACE="Times New Roman" SIZE="3"></p>
      </font><p>CMyFrame:public CFrameWnd</p>
      <p>{</p>
      <p>......</p>
      <p>}</p>
      <p>然后我们使用这个类：<font FACE="Times New Roman" SIZE="3"></p>
      </font><p>CMyFrame *pFrame=(CMyFrame*)AfxGetMainWnd();</p>
      <p>pFrame-&gt;DoSomeOperation();</p>
      <p ALIGN="JUSTIFY">AfxGetMainWnd<font SIZE="3">是一个全局函数，返回指向应用程序的主窗口的指针，类型为</font></font><font FACE="Times New Roman" SIZE="3">CWnd*</font><font SIZE="3">，因此我们必须对它进行强制类型转换，但我们如何知道是否转换成功了呢？我们可以使用</font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">IsKindOf()</font><font SIZE="3">成员函数检查</font><font FACE="Times New Roman" SIZE="3">pFrame</font><font SIZE="3"><font SIZE="3">的类型，用法如下：</font><font FACE="Times New Roman" SIZE="3"></p>
      </font><p>ASSERT(pFrame-&gt;IsKindOf(RUN_TIMECLASS(CMyFrame)))<font SIZE="3">；</font><font FACE="Times New Roman" SIZE="3"></p>
      </font><p><font SIZE="3">将上一语句插入到</font></font><font FACE="Times New Roman" SIZE="3">pFrame-&gt; DoSomeOperation()</font><font SIZE="3">之前，就可以在运行时作类型检查，当类型检查失败时，引发一个断言</font><font FACE="Times New Roman" SIZE="3">(ASSERT)</font><font SIZE="3"><font SIZE="3">，中断程序执行。</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">对象持续性</font><font FACE="Times New Roman" SIZE="3"></p>
      </font><p ALIGN="JUSTIFY"><font SIZE="3">通过与非</font></font><font FACE="Times New Roman" SIZE="3">CObject</font><font SIZE="3">派生的档案类</font><font FACE="Times New Roman" SIZE="3">CArchive</font><font SIZE="3">相结合，提供将多个不同对象以二进制形式保存到磁盘文件</font><font FACE="Times New Roman" SIZE="3">(Serilization)</font><font SIZE="3">中以及根据磁盘文件中的对象状态数据在内存中重建对象</font><font FACE="Times New Roman" SIZE="3">(Deserilization )</font><font SIZE="3"><font SIZE="3">的功能。</font><font FACE="Times New Roman" SIZE="3"></p>
      </font>
    </blockquote>
    <p><font SIZE="3">然而，</font></font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">不仅仅是一个类库，它还提供了一层建立在</font><font FACE="Times New Roman" SIZE="3">Windows API</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">C++</font><font SIZE="3">封装上的附加应用程序框架。该框架提供了</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">程序需要的多数公共用户界面。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">所谓应用程序框架指的是为了生成一般的应用所必须的各种软组件的集成。应用框架是类库的一种超集。一般的类库只是一种可以用来嵌入任何程序中的、提供某些特定功能（如图象处理、串行通信）的孤立的类的集合，但应用框架却定义了应用程序的结构，它的类既相互独立，又相互依赖，形成一个统一的整体，可以用来构造大多数应用程序。中国用户熟悉的</font><font FACE="Times New Roman" SIZE="3">Borland C++</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">DOS</font><font SIZE="3">下的</font><font FACE="Times New Roman" SIZE="3">Turbo Vision</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">下</font><font FACE="Times New Roman" SIZE="3">OWL(Object Windows Language)</font><font SIZE="3">都是应用框架的例子。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">下面我们举个具体的例子来说明</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">所提供的应用程序框架，程序如清单</font><font FACE="Times New Roman" SIZE="3">2.2</font><font SIZE="3"><font SIZE="3">。</font><b><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">清单</font></font><font FACE="Times New Roman" SIZE="3">2.2</font><font SIZE="3">应用程序框架示例</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>#include&lt;afxwin.h&gt;</p>
    <p>//derived an application class</p>
    <p>class CMinMFCApp:public CWinApp</p>
    <p>{</p>
    <p>public:</p>
    <p>BOOL InitInstance();</p>
    <p>};</p>
    <p>//Derive the main window class</p>
    <p>class CMainWindow:public CFrameWnd</p>
    <p>{</p>
    <p>public:</p>
    <p>CMainWindow();</p>
    <p>DECLARE_MESSAGE_MAP()</p>
    <p>};</p>
    <p>BEGIN_MESSAGE_MAP(CMainWindow,CFrameWnd)</p>
    <p>END_MESSAGE_MAP()</p>
    <p>/*CMinMFCApp Member Functions*/</p>
    <p>BOOL CMinMFCApp::InitInstance()</p>
    <p>{</p>
    <p>m_pMainWnd=new CMainWindow();</p>
    <p>m_pMainWnd-&gt;ShowWindow(m_nCmdShow);</p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>m_pMainWnd-&gt;UpdateWindow(); </p>
    <p>return TRUE;</p>
    <p>}</p>
    <p>/*CMainWindow member functions*/</p>
    <p>CMainWindow::CMainWindow()//constructor</p>
    <p>{</p>
    <p>Create(NULL,</p>
    <p>&quot;Min MFC Application&quot;,</p>
    <p>WS_OVERLAPPEDWINDOW,</p>
    <p>rectDefault,</p>
    <p>NULL,</p>
    <p>NULL);</p>
    <p>}</p>
    <p>/*an instance of type CMinMFCApp*/</p>
    <p>CMinMFCApp ThisApp;</p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">清单</font><font FACE="Times New Roman" SIZE="3">2.2</font><font SIZE="3">程序段定义了一个最小的</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">应用程序所需的框架程序。其中声明了</font><font FACE="Times New Roman" SIZE="3">CMinMFCApp</font><font SIZE="3">类，它是从应用程序类</font><font FACE="Times New Roman" SIZE="3">CWinApp</font><font SIZE="3">中派生下来的；和窗口</font><font FACE="Times New Roman" SIZE="3">CMainWindow</font><font SIZE="3">类，它是从框架窗口</font><font FACE="Times New Roman" SIZE="3">CFrameWnd</font><font SIZE="3">类派生出来。我们还用</font><font FACE="Times New Roman" SIZE="3">CMinMFCApp</font><font SIZE="3">定义了一个全局对象</font><font FACE="Times New Roman" SIZE="3">ThisApp</font><font SIZE="3">。读者也许会问，为什么没有</font><font FACE="Times New Roman" SIZE="3">WinMain</font><font SIZE="3">函数？因为</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">已经把它封装起来了。在程序运行时，</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">应用程序首先调用由框架提供的标准的</font><font FACE="Times New Roman" SIZE="3">WinMain</font><font SIZE="3">函数。在</font><font FACE="Times New Roman" SIZE="3">WinMain</font><font SIZE="3">函数中，首先初始化由</font><font FACE="Times New Roman" SIZE="3">CMinMFCApp</font><font SIZE="3">定义的唯一的实例，然后调用</font><font FACE="Times New Roman" SIZE="3">CMinMFCApp</font><font SIZE="3">继承</font><font FACE="Times New Roman" SIZE="3">CWinApp</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">Run</font><font SIZE="3">成员函数，进入消息循环。退出时调用</font><font FACE="Times New Roman" SIZE="3">CWinApp</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">ExitInstance</font><font SIZE="3">函数。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">由上面的说明可以看到，应用程序框架不仅提供了构建应用程序所需要的类</font><font FACE="Times New Roman" SIZE="3">(CWinApp</font><font SIZE="3">，</font><font FACE="Times New Roman" SIZE="3">CFrameWnd</font><font SIZE="3">等</font><font FACE="Times New Roman" SIZE="3">)</font><font SIZE="3">，还定义了程序的基本执行结构。所有的应用程序都在这个基本结构基础上完成不同的功能。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>MFC</font><font SIZE="3">除了定义程序执行结构之外，还定义了三种基本的主窗口模型：单文档窗口，多文档窗口和对话框作为主窗口。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY">Visual C++</font><font SIZE="3">提供了两个重要的工具，用于支持应用程序框架，它们就是前面提到</font><font FACE="Times New Roman" SIZE="3">AppWizard</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">ClassWizard</font><font SIZE="3">。</font><font FACE="Times New Roman" SIZE="3">AppWizard</font><font SIZE="3">用于在应用程序框架基础上迅速生成用户的应用程序基本结构。</font><font FACE="Times New Roman" SIZE="3">ClassWizard</font><font SIZE="3">用于维护这种应用程序结构。</font><font FACE="Times New Roman" SIZE="3"><b></p>
    <p></b></font><font color="#3973DE" FACE="Times New Roman" SIZE="3">2.4.3 MFC</font><font SIZE="3" color="#3973DE">的优点</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Microsoft MFC</font><font SIZE="3"><font SIZE="3">具有以下不同于其它类库的优势：</font><font FACE="Times New Roman" SIZE="3"></p>
    <blockquote>
      <p></font><font SIZE="3">完全支持</font></font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">所有的函数、控件、消息、</font><font FACE="Times New Roman" SIZE="3">GDI</font><font SIZE="3">基本图形函数，菜单及对话框。类的设计以及同</font><font FACE="Times New Roman" SIZE="3">API</font><font SIZE="3"><font SIZE="3">函数的结合相当合理。</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">使用与传统的</font></font><font FACE="Times New Roman" SIZE="3">Windows API</font><font SIZE="3"><font SIZE="3">同样的命名规则，即匈牙利命名法。</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">进行消息处理时，不使用易产生错误的</font></font><font FACE="Times New Roman" SIZE="3">switch/case</font><font SIZE="3">语句，所有消息映射到类的成员函数，这种直接消息到方法的映射对所有的消息都适用。它通过宏来实现消息到成员函数的映射，而且这些函数不必是虚拟的成员函数，这样不需要为消息映射函数生成一个很大的虚拟函数表</font><font FACE="Times New Roman" SIZE="3">(V</font><font SIZE="3">表</font><font FACE="Times New Roman" SIZE="3">)</font><font SIZE="3"><font SIZE="3">，节省内存。</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">通过发送有关对象信息到文件的能力提供更好的判定支持，也可确认成员变量。</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">支持异常错误的处理，减少了程序出错的机会</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">运行时确定数据对象的类型。这允许实例化时动态操作各域</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">有较少的代码和较快的速度。</font></font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">库只增加了少于</font><font FACE="Times New Roman" SIZE="3">40k</font><font SIZE="3">的目标代码，效率只比传统的</font><font FACE="Times New Roman" SIZE="3">C Windows</font><font SIZE="3">程序低</font><font FACE="Times New Roman" SIZE="3">5%</font><font SIZE="3"><font SIZE="3">。</font><font FACE="Times New Roman" SIZE="3"></p>
      <p></font><font SIZE="3">可以利用与</font></font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">紧密结合的</font><font FACE="Times New Roman" SIZE="3">AppWizard</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">ClassWizard</font><font SIZE="3">等工具快速开发出功能强大的应用程序。</font><font FACE="Times New Roman" SIZE="3"></p>
    </blockquote>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">另外，在使用</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">时还允许混合使用传统的函数调用。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">我们着重讲解一下</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">对消息的管理，这是编写</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">消息处理程序的基础。</font><font FACE="Times New Roman" SIZE="3"><b></p>
    <p></b></font><font color="#3973DE" FACE="Times New Roman" SIZE="3">2.4.4 MFC</font><font SIZE="3" color="#3973DE">对消息的管理</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Windows</font><font SIZE="3">消息的管理包括消息发送和处理。为了支持消息发送机制，</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">提供了三个函数：</font><font FACE="Times New Roman" SIZE="3">SendMessage</font><font SIZE="3">、</font><font FACE="Times New Roman" SIZE="3">PostMessage</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">SendDlgItemMessage</font><font SIZE="3">。而消息处理则相对来说显得复杂一些。</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">采用了一种新的机制取代</font><font FACE="Times New Roman" SIZE="3">C</font><font SIZE="3">语言编程时对</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">消息的</font><font FACE="Times New Roman" SIZE="3">Switch/Case</font><font SIZE="3">分支，简化了</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">编程，使程序可读性、可维护性大大提高。</font><b><font FACE="Times New Roman" SIZE="3"></p>
    <p>MFC</font><font SIZE="3">对消息的处理</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>MFC</font><font SIZE="3">不使用用</font><font FACE="Times New Roman" SIZE="3">C</font><font SIZE="3">语言编写</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">程序时用的易产生错误的</font><font FACE="Times New Roman" SIZE="3">switch/case</font><font SIZE="3">语句，而采用一种消息映射机制来决定如何处理特定的消息。这种消息映射机制包括一组宏，用于标识消息处理函数、映射类成员函数和对应的消息等。其中，用</font><font FACE="Times New Roman" SIZE="3">afx_msg</font><font SIZE="3">放在函数返回类型前面，用以标记它是一个消息处理成员函数。类若至少包含了一个消息处理函数，那么还需要加上一个</font><font FACE="Times New Roman" SIZE="3">DECLARE_MESSAGE_MAP()</font><font SIZE="3">宏，该宏对程序执行部分所定义的消息映射进行初始化。清单</font><font FACE="Times New Roman" SIZE="3">2.3</font><font SIZE="3"><font SIZE="3">演示了消息处理函数的例子：</font><b><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">清单</font></font><font FACE="Times New Roman" SIZE="3">2.3 </font><font SIZE="3">消息处理函数例子</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>class CMainFrame:CFrameWnd{</p>
    <p>public:</p>
    <p>CMainFrame();</p>
    <p>protected:</p>
    <p>//{{AFX_MSG(CMainFrame)</p>
    <p>afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);</p>
    <p>afx_msg void OnEditCopy();</p>
    <p>afx_msg void OnClose();</p>
    <p>//}}AFX_MSG</p>
    <p>DECLARE_MESSAGE_MAP()</p>
    <p>};</p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">成员函数</font><font FACE="Times New Roman" SIZE="3">OnCreate,OnEditCopy,OnClose</font><font SIZE="3">分别用来处理消息</font><font FACE="Times New Roman" SIZE="3">WM_CREATE</font><font SIZE="3">、</font><font FACE="Times New Roman" SIZE="3">ID_EDIT_COPY</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">WM_CLOSE</font><font SIZE="3">。其中，</font><font FACE="Times New Roman" SIZE="3">WM_CREATE</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">WM_CLOSE</font><font SIZE="3">是系统预定义消息，包含在</font><font FACE="Times New Roman" SIZE="3">Windows.h</font><font SIZE="3">中。而</font><font FACE="Times New Roman" SIZE="3">ID_EDIT_COPY</font><font SIZE="3">是菜单</font><font FACE="Times New Roman" SIZE="3">Edit-&gt;Copy</font><font SIZE="3">的标识，也就是用户选择</font><font FACE="Times New Roman" SIZE="3">Edit-&gt;Copy</font><font SIZE="3">菜单项时产生的消息，一般在资源文件头文件中定义。在类的实现部分给出这三个成员函数的定义，以及特殊的消息映射宏。上面的例子的消息映射宏定义如下：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>BEGIN_MESSAGE_MAP(CMainFrame,CFrameWnd)</p>
    <p>ON_WM_CREATE()</p>
    <p>ON_COMMAND(ID_EDIT_COPY, OnEditCopy)</p>
    <p>ON_WM_CLOSE()</p>
    <p>END_MESSAGE_MAP()</p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">消息映射宏由</font><font FACE="Times New Roman" SIZE="3">BEGIN_MESSAGE_MAP</font><font SIZE="3">（） 和</font><font FACE="Times New Roman" SIZE="3">END_MESSAGE_MAP()</font><font SIZE="3">。其中，</font><font FACE="Times New Roman" SIZE="3">BEGIN_MESSAGE_MAP</font><font SIZE="3">宏包含两个参数</font><font FACE="Times New Roman" SIZE="3">CMainFrame</font><font SIZE="3">类和</font><font FACE="Times New Roman" SIZE="3">CFrameWnd</font><font SIZE="3">，分别代表当前定义的类和它的父类。在</font><font FACE="Times New Roman" SIZE="3">BEGIN_MESSAGE_MAP</font><font SIZE="3">（）和</font><font FACE="Times New Roman" SIZE="3">END_MESSAGE_MAP()</font><font SIZE="3">之间，包含了主窗口要处理的各个</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">消息的入口。在本例中，包含三个消息。其中</font><font FACE="Times New Roman" SIZE="3">ON_ WM_CREATE</font><font SIZE="3">被用来指定缺省的成员函数</font><font FACE="Times New Roman" SIZE="3">OnCreate</font><font SIZE="3">与</font><font FACE="Times New Roman" SIZE="3">WM_CREATE</font><font SIZE="3">相对应。在</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">中，包含了大量的预定义消息映射宏，用来指定各种成员函数与各种形如</font><font FACE="Times New Roman" SIZE="3">WM_XXXX</font><font SIZE="3">消息相对应。如</font><font FACE="Times New Roman" SIZE="3">ON_WM_CLOSE</font><font SIZE="3">宏指定了</font><font FACE="Times New Roman" SIZE="3">WM_CLOSE</font><font SIZE="3">消息的处理成员函数为</font><font FACE="Times New Roman" SIZE="3">OnClose</font><font SIZE="3">。这时侯，只需要写出要处理的消息就够了，不必再写出处理函数。消息映射宏</font><font FACE="Times New Roman" SIZE="3">ON_COMMAND</font><font SIZE="3">则被用来将菜单项和用户自定义的命令同它们的处理成员函数联系起来。在上例中，用户选择</font><font FACE="Times New Roman" SIZE="3">Edit-&gt;Copy</font><font SIZE="3">菜单项时，系统执行</font><font FACE="Times New Roman" SIZE="3">OnEditCopy()</font><font SIZE="3">函数。</font><font FACE="Times New Roman" SIZE="3">ON_COMMAND</font><font SIZE="3">宏的一般定义形式如下：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>ON_COMMAND(command,command_function)</p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">其中，</font><font FACE="Times New Roman" SIZE="3">command</font><font SIZE="3">为菜单消息或用户自定义消息，</font><font FACE="Times New Roman" SIZE="3">command_function</font><font SIZE="3">为消息处理函数。</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">允许用户自定义消息，常量</font><font FACE="Times New Roman" SIZE="3">WM_USER</font><font SIZE="3">和第一个消息值相对应，用户必须为自己的消息定义相对于</font><font FACE="Times New Roman" SIZE="3">WM_USER</font><font SIZE="3">的偏移值，偏移范围在</font><font FACE="Times New Roman" SIZE="3">0~0x3FFF</font><font SIZE="3">之间，这对绝大多数程序来说都是够用的。用户可以利用</font><font FACE="Times New Roman" SIZE="3">#define</font><font SIZE="3">语句直接定义自己的消息：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>#define WM_USER1 (WM_USER+0)</p>
    <p>#define WM_USER2 (WM_USER+1)</p>
    <p>#define WM_USER3 (WM_USER+2)</p>
    <p></font><font SIZE="3">下表列出了</font><font FACE="Times New Roman" SIZE="3">Windows95</font><font SIZE="3">中</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">消息值的范围。</font><font FACE="Times New Roman" SIZE="3"></p>
    <table BORDER="1" CELLSPACING="2" BORDERCOLOR="#7f7f7f" CELLPADDING="1" WIDTH="400">
      <tr>
        <td WIDTH="19%"></font><font SIZE="3"><font SIZE="3">常 量</font></font><font FACE="Times New Roman" SIZE="3"></font></td>
        <td WIDTH="13%"><font SIZE="3">值</font><font FACE="Times New Roman" SIZE="3"></font></td>
        <td WIDTH="26%"><font SIZE="3">消息值范围</font><font FACE="Times New Roman" SIZE="3"></font></td>
        <td WIDTH="41%"><font SIZE="3">意 义</font><font FACE="Times New Roman" SIZE="3"></font></td>
      </tr>
      <tr>
        <td WIDTH="19%">WM_USER</td>
        <td WIDTH="13%">0x0400</td>
        <td WIDTH="26%">0x0000-0x03FF</td>
        <td WIDTH="41%">Windows<font SIZE="3">消息</font><font FACE="Times New Roman" SIZE="3"></font></td>
      </tr>
      <tr>
        <td WIDTH="19%"><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></font></td>
        <td WIDTH="13%"><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></font></td>
        <td WIDTH="26%">0x0400-0x7FFF</td>
        <td WIDTH="41%"><font SIZE="3">用户自定义的消息</font><font FACE="Times New Roman" SIZE="3"></font></td>
      </tr>
      <tr>
        <td WIDTH="19%"><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></font></td>
        <td WIDTH="13%"><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></font></td>
        <td WIDTH="26%">0x8000-0xBFFF</td>
        <td WIDTH="41%">Windows<font SIZE="3">保留值</font><font FACE="Times New Roman" SIZE="3"></font></td>
      </tr>
      <tr>
        <td WIDTH="19%"><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></font></td>
        <td WIDTH="13%"><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></font></td>
        <td WIDTH="26%">0xC000-0xFFFF</td>
        <td WIDTH="41%"><font SIZE="3">供应用使用的字符串消息</font><font FACE="Times New Roman" SIZE="3"></font></td>
      </tr>
    </table>
    <p><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">为了说明如何使用用户自定义消息，我们看一个例子，见程序清单</font><font FACE="Times New Roman" SIZE="3">2.4</font><font SIZE="3"><font SIZE="3">：</font><b><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">清单</font></font><font FACE="Times New Roman" SIZE="3">2.4 </font><font SIZE="3">使用用户自定义消息</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p>#include&lt;afxwin.h&gt;</p>
    <p>#define CM_APPLE (WM_USER+0)</p>
    <p>#define CM_ORANGE (WM_USER+1)</p>
    <p>class CMainFrame:CFrameWnd{</p>
    <p>public:</p>
    <p>CMainFrame();</p>
    <p>protected:</p>
    <p>afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);</p>
    <p>afx_msg void OnClose();</p>
    <p>//handle user select apple</p>
    <p>afx_msg LRESULT CMApple(WPARAM wParam, LPARAM lParam);</p>
    <p>//handle user select orange</p>
    <p>afx_msg LRESULT CMOrange(WPARAM wParam, LPARAM lParam);</p>
    <p>DECLARE_MESSAGE_MAP()</p>
    <p>};</p>
    <p></font><font SIZE="3">相应的消息映射如下：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>BEGIN_MESSAGE_MAP(CMainFrame,CFrameWnd)</p>
    <p>ON_WM_CREATE()</p>
    <p>ON_MESSAGE(CM_APPLE, CMApple)</p>
    <p>ON_MESSAGE(CM_ORANGE,CMOrange)</p>
    <p>ON_WM_CLOSE()</p>
    <p>END_MESSAGE_MAP()</p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">第一个</font><font FACE="Times New Roman" SIZE="3">ON_MESSAGE</font><font SIZE="3">宏用于指定 </font><font FACE="Times New Roman" SIZE="3">CM_APPLE </font><font SIZE="3">命令消息的处理成员函数为</font><font FACE="Times New Roman" SIZE="3">CMApple </font><font SIZE="3">，而第二个</font><font FACE="Times New Roman" SIZE="3">ON_MESSAGE</font><font SIZE="3">宏用于指定</font><font FACE="Times New Roman" SIZE="3">CM_ORANGE</font><font SIZE="3">命令消息的处理函数为</font><font FACE="Times New Roman" SIZE="3">CMOrange</font><font SIZE="3"><font SIZE="3">。</font><b><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">消息的发送</font></b></font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY">Windows</font><font SIZE="3">应用程序允许应用程序向自己发送消息、向其他应用程序发送消息，甚至可以向</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">操作系统本身发送消息（比如要求关闭操作系统或重新启动操作系统）。</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">提供了三个</font><font FACE="Times New Roman" SIZE="3">API</font><font SIZE="3">函数用于发送消息，这三个函数是：</font><font FACE="Times New Roman" SIZE="3">SendMessage</font><font SIZE="3">、</font><font FACE="Times New Roman" SIZE="3">PostMessage</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">SendDlgItemMessage</font><font SIZE="3">。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>SendMessage</font><font SIZE="3">用于向窗口发送消息，该函数说明如下：</font><font FACE="Times New Roman" SIZE="3"></p>
    <blockquote>
      <p>LRESULT SendMessage(</p>
    </blockquote>
    <p>HWND hWnd, //</font><font SIZE="3">消息要发往的窗口的句柄</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>UINT Msg, //</font><font SIZE="3">要发送的消息</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>WPARAM wParam, //</font><font SIZE="3">消息的第一个参数</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>LPARAM lParam //</font><font SIZE="3">消息的第二个参数</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>);</p>
    <p></font><font SIZE="3">其中，</font><font FACE="Times New Roman" SIZE="3">hWnd</font><font SIZE="3">为接收消息窗口的句柄，参数</font><font FACE="Times New Roman" SIZE="3">Msg</font><font SIZE="3">指定发送的消息，参数</font><font FACE="Times New Roman" SIZE="3">wParam</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">lParam</font><font SIZE="3">依赖于消息</font><font FACE="Times New Roman" SIZE="3">Msg</font><font SIZE="3">。该函数调用目标窗口的窗口函数，直到目标窗口处理完该消息才返回。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY">PostMessage</font><font SIZE="3">函数同</font><font FACE="Times New Roman" SIZE="3">SendMessage</font><font SIZE="3">类似，它把消息放在指定窗口创建的线程的消息队列中，然后不等消息处理完就返回，而不象</font><font FACE="Times New Roman" SIZE="3">SendMessage</font><font SIZE="3">那样必须等到消息处理完毕才返回。目标窗口通过</font><font FACE="Times New Roman" SIZE="3">GetMessage</font><font SIZE="3">或</font><font FACE="Times New Roman" SIZE="3">PeekMessage</font><font SIZE="3">从消息队列中取出并处理。</font><font FACE="Times New Roman" SIZE="3">PostMessage</font><font SIZE="3">函数说明如下：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <blockquote>
      <p>BOOL PostMessage(</p>
    </blockquote>
    <p>HWND hWnd, //</font><font SIZE="3">消息发往的窗口</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>UINT Ms<i>g</i>, //</font><font SIZE="3">要发送的消息</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>WPARAM wParam, //</font><font SIZE="3">消息的第一个参数</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>LPARAM lParam //</font><font SIZE="3">消息的第二个参数</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>);</p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">其中，参数</font><font FACE="Times New Roman" SIZE="3">hWnd</font><font SIZE="3">为接收消息的窗口的句柄，参数</font><font FACE="Times New Roman" SIZE="3">Msg</font><font SIZE="3">指定所发送的消息，参数</font><font FACE="Times New Roman" SIZE="3">wParam</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">lParam</font><font SIZE="3">依赖于消息</font><font FACE="Times New Roman" SIZE="3">Msg</font><font SIZE="3">。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>SendDlgItemMessage</font><font SIZE="3">函数用于向对话框的某个控制发送消息，函数声明如下：</font><font FACE="Times New Roman" SIZE="3"></p>
    <blockquote>
      <b><p></b>LONG SendDlgItemMessage(</p>
    </blockquote>
    <p>HWND hDlg, //</font><font SIZE="3">对话框句柄</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>int nIDDlgItem, //</font><font SIZE="3">对话框控件的</font><font FACE="Times New Roman" SIZE="3">ID</p>
    <p>UINT Msg, //</font><font SIZE="3">要发送的消息</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>WPARAM wParam, //</font><font SIZE="3">消息的第一个参数</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>LPARAM lParam //</font><font SIZE="3">消息的第二个参数</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>); </p>
    <p></font><font SIZE="3">其中，</font><font FACE="Times New Roman" SIZE="3">hDlg</font><font SIZE="3">为包含目标控制的对话框的窗口句柄，参数</font><font FACE="Times New Roman" SIZE="3">nIDDlgItem</font><font SIZE="3">为接收消息的对话框控制的整数标识符，参数</font><font FACE="Times New Roman" SIZE="3">Msg</font><font SIZE="3">指定了所发送的消息，参数</font><font FACE="Times New Roman" SIZE="3">wParam</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">lParam</font><font SIZE="3">提供附加的特定消息的信息。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>MFC</font><font SIZE="3">将这三个函数封装为</font><font FACE="Times New Roman" SIZE="3">CWnd</font><font SIZE="3"><font SIZE="3">类的成员函数，隐藏了窗口句柄和对话框句柄。这三个成员函数用于向本窗口发送消息，函数的说明如下：</font><font FACE="Times New Roman" SIZE="3"></p>
    <blockquote>
      <blockquote>
        </font><font FACE="Arial" SIZE="2"><b><p></b></font>LRESULT SendMessage( UINT message, 
        WPARAM wParam = 0, LPARAM lParam = 0 );</p>
        <font FACE="Arial" SIZE="2"><b><p></b></font>BOOL PostMessage( UINT message, WPARAM wParam 
        = 0, LPARAM lParam = 0 );</p>
        <p>LRESULT SendDlgItemMessage( int nID, UINT message, WPARAM wParam = 0, LPARAM lParam = 0 
        );</p>
      </blockquote>
    </blockquote>
    <b><p></b></font><font color="#3973DE" SIZE="3">2.4.5</font><font color="#3973DE"><font SIZE="3"><font SIZE="3">学习</font></font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">的方法</font></font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">首先要对</font><font FACE="Times New Roman" SIZE="3">Windows 
    API</font><font SIZE="3">有一定的了解，否则无法深入学习</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">。至少要知道</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">对程序员来说意味着什么，它能完成什么工作，它的一些常用数据结构等。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">另一点是不要过分依赖于</font><font FACE="Times New Roman" SIZE="3">Wizards</font><font SIZE="3">。</font><font FACE="Times New Roman" SIZE="3">Wizards</font><font SIZE="3">能做许多工作，但同时掩饰了太多的细节。应当看看</font><font FACE="Times New Roman" SIZE="3">AppWizard</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">ClassWizard</font><font SIZE="3">为你所做的工作。在</font><font FACE="Times New Roman" SIZE="3">mainfrm.cpp</font><font SIZE="3">中运行调试器来观察一下</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">运行的流程。除非你理解了生成的代码的含义，否则无法了解程序是如何运行。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">还有很重要的一点就是要学会抽象的把握问题，不求甚解。许多人一开始学习</font><font FACE="Times New Roman" SIZE="3">Visual C++</font><font SIZE="3">就试图了解整个</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">类库，实际上那几乎是不可能的。一般的学习方法是，先大体上对</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">有个了解，知道它的概念、组成、基本约定等。从最简单的类入手，由浅入深，循序渐进、日积月累的学习。一开始使用</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">提供的类时，只需要知道它的一些常用的方法、外部接口，不必要去了解它的细节和内部实现，把它当做一个模块或者说黑盒子来用，这就是一种抽象的学习方法。在学到一定程度时，再可以深入研究，采用继承的方法对原有的类的行为进行修改和扩充，派生出自己所需的类。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">学习</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">，最重要的一点是理解和使用</font><font FACE="Times New Roman" SIZE="3">MFC</font><font SIZE="3">类库，而不是记忆。</font><font FACE="Times New Roman" SIZE="3"><b></p>
    </b></font><div align="center"><center><table border="0" cellpadding="0" cellspacing="0" width="615">
      <tr>
        <td><a href="chap2_3.htm" tppabs="http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/vc++5.0/chap2/chap2_3.htm">上一页</a></td>
        <td><p align="right"><a href="chap2_5.htm" tppabs="http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/vc++5.0/chap2/chap2_5.htm">下一页</a></td>
      </tr>
    </table>
    </center></div><font SIZE="5"><hr noshade color="#3973DE" size="1">
    <p align="center"></font><font size="2" color="#000000">本教程由<a href="javascript:if(confirm('http://vcdynasty.yeah.net/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://vcdynasty.yeah.net/'" tppabs="http://vcdynasty.yeah.net/">Visual C++王朝（Where programmers come together）</a>协助制作<br>
    未经许可，请勿以任何形式复制</font></td>
    <b>
  </tr>
</table>
</center></div>

<p ALIGN="CENTER"></b><font SIZE="5">　</font><font FACE="Times New Roman" SIZE="5"></p>
</font><font FACE="Times New Roman" SIZE="3">

<p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
</font></b>

<p><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>

<p></font>　</p>
</body>
</html>
