<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title> WIN32开发</title>
</head>

<body link="#3973DE" alink="#3973DE">
<font SIZE="5"><b><div align="center"><center>

<table border="0" width="615" cellspacing="0" cellpadding="0">
  <tr>
    </b><td><div align="center"><center><table border="0" width="615" cellpadding="0" cellspacing="0" height="20">
      <tr>
        <td width="380" bgcolor="#15397D" height="20"></td>
        <td width="235" bgcolor="#000000" height="20"><p align="right"></font><small><span style="text-decoration: none"><a href="javascript:if(confirm('http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/index.htm  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/index.htm'" tppabs="http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/index.htm"><font color="#FFFFFF">电脑报Visual 
        C++网络教程</font></a></span></small></td>
      </tr>
    </table>
    </center></div><p align="center"><font size="4" color="#3973DE"><br>
    </font><font color="#3973DE"><font FACE="Times New Roman" size="5">2.3 WIN32</font><font size="5">开发</font></font></p>
    <font FACE="Times New Roman" size="5"><p ALIGN="JUSTIFY"></font><font FACE="Times New Roman" SIZE="3">Visual C++5.0</font><font SIZE="3">是一个全</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位的软件开发工具，它完全支持</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位的</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">平台开发。</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">平台包括</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位的</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">操作系统和软件开发系统</font><font FACE="Times New Roman" SIZE="3">Win32 API</font><font SIZE="3">。所谓</font><font FACE="Times New Roman" SIZE="3">API</font><font SIZE="3">（应用程序接口）指的是一组由操作系统提供的函数。</font><font FACE="Times New Roman" SIZE="3">Win32 API</font><font SIZE="3">是</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">平台上的一个</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位的软件开发系统，它使应用程序可以充分利用</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">操作系统的能力。使用</font><font FACE="Times New Roman" SIZE="3">Win32 API</font><font SIZE="3">写成的应用程序可以在</font><font FACE="Times New Roman" SIZE="3">Windows95</font><font SIZE="3">或更高版本以及</font><font FACE="Times New Roman" SIZE="3">Windows NT</font><font SIZE="3">上运行。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">由于</font><font FACE="Times New Roman" SIZE="3">Microsoft</font><font SIZE="3">在</font><font FACE="Times New Roman" SIZE="3">Windows 
    3.x</font><font SIZE="3">及其</font><font FACE="Times New Roman" SIZE="3">Win16 API</font><font SIZE="3">上取得巨大的成功，因此，在研制</font><font FACE="Times New Roman" SIZE="3">Win32 API</font><font SIZE="3">时，首先考虑的就是保证</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">与</font><font FACE="Times New Roman" SIZE="3">Win16 API</font><font SIZE="3">兼容，只有让软件开发者能将</font><font FACE="Times New Roman" SIZE="3">Win16</font><font SIZE="3">代码很容易移植到</font><font FACE="Times New Roman" SIZE="3">Win32 API</font><font SIZE="3">上，才有实际意义。</font><font FACE="Times New Roman" SIZE="3">Win32 API</font><font SIZE="3">在语法上只作了极小的改动，</font><font FACE="Times New Roman" SIZE="3">API</font><font SIZE="3">的命名与</font><font FACE="Times New Roman" SIZE="3">Windows </font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">Win16 API</font><font SIZE="3">相同，语义也相同，消息序号也相同。事实上，完全可以保存独立的源代码，并选择编译成</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位的</font><font FACE="Times New Roman" SIZE="3">Win16</font><font SIZE="3">程序或</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位的</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">程序。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">其次，如其名所示，在设计</font><font FACE="Times New Roman" SIZE="3">Win32 API</font><font SIZE="3">时考虑到了充分利用</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位处理器的能力。随着硬件的发展，内存和</font><font FACE="Times New Roman" SIZE="3">CPU</font><font SIZE="3">价格的降低和性能的提高，</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位</font><font FACE="Times New Roman" SIZE="3">CPU</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">486</font><font SIZE="3">、</font><font FACE="Times New Roman" SIZE="3">Pentium</font><font SIZE="3">已成为主流。据有关数据显示，目前在我国家用计算机用户中，使用</font><font FACE="Times New Roman" SIZE="3">Pentium</font><font SIZE="3">系列处理器的计算机已占</font><font FACE="Times New Roman" SIZE="3">80%</font><font SIZE="3">以上。如何充分利用当前</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位（和</font><font FACE="Times New Roman" SIZE="3">64</font><font SIZE="3">位）处理器的能力，并预见将来处理器的发展，就成为</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">设计时考虑的重要因素之一。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">再次，为了摆脱操作系统对</font><font FACE="Times New Roman" SIZE="3">Intel</font><font SIZE="3">处理器的依赖，使应用程序可以运行于各种处理器平台上，</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">设计时增强了它的可移植性，提供了</font><font FACE="Times New Roman" SIZE="3">Microsoft Windows95</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">Windows NT</font><font SIZE="3">之间的透明的移植能力。虽然</font><font FACE="Times New Roman" SIZE="3">Windows95</font><font SIZE="3">只能运行于</font><font FACE="Times New Roman" SIZE="3">Intel</font><font SIZE="3">平台上，但是</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">还支持</font><font FACE="Times New Roman" SIZE="3">Windows NT</font><font SIZE="3">，而</font><font FACE="Times New Roman" SIZE="3">Windows NT</font><font SIZE="3">已经被移植到许多非</font><font FACE="Times New Roman" SIZE="3">Intel</font><font SIZE="3">的处理器上，如</font><font FACE="Times New Roman" SIZE="3">Alpha</font><font SIZE="3">、</font><font FACE="Times New Roman" SIZE="3">RISC</font><font SIZE="3">硬件平台等。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Win32</font><font SIZE="3">可以应用于特定的操作系统，这种系统可以直接控制和处理</font><font FACE="Times New Roman" SIZE="3">PC</font><font SIZE="3">硬件资源，而不必象</font><font FACE="Times New Roman" SIZE="3">Win16 API</font><font SIZE="3">那样依赖于</font><font FACE="Times New Roman" SIZE="3">MS-DOS</font><font SIZE="3">系统服务。然而，</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">不是简单的由</font><font FACE="Times New Roman" SIZE="3">Win16</font><font SIZE="3">从</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位到</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位的升级，更重要的在于它支持：</font><font FACE="Times New Roman" SIZE="3"><ul>
      <li></font><font SIZE="3"><font SIZE="3">高性能的抢先式多任务和多线程</font></font><font FACE="Times New Roman" SIZE="3"></li>
      <li></font><font SIZE="3"><font SIZE="3">连续的</font></font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3"><font SIZE="3">位地址空间和先进的内存管理</font></li>
      <li><font SIZE="3">对所有的可为进程共享的对象，解决了它的安全性问题</font></li>
      <li><font SIZE="3">内存映射文件</font></li>
    </ul>
    </font><b><font FACE="Times New Roman" SIZE="3"><p></font></b><font color="#3973DE" FACE="Times New Roman" SIZE="3">2.3.1 </font><font SIZE="3" color="#3973DE">抢先式多任务和多线程</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">我们知道</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">是一个多任务操作系统，它提供了一次运行多个应用程序的能力。但是，</font><font FACE="Times New Roman" SIZE="3">Windows 3.x</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">Windows95</font><font SIZE="3">在多任务的实现上有所不同。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY">Windows 3.x</font><font SIZE="3">的多任务是一种由协作、软件方式产生的有限的非抢先式的多任务。它是借助于每个应用程序的消息循环这种软件协议方式来实现多任务的。</font><font FACE="Times New Roman" SIZE="3">Windows 3.x</font><font SIZE="3">管理所有的消息，并存放于系统的消息队列中。操作系统判断消息应归哪一个窗口去处理，再将消息发送给该窗口。每个应用程序窗口处于等待消息状态，直到有消息来，然后进行处理，处理完毕将控制权交给操作系统。在对消息进行处理时，对于用户用键盘或者鼠标输入的任何命令，</font><font FACE="Times New Roman" SIZE="3">Win16</font><font SIZE="3">都不会理睬。比如，我们用</font><font FACE="Times New Roman" SIZE="3">WORD</font><font SIZE="3">载入一个文件时，其他程序都得等待文件</font><font FACE="Times New Roman" SIZE="3">I/O</font><font SIZE="3">操作完成才能获得响应。而且，一个应用程序切换到另一个应用程序时，需要较长的等待时间。各应用程序在取得消息、处理消息时是平等的，无优先级的，系统无法设置应用程序的优先级和时间片的大小。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Windows95</font><font SIZE="3">的多任务是一种抢先式多任务。比如，我们在用资源管理器复制一个文件的同时，还可以启动另外一个应用程序，如纸牌游戏，而且随时都可以切换回资源管理器，察看文件复制进度，系统始终保持较好的响应和灵活性。</font><font FACE="Times New Roman" SIZE="3">Windows95</font><font SIZE="3">的抢先式多任务机制不是用</font><font FACE="Times New Roman" SIZE="3">Windows 3.x</font><font SIZE="3">下的软件调度来实现的。要了解抢先式多任务，我们需要首先了解一下进程和线程的概念。调入内存准备执行的应用程序叫做进程</font><font FACE="Times New Roman" SIZE="3">(process)</font><font SIZE="3">。每个进程至少有一条线程，叫做主线程（</font><font FACE="Times New Roman" SIZE="3">primary thread</font><font SIZE="3">）。一个进程包含代码、数据和其他属于应用程序的资源。一条线程包含一组指令，相关的</font><font FACE="Times New Roman" SIZE="3">CPU</font><font SIZE="3">寄存器值和一个堆栈。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">在抢先式多任务操作系统中，系统在所有运行的所有进程之间对</font><font FACE="Times New Roman" SIZE="3">CPU</font><font SIZE="3">时间进行共享，从而保证每个进程都能频繁的访问处理器，并且实现指令的连续执行。这样，每个</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">进程都需要分配一个优先级，系统调度程序利用这种优先级来决定哪一时刻该运行哪一个进程。具有高优先级的进程（严格的说应当是线程）就是当前运行的哪一个。更高优先级的线程可以中断当前进程的执行。同一优先级的线程通过时间片来调度。一个线程处于以下三种状态之一：正在执行，挂起，准备运行。在单处理器环境下（如</font><font FACE="Times New Roman" SIZE="3">Windows 95</font><font SIZE="3">），同一时刻只能运行一个线程。有关多线程，我们还将在后面的章节里作专门介绍。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">为了在</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">中支持多线程进程结构，</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">在原来</font><font FACE="Times New Roman" SIZE="3">Win16</font><font SIZE="3">基础上增加了：</font><font FACE="Times New Roman" SIZE="3"></p>
    <blockquote>
      </font><font SIZE="3"><p>对进程以及线程创建、操纵的支持</p>
      <p>对一个进程内线程之间的同步和同步对象的支持</p>
      <p>一个统一的共享机制。</p>
      </font><font FACE="Times New Roman" SIZE="3">
    </blockquote>
    <p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font></b><font color="#3973DE" FACE="Times New Roman" SIZE="3">2.3.2 </font><font SIZE="3" color="#3973DE">连续的地址空间和先进的内存管理</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">对于各种操作系统和平台来说，内存管理都是一个非常重要的问题。在</font><font FACE="Times New Roman" SIZE="3">Windows3.1</font><font SIZE="3">下，有两种形式的内存管理函数调用：局部的和全局的。全局内存管理函数从物理内存中分配一段，然后返回一个句柄值。该句柄可以转换为一个</font><font FACE="Times New Roman" SIZE="3">GlobalLock</font><font SIZE="3">函数所使用的远指针。基本处理过程如下：<ol>
      <li>申请一块可移动的内存块</li>
      <li>锁定该内存块。因为<font FACE="Times New Roman" SIZE="3">Windows</font>引入了虚拟内存管理，可以把内存块移动到硬盘交换文件中，所以在使用内存块之前，必须将它锁定在真正的内存<font FACE="Times New Roman" SIZE="3">RAM</font>之中，也就是告诉操作系统，现在这块内存暂时由应用程序来管理。</li>
      <li>对该内存块进行各种操作：如复制数据到内存块。</li>
      <li>解锁内存，应用程序将对该内存的控制交与<font FACE="Times New Roman" SIZE="3">Windows</font>。</font></li>
    </ol>
    <p><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">下面给出一个程序片段，来说明内存管理函数的用法。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>HGLOBAL memHandle;//</font><font SIZE="3">内存句柄</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>char far* lpMem;//</font><font SIZE="3">假设长度为</font><font FACE="Times New Roman" SIZE="3">memLen</p>
    <p>memHandle=GlobalAlloc(GHND,memLen+1);//</font><font SIZE="3">申请内存块，此处未做返回结果检查，</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>//</font><font SIZE="3">事实上，申请内存有时会失败</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>memcpy(lpMem,string,textLen);//</font><font SIZE="3">拷贝数据，其中</font><font FACE="Times New Roman" SIZE="3">string</font><font SIZE="3">为一字符串变量，</font><font FACE="Times New Roman" SIZE="3">textLen</font><font SIZE="3">是这个</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>//</font><font SIZE="3">字符串的长度</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>GlobalUnlock(memHandle);//</font><font SIZE="3">解锁内存</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>...</p>
    <p>GlobalFree((HGLOBAL) memHandle);//</font><font SIZE="3">释放内存</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">全局内存对所有的应用程序都是可见的，不管是显式的还是隐式的请求。因为</font><font FACE="Times New Roman" SIZE="3">Windows 3.x</font><font SIZE="3">的实现方式就是所有的进程在同一地址空间中运行。局部内存管理则是从</font><font FACE="Times New Roman" SIZE="3">64KB</font><font SIZE="3">的段内分配对象并返回所分配内存的</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位偏移量。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">在</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">下，局部和全局内存管理函数基本相同，仍然可以使用可移动和可丢弃选项。但是它引入了连续</font><font FACE="Times New Roman" SIZE="3">(flat)</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位内存管理概念。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">在</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">中，每个进程都有其特有的</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位虚拟地址空间，该空间最大可达</font><font FACE="Times New Roman" SIZE="3">4GB</font><font SIZE="3">。如图所示，低端内存的</font><font FACE="Times New Roman" SIZE="3">2GB</font><font SIZE="3">是用户可用的，高端内存的</font><font FACE="Times New Roman" SIZE="3">2GB</font><font SIZE="3">为内核</font><font FACE="Times New Roman" SIZE="3">(Kernel)</font><font SIZE="3">保留。其中，最高的</font><font FACE="Times New Roman" SIZE="3">1GB</font><font SIZE="3">用于</font><font FACE="Times New Roman" SIZE="3">VxD</font><font SIZE="3">、内存管理和文件系统。下面的</font><font FACE="Times New Roman" SIZE="3">1GB</font><font SIZE="3">用于共享的</font><font FACE="Times New Roman" SIZE="3">Win32 DLL</font><font SIZE="3">、内存映射文件和共享内存区域。进程所使用的虚拟地址不代表一个对象在内存的实际的物理位置（事实上，我们大部分的</font><font FACE="Times New Roman" SIZE="3">PC</font><font SIZE="3">还没有配置</font><font FACE="Times New Roman" SIZE="3">4GB</font><font SIZE="3">内存）。操作系统为每个进程维护一个映射表，根据该表将虚拟地址映射到真正的物理位置处（</font><font FACE="Times New Roman" SIZE="3">RAM</font><font SIZE="3">或者交换页文件中）。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="CENTER"></font><img src="T2_7.gif" tppabs="http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/vc++5.0/chap2/T2_7.gif" alt="T2_7.tif (136561 bytes)" WIDTH="385" HEIGHT="325"><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="CENTER"></font><font size="2">图<font FACE="Times New Roman">2.7 Windows95</font>的内存映射<font FACE="Times New Roman"></p>
    <p ALIGN="CENTER"></font></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">在</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">下局部内存对象有一个</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位句柄而不是</font><font FACE="Times New Roman" SIZE="3">Windows 3.x</font><font SIZE="3">下的</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位句柄，而且这个句柄是一个实际指针而不是一个相对于段的偏移量。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Win32</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">一个重要区别是：在</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">下，所有的进程都有自己独立的地址空间（在进程内部的线程仍然共享进程的内存变量），全局内存不再对所有的</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">应用程序都可见。由于每个应用程序都有自己的地址空间，一个进程分配的内存在该进程的地址之外就不再可见。</font><font FACE="Times New Roman" SIZE="3">DDE</font><font SIZE="3">会话中使用的内存对接收者进程来说是透明的。这样，进程的安全性就得到大大提高，程序更加强壮。一个进程崩溃一般不会影响另外一个进程的执行。但是，这也给多个应用程序共享内存带来了困难。在许多情况下，需要在多个应用程序之间进行通讯和数据交换，这时，该怎么办呢？</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">引入了内存映射文件，很好的解决了这个问题。</font><font FACE="Times New Roman" SIZE="3"><b></p>
    <p></b></font><font color="#3973DE" FACE="Times New Roman" SIZE="3">2.3.3</font><font SIZE="3" color="#3973DE">&nbsp; 内存映射文件</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">内存映射文件是由一个文件到一块内存的映射。</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">提供了允许应用程序把文件映射到一个进程的函数</font><font FACE="Times New Roman" SIZE="3">(CreateFileMapping)</font><font SIZE="3">。这样，文件内的数据就可以用内存读</font><font FACE="Times New Roman" SIZE="3">/</font><font SIZE="3">写指令来访问，而不是用</font><font FACE="Times New Roman" SIZE="3">ReadFile</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">WriteFile</font><font SIZE="3">这样的</font><font FACE="Times New Roman" SIZE="3">I/O</font><font SIZE="3">系统函数，从而提高了文件存取速度。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">这种函数最适用于需要读取文件并且对文件内包含的信息做语法分析的应用程序，如对输入文件进行语法分析的彩色语法编辑器，编译器等。把文件映射后进行读和分析，能让应用程序使用内存操作来操纵文件，而不必在文件里来回地读、写、移动文件指针。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">有些操作，如放弃“读”一个字符，在以前是相当复杂的，用户需要处理缓冲区的刷新问题。在引入了映射文件之后，就简单的多了。应用程序要做的只是使指针减少一个值。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">映射文件的另一个重要应用就是用来支持永久命名的共享内存。要在两个应用程序之间共享内存，可以在一个应用程序中创建一个文件并映射之，然后另一个应用程序可以通过打开和映射此文件把它作为共享的内存来使用。</font><font FACE="Times New Roman" SIZE="3"><b></p>
    <p></b></font><font color="#3973DE" FACE="Times New Roman" SIZE="3">2.3.4 Win32s</font><font color="#3973DE"><font SIZE="3">：</font><font FACE="Times New Roman" SIZE="3">Windows 3.x</font><font SIZE="3">对</font><font FACE="Times New Roman" SIZE="3">Win32 API</font><font SIZE="3">的支持</font></font><font FACE="Times New Roman" SIZE="3"></p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">我们经常会遇到</font><font FACE="Times New Roman" SIZE="3">Win32s</font><font SIZE="3">这个词，它与</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">是有区别的。</font><font FACE="Times New Roman" SIZE="3">Win32s</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">s</font><font SIZE="3">的含义是指子集（</font><font FACE="Times New Roman" SIZE="3">subset</font><font SIZE="3">）。它指的是，在一个</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">程序中移入一些</font><font FACE="Times New Roman" SIZE="3">DLLs</font><font SIZE="3">和一个</font><font FACE="Times New Roman" SIZE="3">VxD</font><font SIZE="3">，使它运行于配置</font><font FACE="Times New Roman" SIZE="3">80386</font><font SIZE="3">以上处理器的</font><font FACE="Times New Roman" SIZE="3">Windows 3.x</font><font SIZE="3">系统之上，并且以一种增强模式运行（但有一定限制）。运行在</font><font FACE="Times New Roman" SIZE="3">Windows 3.x/Win32s</font><font SIZE="3">系统上的</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">程序支持</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位指针和</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位寄存器，只需要在系统调用之前稍作形式替换。如果程序中使用大的数据结构或很多的计算时，</font><font FACE="Times New Roman" SIZE="3">Win32s</font><font SIZE="3">性能明显优于</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">版本，根据</font><font FACE="Times New Roman" SIZE="3">Microsoft</font><font SIZE="3">的测试，性能可以提高两倍左右；如果程序只是大量的调用</font><font FACE="Times New Roman" SIZE="3">Windows API</font><font SIZE="3">，则</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位版本的性能可能会强于</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位版本，因为</font><font FACE="Times New Roman" SIZE="3">Win32s</font><font SIZE="3">会对每一次</font><font FACE="Times New Roman" SIZE="3">API</font><font SIZE="3">调用作一个从</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位到</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位的转换。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Win32s</font><font SIZE="3">子集同</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">相比，不支持：多线程，高级图形</font><font FACE="Times New Roman" SIZE="3">API</font><font SIZE="3">，异步文件</font><font FACE="Times New Roman" SIZE="3">I/O</font><font SIZE="3">，</font><font FACE="Times New Roman" SIZE="3">Unicode</font><font SIZE="3">和安全性；而且它是运行于</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位的</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">系统上的。但是同</font><font FACE="Times New Roman" SIZE="3">Win16</font><font SIZE="3">相比，有它的优越之处，目前在</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">程序开发方面有相当的潜力。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Visual C++4.1</font><font SIZE="3">及以前版本支持</font><font FACE="Times New Roman" SIZE="3">Win32s</font><font SIZE="3">，但</font><font FACE="Times New Roman" SIZE="3">Visual C++5.0</font><font SIZE="3">不再支持</font><font FACE="Times New Roman" SIZE="3">Win32s</font><font SIZE="3">。</font><font FACE="Times New Roman" SIZE="3"></p>
    <b><p></b></font><font color="#3973DE" FACE="Times New Roman" SIZE="3">2.3.5 Win32</font><font SIZE="3" color="#3973DE">编程基础</font><b><font FACE="Times New Roman" SIZE="3"></p>
    <p>Win32</font><font SIZE="3">数据类型</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">这里的数据类型指的是一些关键字，这些关键字定义了</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">中的函数中的有关参数和返回值的大小和意义。</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">常用的数据类型有：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font>　</p>
    <table BORDER="1" CELLSPACING="2" BORDERCOLOR="#7f7f7f" CELLPADDING="1" WIDTH="557">
      <tr>
        <td WIDTH="16%"><font SIZE="3">数据类型</font></td>
        <td WIDTH="84%"><font SIZE="3">描述</font></td>
      </tr>
      <tr>
        <td WIDTH="16%"><font FACE="Times New Roman" SIZE="3">HANDLE</font></td>
        <td WIDTH="84%"><font SIZE="3">定义一个</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位无符号的整数，用作句柄</font></td>
      </tr>
      <tr>
        <td WIDTH="16%"><font FACE="Times New Roman" SIZE="3">HINSTANCE</font></td>
        <td WIDTH="84%"><font SIZE="3">定义一个</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位的无符号整数，用作实例句柄</font></td>
      </tr>
      <tr>
        <td WIDTH="16%"><font FACE="Times New Roman" SIZE="3">HWND</font></td>
        <td WIDTH="84%"><font SIZE="3">定义一个</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位的无符号整数，用作窗口句柄</font></td>
      </tr>
      <tr>
        <td WIDTH="16%"><font FACE="Times New Roman" SIZE="3">HDC</font></td>
        <td WIDTH="84%"><font SIZE="3">一个设备描述背景的句柄</font></td>
      </tr>
      <tr>
        <td WIDTH="16%"><font FACE="Times New Roman" SIZE="3">LONG</font></td>
        <td WIDTH="84%"><font SIZE="3">说明一个</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位带符号整数</font></td>
      </tr>
      <tr>
        <td WIDTH="16%"><font FACE="Times New Roman" SIZE="3">LPSTR</font></td>
        <td WIDTH="84%"><font SIZE="3">定义一个线性的</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位字符串指针</font></td>
      </tr>
      <tr>
        <td WIDTH="16%"><font FACE="Times New Roman" SIZE="3">UINT</font></td>
        <td WIDTH="84%"><font SIZE="3">定义一个新的</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">数据类型，它会把一个参数强制转换成</font><font FACE="Times New Roman" SIZE="3">Windows3.x</font><font SIZE="3">应用中的</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位值或</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">应用中的</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位</font></td>
      </tr>
      <tr>
        <td WIDTH="16%"><font FACE="Times New Roman" SIZE="3">WCHAR</font></td>
        <td WIDTH="84%"><font SIZE="3">说明一个</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位的</font><font FACE="Times New Roman" SIZE="3">UNICODE</font><font SIZE="3">字符，用来表示世界上所有已知的书写语言的符号</font></td>
      </tr>
    </table>
    <p><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">这里需要解释一下的是句柄。句柄是</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">编程的一个关键性的概念，编写</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">应用程序总是要和各种句柄打交道。所谓句柄，就是一个唯一的数，用以标识许多不同的对象类型，如窗口、菜单、内存、画笔、画刷、电话线路等。在</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">里，句柄是指向一个“无类型对象”</font><font FACE="Times New Roman" SIZE="3">(void*)</font><font SIZE="3">的指针，也就是一个</font><font FACE="Times New Roman" SIZE="3">4</font><font SIZE="3">字节长的数据。无论它的本质是什么，句柄并不是一个真正意义上的指针。从构造上看，句柄是一个指针，尽管它没有指向用于存储某个对象的内存位置。事实上，句柄指向一个包含了对该对象进行的引用的位置。句柄的声明是这样的：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>typedef void *HANDLE</p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">由于</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">是一个多任务操作系统，它可以同时运行多个程序或一个程序的多个副本。这些运行的程序称为一个实例。为了对同一程序的多个副本进行管理，</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">引入了实例句柄。</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">为每个应用程序建立一张表，实例句柄就好象是这张表的一个索引。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Windows</font><font SIZE="3">不仅使用句柄来管理实例，也用它来管理窗口、位图、字体、元文件、图标等系统资源。<b></p>
    <p>标识符命名</b></font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">在编程时，变量、函数的命名是一个极其重要的问题。好的命名方法使变量易于记忆且程序可读性大大提高。</font><font FACE="Times New Roman" SIZE="3">Microsoft</font><font SIZE="3">采用匈牙利命名法来命名</font><font FACE="Times New Roman" SIZE="3">Windows API</font><font SIZE="3">函数和变量。匈牙利命名法是由</font><font FACE="Times New Roman" SIZE="3">Microsoft</font><font SIZE="3">的著名开发人员、</font><font FACE="Times New Roman" SIZE="3">Excel</font><font SIZE="3">的主要设计者查尔斯&middot;西蒙尼在他的博士论文中提出来的，由于西蒙尼的国籍是匈牙利，所以这种命名法叫匈牙利命名法。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">匈牙利命名法为</font><font FACE="Times New Roman" SIZE="3">C</font><font SIZE="3">标识符的命名定义了一种非常标准化的方式，这种命名方式是以两条规则为基础的：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>1.</font><font SIZE="3">标识符的名字以一个或者多个小写字母开头，用这些字母来指定数据类型。下表列出了常用的数据类型的标准前缀：</p>
    <p ALIGN="CENTER">在</font><font FACE="Times New Roman" SIZE="3">Windows</font><font SIZE="3">里定义数据类型的一些标准前缀</font></p>
    <table BORDER="1" CELLSPACING="1" CELLPADDING="1" WIDTH="557">
      <tr>
        <td WIDTH="30%"><font SIZE="3"><p ALIGN="CENTER">前缀</font></td>
        <td WIDTH="70%"><font SIZE="3"><p ALIGN="CENTER">数据类型</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">c</font></td>
        <td WIDTH="70%"><font SIZE="3">字符（</font><font FACE="Times New Roman" SIZE="3">char</font><font SIZE="3">）</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">s</font></td>
        <td WIDTH="70%"><font SIZE="3">短整数（</font><font FACE="Times New Roman" SIZE="3">short</font><font SIZE="3">）</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">cb</font></td>
        <td WIDTH="70%"><font SIZE="3">用于定义对象（一般为一个结构）尺寸的整数</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">n</font></td>
        <td WIDTH="70%"><font SIZE="3">整数（</font><font FACE="Times New Roman" SIZE="3">integer</font><font SIZE="3">）</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">sz</font></td>
        <td WIDTH="70%"><font SIZE="3">以’</font><font FACE="Times New Roman" SIZE="3">\0</font><font SIZE="3">’结尾的字符串</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">b</font></td>
        <td WIDTH="70%"><font SIZE="3">字节</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">i</font></td>
        <td WIDTH="70%"><font FACE="Times New Roman" SIZE="3">int(</font><font SIZE="3">整数</font><font FACE="Times New Roman" SIZE="3">)</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">x</font></td>
        <td WIDTH="70%"><font SIZE="3">短整数（坐标</font><font FACE="Times New Roman" SIZE="3">x</font><font SIZE="3">）</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">y</font></td>
        <td WIDTH="70%"><font SIZE="3">短整数（坐标</font><font FACE="Times New Roman" SIZE="3">y</font><font SIZE="3">）</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">f</font></td>
        <td WIDTH="70%"><font FACE="Times New Roman" SIZE="3">BOOL</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">w</font></td>
        <td WIDTH="70%"><font SIZE="3">字</font><font FACE="Times New Roman" SIZE="3">(WORD</font><font SIZE="3">，无符号短整数</font><font FACE="Times New Roman" SIZE="3">)</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">l</font></td>
        <td WIDTH="70%"><font SIZE="3">长整数</font><font FACE="Times New Roman" SIZE="3">(long)</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">h</font></td>
        <td WIDTH="70%"><font FACE="Times New Roman" SIZE="3">HANDLE</font><font SIZE="3">（无符号</font><font FACE="Times New Roman" SIZE="3">int</font><font SIZE="3">）</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">m_</font></td>
        <td WIDTH="70%"><font SIZE="3">类成员变量</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">fn</font></td>
        <td WIDTH="70%"><font SIZE="3">函数</font><font FACE="Times New Roman" SIZE="3">(function)</font></td>
      </tr>
      <tr>
        <td WIDTH="30%"><font FACE="Times New Roman" SIZE="3">dw</font></td>
        <td WIDTH="70%"><font SIZE="3">双字</font><font FACE="Times New Roman" SIZE="3">(DWORD</font><font SIZE="3">，无符号长整数</font><font FACE="Times New Roman" SIZE="3">)</font></td>
      </tr>
    </table>
    <p><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>2.</font><font SIZE="3">在标识符内，前缀以后就是一个或者多个第一个字母大写的单词，这些单词清楚地指出了源代码内那个对象的用途。比如，</font><font FACE="Times New Roman" SIZE="3">m_szStudentName</font><font SIZE="3">表示一个学生名字的类成员变量，数据类型是字符串型。<b></p>
    <p>从</font><font FACE="Times New Roman" SIZE="3">16</font><font SIZE="3">位的</font><font FACE="Times New Roman" SIZE="3">Win16 API</font><font SIZE="3">迁移到</font><font FACE="Times New Roman" SIZE="3">Win32 API</font><font SIZE="3">注意点</font></b><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>1.</font><font SIZE="3">数据类型字长的变化：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">我们编写一个小程序来说明</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">下的常见数据类型的字长：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>#include&lt;windows.h&gt;</p>
    <p>#include&lt;stdio.h&gt;</p>
    <p>void main(void)</p>
    <p>{</p>
    <p>printf(&quot;sizeof(int) is %d\n&quot;,sizeof(int));</p>
    <p>printf(&quot;sizeof(BYTE) is %d\n&quot;,sizeof(BYTE));</p>
    <p>printf(&quot;sizeof(WORD) is %d\n&quot;,sizeof(WORD));</p>
    <p>printf(&quot;sizeof(DWORD) is %d\n&quot;,sizeof(DWORD));</p>
    <p>printf(&quot;sizeof(LONG) is %d\n&quot;,sizeof(LONG));</p>
    <p>printf(&quot;sizeof(PVOID) is %d\n&quot;,sizeof(PVOID));</p>
    <p>printf(&quot;sizeof(LPVOID) is %d\n&quot;,sizeof(LPVOID));</p>
    <p>}</p>
    <p></font><font SIZE="3">使用</font><font FACE="Times New Roman" SIZE="3">Visual C++</font><font SIZE="3">编译运行该程序，输出结果如下：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>sizeof(int) is 4</p>
    <p>sizeof(BYTE) is 1</p>
    <p>sizeof(WORD) is 2</p>
    <p>sizeof(DWORD) is 4</p>
    <p>sizeof(LONG) is 4</p>
    <p>sizeof(PVOID) is 4</p>
    <p>sizeof(LPVOID) is 4</p>
    <p ALIGN="JUSTIFY"></font><font SIZE="3">从上面的输出结果我们看到：整数类型字长已经同长整数相同，</font><font FACE="Times New Roman" SIZE="3">PVOID</font><font SIZE="3">近指针和</font><font FACE="Times New Roman" SIZE="3">LPVOID</font><font SIZE="3">远指针长度也相同。在编程过程中，我们要注意这些变化，凡是设计字长的问题最好还是采用可以移植的</font><font FACE="Times New Roman" SIZE="3">sizeof</font><font SIZE="3">操作符来做。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>2.</font><font SIZE="3">内存模式变化：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">在</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">平台下，不再有微模式、紧凑模式、中模式、大模式、巨模式、自定义内存模式之分，也不再有</font><font FACE="Times New Roman" SIZE="3">64KB</font><font SIZE="3">代码段和数据段的限制。只有一种内存模式，</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">下的地址和代码均在线性寻址的</font><font FACE="Times New Roman" SIZE="3">2GB</font><font SIZE="3">的</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位内存空间中。当然，编程时还是要考虑到实际内存限制的。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>3.</font><font SIZE="3">类型修饰符：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p></font><font SIZE="3">在</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">下，不再有远指针、近指针、巨型指针之分，三种指针类型完全相同。</font><font FACE="Times New Roman" SIZE="3">32</font><font SIZE="3">位的编译器会忽略所有的</font><font FACE="Times New Roman" SIZE="3">_near</font><font SIZE="3">、</font><font FACE="Times New Roman" SIZE="3">_far</font><font SIZE="3">、</font><font FACE="Times New Roman" SIZE="3">_huge</font><font SIZE="3">关键字并一视同仁来处理。在</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">中，象</font><font FACE="Times New Roman" SIZE="3">LPSTR</font><font SIZE="3">和</font><font FACE="Times New Roman" SIZE="3">PSTR</font><font SIZE="3">这种类型是等价的。</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>4.</font><font SIZE="3">函数的变化：</font><font FACE="Times New Roman" SIZE="3"></p>
    <p>Win32API</font><font SIZE="3">设计时尽可能保证与</font><font FACE="Times New Roman" SIZE="3">Win16API</font><font SIZE="3">兼容，但是仍然对一些函数作了修改。比如在</font><font FACE="Times New Roman" SIZE="3">Win16</font><font SIZE="3">下的</font><font FACE="Times New Roman" SIZE="3">MoveTo</font><font SIZE="3">在</font><font FACE="Times New Roman" SIZE="3">Win32</font><font SIZE="3">下为</font><font FACE="Times New Roman" SIZE="3">MoveToEx</font><font SIZE="3">。如果在编译程序时某个</font><font FACE="Times New Roman" SIZE="3">API</font><font SIZE="3">函数没找到，试着在这个函数名后面加上</font><font FACE="Times New Roman" SIZE="3">Ex</font><font SIZE="3">，</font><font FACE="Times New Roman" SIZE="3">Ex</font><font SIZE="3">表示它是</font><font FACE="Times New Roman" SIZE="3">Win16</font><font SIZE="3">的扩展。 </font><font FACE="Times New Roman" SIZE="3"></p>
    </font><div align="center"><center><table border="0" cellpadding="0" cellspacing="0" width="615">
      <tr>
        <td><a href="chap2_2.htm" tppabs="http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/vc++5.0/chap2/chap2_2.htm">上一页</a></td>
        <td><p align="right"><a href="chap2_4.htm" tppabs="http://www.lzu.edu.cn/netteach/jiaochen/vc++5.0/vc++5.0/chap2/chap2_4.htm">下一页</a></td>
      </tr>
    </table>
    </center></div><font SIZE="5"><hr noshade color="#3973DE" size="1">
    <p align="center"></font><font size="2" color="#000000">本教程由<a href="javascript:if(confirm('http://vcdynasty.yeah.net/  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://vcdynasty.yeah.net/'" tppabs="http://vcdynasty.yeah.net/">Visual C++王朝（Where programmers come together）</a>协助制作<br>
    未经许可，请勿以任何形式复制</font></td>
    <b>
  </tr>
</table>
</center></div>

<p ALIGN="CENTER"></b><font SIZE="5">　</font><font FACE="Times New Roman" SIZE="5"></p>
</font><font FACE="Times New Roman" SIZE="3">

<p></font><b><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>
</font></b>

<p><font SIZE="3">　</font><font FACE="Times New Roman" SIZE="3"></p>

<p></font>　</p>
</body>
</html>
