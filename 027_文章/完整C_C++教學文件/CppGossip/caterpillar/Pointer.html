<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>








  
  
  
  
  
  <link rel="stylesheet" href="stdlayout.css" tppabs="http://caterpillar.onlyfun.net/Gossip/CppGossip/css/stdlayout.css" type="text/css">






  
  
  
  
  
  <link rel="stylesheet" href="print.css" tppabs="http://caterpillar.onlyfun.net/Gossip/CppGossip/css/print.css" type="text/css">






  
  
  
  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type"><title>指標與記憶體位址</title></head><body>






<h3><a href="javascript:if(confirm('http://caterpillar.onlyfun.net/Gossip/index.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://caterpillar.onlyfun.net/Gossip/index.html'" tppabs="http://caterpillar.onlyfun.net/Gossip/index.html">From
Gossip@caterpillar</a></h3>






<h1><a href="CppGossip.html" tppabs="http://caterpillar.onlyfun.net/Gossip/CppGossip/CppGossip.html">C++
Gossip:&nbsp;指標與記憶體位址</a></h1>






<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">






  <tbody>






    <tr>






      <td style="width: 676px; vertical-align: top;"> <small>在 <a href="Variable.html" tppabs="http://caterpillar.onlyfun.net/Gossip/CppGossip/Variable.html">變
數</a> 中曾經說過，
變數（Variable）提供一個有名稱的記憶體儲存空間，一個變數關係至一個資料型態、一個變數本身的值與一個變數的位址值。<br>





      <br>






變數資料型態決定了變數所分配到的記憶體大小；變數本身的值是指儲存於記憶體中的某個數值，而您可以透過變數名稱取得這個數值，這個數值又稱為
rvalue或
read
value；而變數的位址值則是指變數所分配到的記憶體之位置，變數本身又稱為lvalue或
location value。<br>





      <br>






如果您想知道變數的記憶體位址為何，您可以使用&amp;運算子，&amp;是「取址運算子」（Address-of
operator），它可以取出變數的記憶體位址，例如： </small>

      <br>






      <br>






      
      
      
      
      
      <pre>#include &lt;iostream&gt; <br>using namespace std; <br><br>int main() { <br>    int var = 10; <br><br>    cout &lt;&lt; "變數var的值：" &lt;&lt; var <br>         &lt;&lt; endl; <br>    cout &lt;&lt; "變數var的記憶體位址：" &lt;&lt; &amp;var <br>         &lt;&lt; endl; <br> <br>    return 0; <br>}<br></pre>






      <br>





      <small>
執行結果： </small><br>






      <small> </small><small> </small><small>
      </small><small> </small><small>
      </small>
      
      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






        <tbody>






          <tr>






            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">變數var的值：10<br>






變數var的記憶體位址：0x22ff74</span><span style="color: rgb(255, 255, 255);"></span></small></td>






          </tr>






        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>






      <br>





      <small>
這個程式中，您宣告了一個int整數變數var，var指向的記憶體位址是0x22ff74，這是記憶體位址的16進位表示法，從 0x22ff74後的4個位元組都是var所配置到的記憶體空間，現在這個空間中儲存值為10。<br>





      <br>






直接存取變數即直接對所分配到的記憶體空間作存取，指標（Pointer）則提供了間接性，指標可指向特定的記憶體位址，而不直接操作變數或物件，要宣告
一個指標，使用以下的語法：<br>





      </small>

      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">type
*ptr;</span><br>






      </small></div>






      <small><br>






其中type是指標的型態，每一個指標都有一個相對應的型態，用以指出所指向的資料或物件之型態有所不同，編譯器根據指標型態來確定特定記憶體位址上的資
料如何解釋，以及如何進行指標運算（Pointer arithmetic），以下是幾個指標宣告的範例：<br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int
*iptr;</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">float
*fptr;</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">char
*cptr;</span><br>






      </small></div>






      <small><br>






您可以使用&amp;運算子取出變數的位址值並指定給指標，例如：</small><br>






      <br>






      
      
      
      
      
      <pre>#include &lt;iostream&gt; <br>using namespace std; <br><br>int main() { <br>    int var = 10; <br>    int *ptr = &amp;var ; <br><br>    cout &lt;&lt; "變數var的位址：" &lt;&lt; &amp;var <br>         &lt;&lt; endl; <br>    cout &lt;&lt; "指標ptr指向的位址：" &lt;&lt; ptr <br>         &lt;&lt; endl; <br> <br>    return 0; <br>}<br></pre>






      <small><br>






執行結果： </small><br>






      <small> </small><small> </small><small>
      </small><small> </small><small>
      </small>
      
      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






        <tbody>






          <tr>






            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">變數var的位址：0x22ff74<br>






指標ptr指向的位址：0x22ff74</span><span style="color: rgb(255, 255, 255);"></span></small></td>






          </tr>






        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>






      <br>





      <small>
如以上的程式結果所示，您使用&amp;來取出變數var所指向的記憶體位址，然後將這個位址指定給指標ptr，因此ptr所儲存的值就與
&amp;
var所取出的值相同。 <br>





      <br>






指標擁有兩種操作特性，一是操作指標所儲存的位址，一是操作指標所指向位址之資料，或是操作指向的位址上之物件，您可以使用提取
（Dereference）運算子*來提取指標所指向位址的資料，例如：</small>
      <br>






      <br>






      
      
      
      
      
      <pre>#include &lt;iostream&gt; <br>using namespace std; <br><br>int main() { <br>    int var = 10; <br>    int *ptr = &amp;var;<br><br>    cout &lt;&lt; "指標ptr儲存的值：" &lt;&lt; ptr<br>         &lt;&lt; endl; <br>    cout &lt;&lt; "取出ptr指向的記憶體位置之值：" &lt;&lt; *ptr <br>         &lt;&lt; endl;<br> <br>    return 0; <br>}<br></pre>






      <br>





      <small>
執行結果： </small><br>






      <small> </small><small> </small><small>
      </small><small> </small><small>
      </small>
      
      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






        <tbody>






          <tr>






            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">指標ptr儲存的值：0x22ff74<br>






取出ptr指向的記憶體位置之值：10</span><span style="color: rgb(255, 255, 255);"></span></small></td>






          </tr>






        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>






      <br>





      <small>
如果已經取得了記憶體位置，當將某個值指定給*ptr時，該記憶體位置的值也會跟著改變，相當於告訴程式，將值放到ptr所指向的記憶體位址，例如： <br>





      </small>
      <br>






      
      
      
      
      
      <pre>#include &lt;iostream&gt; <br>using namespace std; <br><br>int main() { <br>    int var = 10; <br>    int *ptr = &amp;var ; <br><br>    cout &lt;&lt; "var = " &lt;&lt; var <br>         &lt;&lt; endl; <br>    cout &lt;&lt; "*ptr = " &lt;&lt; *ptr <br>         &lt;&lt; endl; <br><br>    *ptr = 20; <br><br>    cout &lt;&lt; "var = " &lt;&lt; var <br>         &lt;&lt; endl;<br>    cout &lt;&lt; "*ptr = " &lt;&lt; *ptr <br>         &lt;&lt; endl;<br> <br>    return 0; <br>}<br></pre>






      <br>





      <small>
執行結果： </small><br>






      <small> </small><small> </small><small>
      </small><small> </small><small>
      </small>
      
      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






        <tbody>






          <tr>






            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">var = 10<br>






*ptr = 10<br>






var = 20<br>






*ptr = 20</span><span style="color: rgb(255, 255, 255);"></span></small></td>






          </tr>






        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>






      <br>





      <small>
如以上所表示的，當指標ptr所儲存的值與變數var所指向的記憶體位置相同時，當您對*ptr進行指定的動作時，就會將值直接存入該記憶體位置，因此再
透過變數var所取出的值也就改變了。 <br>





      <br>






如果宣告指標但不指定初值，則指標指向的位址是未知的，存取未知位址的記憶體內容是危險的，例如：<br>





      </small>

      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int
*ptr; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">*ptr
= 10;</span><br>






      </small></div>






      <small><br>





      <br>






這個程式片段並未初始指標就指定值給*ptr，所以會造成不可預知的結果（通常是記憶體區段錯誤），最好為指標設定初值，如果指標一開始不指向任何的物
件，則可設定初值為0，表示不指向任何物件，例如：<br>





      </small>

      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int
*iptr = 0;</span><br>






      </small></div>






      <small><br>






在這邊必須注意一個指標宣告常犯的錯誤，在指標宣告時，可以靠在名稱旁邊，也可以靠在關鍵字旁邊，例如： <br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int
*ptr1; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int*
ptr2;</span><br>






      </small></div>






      <small><br>






這兩個宣告方式都是可允許的，一般比較傾向用第一個，因為可以避免以下的錯誤：<br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int*
ptr1, ptr2;</span><br>






      </small></div>






      <small><br>






這樣的宣告方式，初學者可能以為ptr2也是指標，但事實上並不是，以下的宣告ptr1與ptr2才都是指標：<br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int
*ptr1, *ptr2;</span><br>






      </small></div>






      <small><br>






有時候，您只希望儲存記憶體的位址，然後將之與另一個記憶體位址作比較，這時並不需要關心型態的問題，您可以使用void*來宣告指標，例如： <br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">void*
ptr;</span><br>






      </small></div>






      <small><br>






由於void型態的指標沒有任何的型態資訊，所以只用來持有位址資訊，您不可以使用*運算子對void型態指標提取值，而必須使用
reinterpret_cast作轉型動作至對應的型態，例
如</small>：<br>






      <br>






      
      
      
      
      
      <pre>#include &lt;iostream&gt; <br>using namespace std; <br><br>int main() { <br>    int var = 10; <br>    void *vptr = &amp;var ; <br> <br>    // 下面這句不可行，void型態指標不可取值 <br>    //cout &lt;&lt; *vptr &lt;&lt; endl;<br> <br>    // 轉型為int型態指標並指定給iptr <br>    int *iptr = reinterpret_cast&lt;int*&gt;(vptr);<br>    cout &lt;&lt; *iptr &lt;&lt; endl; <br> <br>    return 0; <br>}<br></pre>






      <br>





      <small>
執行結果： </small><br>






      <small> </small><small> </small><small>
      </small><small> </small><small>
      </small>
      
      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






        <tbody>






          <tr>






            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">10</span><span style="color: rgb(255, 255, 255);"></span></small></td>






          </tr>






        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>






      <br>





      <small>
您也可以使用舊風格的轉型語法，如下所示：<br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int
var = 10; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">void
*vptr =
&amp;var ; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">//
轉型為int型態指標並指定給iptr </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int
*iptr =
(int*)(vptr);</span><br>






      </small></div>






      <small><br>






順便來看一下const宣告的變數，被const宣告的變數一但被指定值，就不能再改變變數的值，您也無法對該變數如下取值：<br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">const
int var = 10;</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">var
= 20; //
error,&nbsp;assignment of read-only variable `var' </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int
*ptr =
&amp;var; // error,&nbsp; invalid conversion from `const int*'
to
`int*' </span><br>






      </small></div>






      <small><br>






用const宣告的變數，必須使用對應的const型態指標才可以：<br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">const
int var = 10;</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">const
int *vptr =
&amp;var;</span><br>






      </small></div>






      <small><br>






同樣的vptr所指向的記憶體中的值一但指定，就不能再改變記憶體中的值，您不能如下試圖改變所指向記憶體中的資料：<br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">*vptr
= 20; // error,
assignment of read-only location </span><br>






      </small></div>






      <small><br>






另外還有指標常數，也就是您一旦指定給指標值，就不能指定新的記憶體位址值給它，例如：<br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-family: Courier New,Courier,monospace; font-weight: bold;">int
x = 10;</span><br style="font-family: Courier New,Courier,monospace; font-weight: bold;">






      <span style="font-family: Courier New,Courier,monospace; font-weight: bold;">
int y = 20;</span><br style="font-family: Courier New,Courier,monospace; font-weight: bold;">






      <span style="font-family: Courier New,Courier,monospace; font-weight: bold;">
int* const vptr = &amp;x;</span><br style="font-family: Courier New,Courier,monospace; font-weight: bold;">






      <span style="font-family: Courier New,Courier,monospace; font-weight: bold;">
vptr = &amp;x; &nbsp;// error,&nbsp; assignment of
read-only variable `vptr' </span><br>






      </small></div>






      <small><span style="font-style: italic;"><span style="font-weight: bold;"><br>






      </span></span>
在某些情況下，您會想要改變唯讀區域的值，這時您可以使用const_cast改變指標的型態，例如：</small><br>






      <br>






      
      
      
      
      
      <pre>#include &lt;iostream&gt; <br>using namespace std; <br><br>void foo(const int*); <br> <br>int main() { <br>    int var = 10; <br> <br>    cout &lt;&lt; "var = " &lt;&lt; var &lt;&lt; endl; <br> <br>    foo(&amp;var); <br> <br>    cout &lt;&lt; "var = " &lt;&lt; var &lt;&lt; endl; <br> <br>    return 0; <br>}<br><br>void foo(const int* p) {<br>    int* v = const_cast&lt;int*&gt; (p); <br>    *v = 20; <br>}<br></pre>






      <br>





      <small>
由於函式（Function）定義中傳入的指標使用const加上唯讀性，所以您不能對傳入的指標進行以下的動作：<br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">*p
= 20; // error, assignment
of read-only location</span><span style="font-weight: bold; font-style: italic;"> </span></small></div>






      <small><br>






但在某種原因下，您真的必須改變指標指向的位址處之資料，則您可以使用const_cast改變指標的唯讀性，<br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int*
v =
const_cast&lt;int*&gt; (p); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">*v
= 20; </span><br>






      </small></div>






      <small><br>






執行結果： </small><br>






      <small> </small><small> </small><small>
      </small><small> </small><small>
      </small>
      
      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






        <tbody>






          <tr>






            <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">var = 10<br>






var = 20</span></small></td>






          </tr>






        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>






      <br>





      <small>
您也可以使用舊風格的轉型語法，例如：<br>





      </small>
      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">void
foo(const
int* p) {</span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;
int* v = (int*) (p); </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">&nbsp;&nbsp;&nbsp;
*v = 20; </span><br style="font-weight: bold; font-family: Courier New,Courier,monospace;">






      <span style="font-weight: bold; font-family: Courier New,Courier,monospace;">}</span><br>






      </small></div>






      <small><br>






關於函式的定義與使用，在之後還會介紹。</small> </td>






      <td style="width: 250px; text-align: center; vertical-align: top;"><comment title=" adsense for content" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment>&nbsp;
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      <script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>

      <comment title=" adsense for content end" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment><br>

      <comment title=" adsense for content" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment>
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      <script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script><comment title=" adsense for content end" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment><br>

      <br>
      <center>
      <script language="javascript" src="showads.aspx-blogid=20070509000002&charset=big5" tppabs="http://ad2.bloggerads.net/showads.aspx?blogid=20070509000002&charset=big5"></script><br>

      </center>

 </td>






    </tr>






  
  
  
  
  
  </tbody>
</table>






<br>






<script src="urchin.js" tppabs="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script>
</body></html>