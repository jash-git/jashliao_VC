<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>













  
  
  
  
  
  
  
  
  
  
  <link rel="stylesheet" href="stdlayout.css" tppabs="http://caterpillar.onlyfun.net/Gossip/CGossip/css/stdlayout.css" type="text/css">











  
  
  
  
  
  
  
  
  
  
  <link rel="stylesheet" href="print.css" tppabs="http://caterpillar.onlyfun.net/Gossip/CGossip/css/print.css" type="text/css">











  
  
  
  
  
  
  
  
  
  
  <meta content="text/html; charset=Big5" http-equiv="content-type"><title>邏輯（Logical）運算、位元（Bitwise）運算</title></head><body>











<h3><a href="javascript:if(confirm('http://caterpillar.onlyfun.net/Gossip/index.html  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://caterpillar.onlyfun.net/Gossip/index.html'" tppabs="http://caterpillar.onlyfun.net/Gossip/index.html">From
Gossip@caterpillar</a></h3>











<h1><a href="CGossip.html" tppabs="http://caterpillar.onlyfun.net/Gossip/CGossip/CGossip.html">C&nbsp;Gossip: 邏輯（Logical）運算、位元（Bitwise）運算</a></h1>











<table style="text-align: left; width: 946px; height: 32px;" border="0" cellpadding="0" cellspacing="0">











  <tbody>











    <tr>











      <td style="width: 676px; vertical-align: top;"> <small>

在邏輯上有所謂的「且」、「或」與「反」運算，在C中也提供這幾個基本邏輯運算所需的「邏輯運算子」（Logical
operator），分別為「且」（&amp;&amp;）、「或」（||）及「反相」（!）三個運算子。 <br>





      <br>







來看看下面這個程式會輸出什麼？ <br>





      </small>



      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">int num = 75;<br>



printf("%d\n", (num &gt; 70 &amp;&amp; num &lt; 80));<br>



printf("%d\n", (num &gt; 80 || num &lt; 75));<br>



printf("%d\n", !(num &gt; 80 || num &lt; 75));</span><span style="font-weight: bold; font-family: Courier New,Courier,monospace;"></span><br>







      </small></div>







      <small><br>







三段程式分別會輸出1、0與1，也就是分別表示真、假與真三種狀況。 <br>





      <br>







&amp;&amp;運算中，如果左邊的式子已經被評斷為假，則可立即判斷整個式子為假，因而右邊的式子就不會再評斷；
|| 運算中如果左邊的式子已經被評斷為真，則可以判斷整個式子為真，因而右邊的式子就不會再評斷。<br>





      <br>







接下來看看「位元運算子」（Bitwise
operator），數位設計上有AND、OR、NOT、XOR與補數等運算，在C中提供這些運算的就是位元運算子，它們的對應分別是AND
（&amp;）、OR（|）、NOT（!）、XOR（^）與補數（~）。 <br>





      <br>







如果您不會基本的位元運算，這邊可以提供一個程式來顯示各個運算的結果：<br>



      </small>
      
      
      
      <pre>#include &lt;stdio.h&gt;<br><br>int main(void) {<br>    puts("AND運算：");<br>    printf("0 AND 0\t\t%d\n", 0 &amp; 0);<br>    printf("0 AND 1\t\t%d\n", 0 &amp; 1);<br>    printf("1 AND 0\t\t%d\n", 1 &amp; 0);<br>    printf("1 AND 1\t\t%d\n\n", 1 &amp; 1);<br><br>    puts("OR運算：");<br>    printf("0 OR 0\t\t%d\n", 0 | 0);<br>    printf("0 OR 1\t\t%d\n", 0 | 1);<br>    printf("1 OR 0\t\t%d\n", 1 | 0);<br>    printf("1 OR 1\t\t%d\n\n", 1 | 1);<br>    <br>    puts("XOR運算：");<br>    printf("0 XOR 0\t\t%d\n", 0 ^ 0);<br>    printf("0 XOR 1\t\t%d\n", 0 ^ 1);<br>    printf("1 XOR 0\t\t%d\n", 1 ^ 0);<br>    printf("1 XOR 1\t\t%d\n\n", 1 ^ 1);<br><br>    puts("NOT運算：");<br>    printf("NOT 0\t\t%d\n", !0);<br>    printf("NOT 1\t\t%d\n\n", !1);<br>    <br>    return 0;<br>}</pre>










      <span class="postbody"><br>



      </span><small>

執行結果如下： </small><br>







      
      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">







  <tbody>







    <tr>







      <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">AND運算：<br>



0 AND 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>



0 AND 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>



1 AND 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>



1 AND 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br>



            <br>



OR運算：<br>



0 OR 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>



0 OR 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br>



1 OR 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br>



1 OR 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br>



            <br>



XOR運算：<br>



0 XOR 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>



0 XOR 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br>



1 XOR 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br>



1 XOR 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>



            <br>



NOT運算：<br>



NOT 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1<br>



NOT 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0<br>







      </span></small></td>







    </tr>







  
        
        
        
        
        
        </tbody>
      
      
      
      
      
      </table>







      <br>





      <small>

C中的位元運算是逐位元運算的，例如10010001與01000001作AND運算，是一個一個位元對應運算，答案就是00000001；而補數運
算是將所有的位元0變1，1變0，例如00000001經補數運算就會變為11111110，例如下面這個程式所示： <br>





      </small>

      
      
      
      
      
      <div style="margin-left: 40px;"><small><span style="font-weight: bold; font-family: Courier New,Courier,monospace;">char num = 255;<br>



printf("%d\n", ~num);</span><span style="font-weight: bold; font-family: Courier New,Courier,monospace;"></span><br>







      </small></div>







      <small><br>







這段程式會在主控台顯示0，char使用一個位元組，若用於儲存正整數最大可儲存255的值，255的二進位表示法為11111111，經補數運算就是
00000000，也就是0。 <br>





      <br>







要注意的是，邏輯運算子與位元運算子也是很常被混淆的，像是&amp;&amp;為邏輯運算，而&amp;為位元運算，||為邏
輯運算，而|為位元運算，
初學時可得多注意。 <br>



      <br></small><small>位元運算對初學者來說的確較不常用，但如果用的洽當的話，可以增進不少程式效率，例如下面這個程式可以判斷使用者的輸入是否為奇數：</small>



      <br>







      
      
      <pre>#include &lt;stdio.h&gt;<br><br>int main(void) {<br>    int input = 0; <br><br>    printf("輸入正整數："); <br>    scanf("%d", &amp;input); <br>    printf("輸入為奇數？%c\n", (input&amp;1 ? 'Y' : 'N'));<br>    <br>    return 0;<br>}</pre>



      <span class="postbody"><br>

      </span><small>

執行結果如下： </small><br>






      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">輸入正整數：5<br>






輸入為奇數？Y<br>






      </span></small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>




      <small>

這個程式得以運算的原理是，奇數的數值若以二進位來表示，其最右邊的位元必為1，而偶數最右邊的位元必為0，所以您使用1來與輸入的值作AND運算，由於
1除了最右邊的位元為1之外，其它位元都會是0，與輸入數值AND運算的結果，只會留下最右邊位元為0或為的結果，其它部份都被0
AND運算遮掉了，這就是所謂「位元遮罩」，例如：</small><br>






      
      
      
      
      <table style="text-align: left; width: 25%;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000100</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>4</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000001</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>1</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000000</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>判
斷為偶數</small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>






      <br>






      
      
      
      
      <table style="text-align: left; width: 25%;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000011</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>3</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000001</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>1</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000001</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>判
斷為奇數</small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>






      <br>




      <small>

XOR的運算較不常見，這邊舉個簡單的XOR字元加密例子，先看看程式：</small><br>






      
      <pre>#include &lt;stdio.h&gt;<br><br>int main(void) {<br>    char ch = 'A'; <br><br>    printf("before encoding：%c\n", ch);<br><br>    ch = ch^0x7; <br>    printf("after encoding：%c\n", ch);<br><br>    ch = ch^0x7; <br>    printf("decoding：%c\n", ch);<br><br>    return 0;<br>}</pre>

      <span class="postbody"><br>

      </span><small>

執行結果如下： </small><br>






      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">before encoding：A<br>






after encoding：F<br>






decoding：A<br>






      </span></small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>




      <small>

0x7是C中整數的16進位寫法，其實就是10進位的7，將位元與1作XOR的作用其實就是位元反轉，0x7的最右邊三個位元為1，所以其實就是反轉
ch 的最後兩個字元，如下所示：</small><br>






      
      
      
      
      <table style="text-align: left; width: 273px;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>01000001</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace; width: 191px;"><small>65
（對應
ASCII的'A'）</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000111</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace; width: 191px;"><small>0x7</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>01000110</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace; width: 191px;"><small>70
（對應
ASCII中的'F'）</small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>




      <small>

同樣的，這個簡單的XOR字元加密，要解密也只要再進行相同的位元反轉就可以了。 <br>




      <br>






要注意的是，雖然在說明時都只取8個位元來說明，但實際的位元在運算時，需依資料型態所佔的記憶體長度而定，例如在使用int型態的0作運算時，要考慮的
是32個位元，而不是只有8個位元，因為int佔有4個位元組。 <br>




      <br>






在位元運算上，C還有左移（&lt;&lt;）與右移（&gt;&gt;）兩個運算子，左移運算子會將所有的位元往左移指定的位數，左邊被擠出去的位元會被丟棄，而右邊會補上0；右移運算則
是相反，會將所有
的位元往右移指定的位數，右邊被擠出去的位元會被丟棄，至於左邊位元補0或補1則不一定，視系統而定。 <br>




      <br>






您可以使用左移運算來作簡單的2次方運算示範，如下所示： <br>

      </small>
      
      <pre>#include &lt;stdio.h&gt;<br><br>int main(void) {<br>    int num = 1; <br><br>    printf("2的0次：%d\n", num);<br><br>    num = num &lt;&lt; 1; <br>    printf("2的1次：%d\n", num);<br><br>    num = num &lt;&lt; 1; <br>    printf("2的2次：%d\n", num);<br><br>    num = num &lt;&lt; 1; <br>    printf("2的3次：%d\n", num);<br><br>    return 0;<br>}</pre>

      <small><br>

      </small><small>

執行結果如下： </small><br>






      
      
      
      
      <table style="text-align: left; width: 100%;" border="0" cellpadding="2" cellspacing="2">






  <tbody>






    <tr>






      <td style="background-color: rgb(0, 0, 0);"><small><span style="color: rgb(255, 255, 255);">2的0次：1<br>






2的1次：2<br>






2的2次：4<br>






2的3次：8<br>






      </span></small></td>






    </tr>






  
        
        
        
        
        </tbody>
      
      
      
      
      </table>






      <br>




      <small>

實際來左移看看就知道為何可以如此運算了： </small><br>






      
      
      




  




    
      
      <table style="text-align: left; width: 25%;" border="0" cellpadding="2" cellspacing="2">

        <tbody>

          <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000001</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>1</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000010</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>2</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00000100</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>4</small></td>






    </tr>






    <tr>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>00001000</small></td>






      <td style="font-weight: bold; font-family: Courier New,Courier,monospace;"><small>8</small></td>

          </tr>

        
        </tbody>
      
      </table>

      <br>

      <small><br>

      <br>

      </small> </td>











      <td style="width: 250px; text-align: center; vertical-align: top;"><comment title=" adsense for content" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment>&nbsp;
      
      
      
      
      
      
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->
      </script>
      
      
      
      
      
      
      <script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js">
      </script><br>







      <comment title=" adsense for content end" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment><br>







      <comment title=" adsense for content" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment>
      
      
      
      
      
      
      <script type="text/javascript"><!--
google_ad_client = "pub-9750319131714390";
google_ad_width = 160;
google_ad_height = 600;
google_ad_format = "160x600_as";
google_ad_type = "text_image";
google_ad_channel = "";
//-->&#160;</script>&nbsp;
      
      
      
      
      
      
      <script type="text/javascript" src="show_ads.js" tppabs="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script><comment title=" adsense for content end" xmlns="http://disruptive-innovations.com/zoo/nvu"></comment><br>







      <br>






      
      
      
      
      
      
      <center>
      
      
      
      
      
      
      <script language="javascript" src="showads.aspx-blogid=20070509000002&charset=big5" tppabs="http://ad2.bloggerads.net/showads.aspx?blogid=20070509000002&charset=big5"></script><br>







      </center>







 </td>











    </tr>











  
  
  
  
  
  
  
  
  
  
  </tbody>
</table>











<br>










<span class="postbody"><br>











<br>











</span>
<script src="urchin.js" tppabs="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-143766-1";
urchinTracker();
</script>
</body></html>