<html lang="zh-TW"><head><meta charset="UTF-8" /><link rel="stylesheet" href="style.css" tppabs="http://www.csie.ntnu.edu.tw/~u91029/style.css" />
<title>演算法筆記 - Graph</title></head><body>
<div class="a"><div class="h">
<p class="b">Graph Operation</p>
<p class="r">程度★★　難度★★</p>
</div><div class="c">
<p class="t">Canonization</p>
<p><a href="javascript:if(confirm('http://en.wikipedia.org/wiki/Graph_canonization  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://en.wikipedia.org/wiki/Graph_canonization'" tppabs="http://en.wikipedia.org/wiki/Graph_canonization">http://en.wikipedia.org/wiki/Graph_canonization</a></p>
<p class="t">Isomorphism</p>
<p><a href="javascript:if(confirm('http://en.wikipedia.org/wiki/Graph_isomorphism  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://en.wikipedia.org/wiki/Graph_isomorphism'" tppabs="http://en.wikipedia.org/wiki/Graph_isomorphism">http://en.wikipedia.org/wiki/Graph_isomorphism</a></p>
<p><a href="javascript:if(confirm('http://en.wikipedia.org/wiki/Subgraph_isomorphism_problem  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://en.wikipedia.org/wiki/Subgraph_isomorphism_problem'" tppabs="http://en.wikipedia.org/wiki/Subgraph_isomorphism_problem">http://en.wikipedia.org/wiki/Subgraph_isomorphism_problem</a></p>
<p><a href="javascript:if(confirm('http://en.wikipedia.org/wiki/Maximum_common_subgraph_isomorphism_problem  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://en.wikipedia.org/wiki/Maximum_common_subgraph_isomorphism_problem'" tppabs="http://en.wikipedia.org/wiki/Maximum_common_subgraph_isomorphism_problem">http://en.wikipedia.org/wiki/Maximum_common_subgraph_isomorphism_problem</a></p>
<p class="e">UVa 10729 10904 12489 ICPC 2935</p>
<pre>
http://en.wikipedia.org/wiki/Graph_isomorphism_problem#Solved_special_cases

subtree isomorphism問題可以用DP+matching來解決
https://code.google.com/codejam/contest/dashboard?c=32005#s=a&a=3
http://www.lsi.upc.edu/~valiente/riga-tre.pdf
</pre>
<pre>
為什麼對？
https://github.com/juanplopes/icpc/blob/master/uva/12489.cpp
</pre>
<p class="t">Product</p>
<p><a href="javascript:if(confirm('http://en.wikipedia.org/wiki/Graph_product  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://en.wikipedia.org/wiki/Graph_product'" tppabs="http://en.wikipedia.org/wiki/Graph_product">http://en.wikipedia.org/wiki/Graph_product</a></p>
<p class="t">Minor</p>
<p><a href="javascript:if(confirm('http://en.wikipedia.org/wiki/Graph_minor  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://en.wikipedia.org/wiki/Graph_minor'" tppabs="http://en.wikipedia.org/wiki/Graph_minor">http://en.wikipedia.org/wiki/Graph_minor</a></p>
<pre>
minor -> 一張無向圖，收縮某些邊之後得到的圖。
minor containment problem -> 問一張圖是不是有某個minor。至少是NP-complete吧。
</pre>
<p class="e">ICPC 4023</p>
<p class="t">Separator</p>
<p><a href="javascript:if(confirm('http://en.wikipedia.org/wiki/Vertex_separator  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://en.wikipedia.org/wiki/Vertex_separator'" tppabs="http://en.wikipedia.org/wiki/Vertex_separator">http://en.wikipedia.org/wiki/Vertex_separator</a></p>
<p class="t">Expander</p>
<p><a href="javascript:if(confirm('http://en.wikipedia.org/wiki/Expander_graph  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://en.wikipedia.org/wiki/Expander_graph'" tppabs="http://en.wikipedia.org/wiki/Expander_graph">http://en.wikipedia.org/wiki/Expander_graph</a></p>
<pre>
Definition 3.1
A graph G = (V,E) is called an (n, d, c)-expander
if it has n vertices, the maximum degree is d,
and for all S 屬於 V with |S| <= |V|/2,
we have |N(S)| >= c|S| and c is called the expansion of G.
</pre>
<p class="t">Complement Graph</p>
<p>【待補文字】</p>
<p class="t">Dual Graph</p>
<img src="DualGraph1.png" tppabs="http://www.csie.ntnu.edu.tw/~u91029/DualGraph1.png">
<p>一張平面圖當中，面與面的關係表示成一張圖，稱作Dual Graph。請參考「<a href="PlanarGraph.html" tppabs="http://www.csie.ntnu.edu.tw/~u91029/PlanarGraph.html">Planar Graph</a>」。</p>
<p class="t">Line Graph</p>
<img src="LineGraph1.png" tppabs="http://www.csie.ntnu.edu.tw/~u91029/LineGraph1.png">
<p>一張圖當中，邊與邊關係表示成一張圖，稱作Line Graph。</p>
<p>原圖和Line Graph並非對偶，因為Line Graph無法使用相同手法得到原圖。</p>
<p class="e">UVa 10988 11175</p>

</div></div><div class="a"><div class="h">
<p class="b">Intersection Graph</p>
<p class="r">程度★★★　難度★</p>
</div><div class="c">
<p class="t">Intersection Graph</p>
<p>所有圖都可以表示成intersection graph。</p>
<p class="t">Scheinerman's conjecture</p>
<p><a href="javascript:if(confirm('http://en.wikipedia.org/wiki/Scheinerman\'s_conjecture  \n\nThis file was not retrieved by Teleport Pro, because it is addressed on a domain or path outside the boundaries set for its Starting Address.  \n\nDo you want to open it from the server?'))window.location='http://en.wikipedia.org/wiki/Scheinerman\'s_conjecture'" tppabs="http://en.wikipedia.org/wiki/Scheinerman's_conjecture">http://en.wikipedia.org/wiki/Scheinerman's_conjecture</a></p>

</div></div><div class="a"><div class="h">
<p class="b">Hypergraph</p>
<p class="r">程度★★★　難度★</p>
</div><div class="c">
<p>【待補文字】</p>

</div></div><div class="a"><div class="h">
<p class="b">拉里拉雜Graph</p>
<p class="r">程度★★　難度★★★</p>
</div><div class="c">
<p class="t">Cactus Graph</p>
<img src="DirectedCactus1.png" tppabs="http://www.csie.ntnu.edu.tw/~u91029/DirectedCactus1.png">
<p>有向仙人掌：圖上每條邊隸屬於恰好一個有向簡單環。另一種說法：許多有向環，相互銜接成樹狀，接縫恰好是一點。</p>
<p>要判斷一張圖是不是有向仙人掌，原理就跟判斷「<a href="Connectivity.html" tppabs="http://www.csie.ntnu.edu.tw/~u91029/Connectivity.html">關節點</a>」的方法相同。</p>
<pre>
使用 DFS ，會遇到三種情形：

一、 (i, j) 是 cross edge 或 forward edge：

    tree edge 和 back edge 剛好構成仙人掌全部的邊，
    所以不會有 cross edge 與 forward edge。
    如果有的話，就表示不是仙人掌。

    實作時，可利用 DFS stack 判斷，
    如果 j 不在 stack 又已經拜訪過（也就是 j 已經從 stack 彈出來了），
    則表示 (i, j) 一定是 cross edge 或 forward edge。

二、 (i, j) 是 back edge：

    如果從 i 就已經有路可以走回到 i 的祖先（也是會經過其他的back edge），
    此時 j 又走回到 i 的祖先，表示環重疊，不是仙人掌。

    範例一：12 23 34 45 56 62 53!       // i = 5 and j = 3
    範例二：12 23 34 45 51! 53!         // 怎麼好像在寫棋譜...

    實作時，累加 i 回到祖先的路有幾條，只能是恰好一條。
    可利用關節點演算法的原理，記錄 i 可到達的最高祖先。

三、 (i, j) 是 tree edge：

    與 2. 的概念很像，不過要在 DFS 的回溯階段才能判斷。
    如果從 i 就已經有路可以走回到 i 的祖先，
    此時 j 又有路走回到 i 的祖先，表示環重疊，不是仙人掌。

    範例一：12 23 34 45 56! 67! 72! 58! 89! 91!     // i = 5 and j = 8
    範例二：12 23 34 45 51! 58! 89! 91!             // 同上

    實作時，累加 i 回到祖先的路有幾條，只能是恰好一條。和（二）一起累加。
    可利用關節點演算法的原理，記錄 i 可到達的最高祖先。

DFS 結束之後，
最後要判斷 DFS 是否能順利走到圖上所有點。

附註：樹根不必走到祖先，要當做例外處理。可以選定任何一點作為樹根。
</pre>
<textarea>
int adj[9][9];	// adjacency matrix
int dis[9];		// DFS遍歷順序
int low[9];		// 可以走回到的最高祖先（的遍歷順序）
int t = 0;		// 時刻
bool v[9];		// 已經結束拜訪的節點

bool DFS(int p, int i)
{
	dis[i] = low[i] = ++t;

	int c = 0;
	for (int j=0; j<9; ++j)
		if (!dis[j])	// tree edge
		{
			// 一旦發現不是仙人掌就可以馬上結束
			if (!DFS(i, j)) return false;

			// 找到一條走回到i點祖先的路
			if (low[j] < dis[i]) if (++c > 1) return false;

			// 更新i點可走到的最高祖先
			low[i] = min(low[i], low[j]);
		}
		else			// back edge
		{
			// 排除 forward edge 與 cross edge 的情況
			if (v[j]) return false;

			// 找到一條走回到i點祖先的路
			if (dis[j] < low[i]) if (++c > 1) return false;

			// 更新i點可走到的最高祖先
			low[i] = min(low[i], dis[j]);
		}

	v[i] = true;
	return p == -1 ? true : c == 1;
}

bool directed_cactus()
{
	memset(d, 0, sizeof(d));
	memset(v, false, sizeof(v));
	t = 0;

	// 也要確認DFS是否有走到圖上所有點
	return DFS(-1, 0) && t == V;
}
</textarea>
<p class="e">UVa 10510 ICPC 3514 CF 231E</p>
<p class="t">Cograph</p>
<p class="e">ICPC 3666</p>

</div></div><div class="a"><div class="h">
<p class="b">???</p>
<p class="r">程度★★　難度★★★</p>
</div><div class="c">
<p>http://en.wikipedia.org/wiki/Geometric_graph_theory</p>
</div></div><script src="h.js" tppabs="http://www.csie.ntnu.edu.tw/~u91029/h.js"></script></body></html>