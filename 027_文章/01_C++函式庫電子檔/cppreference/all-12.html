<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Linux/x86 (vers 1 September 2005), see www.w3.org">

  <title>C++ Vectors</title>
  <link href="cppreference.css" tppabs="http://www.cppreference.com/cppreference.css" rel="stylesheet" type="text/css">
</head>

<body>
<table>
  <tr>
  <td>
  <div class="body-content">

  <div class="header-box">
    <a href="index.html" tppabs="http://www.cppreference.com/index.html">cppreference.com</a> &gt; <a href=
    "index-14.html" tppabs="http://www.cppreference.com/cppvector/index.html">C++ Vectors</a>
  </div>

  <div class="name-format">
    assign
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  void assign( <strong>size_type</strong> num, const <a href=
"containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; val );
  void assign( <a href=
"iterators.html" tppabs="http://www.cppreference.com/iterators.html">input_iterator</a> start, <a href=
"iterators.html" tppabs="http://www.cppreference.com/iterators.html">input_iterator</a> end );
</pre>

  <p>The assign() function either gives the current vector the values
  from <em>start</em> to <em>end</em>, or gives it <em>num</em> copies
  of <em>val</em>.</p>

  <p>This function will destroy the previous contents of the
  vector.</p>

  <p>For example, the following code uses assign() to put 10 copies of
  the integer 42 into a vector:</p>
  <pre class="example-code">
 vector&lt;int&gt; v;
 v.assign( 10, 42 );
 for( int i = 0; i &lt; v.size(); i++ ) {
   cout &lt;&lt; v[i] &lt;&lt; &quot; &quot;;
 }
 cout &lt;&lt; endl;            
</pre>

  <p>The above code displays the following output:</p>
  <pre class="example-code">
 42 42 42 42 42 42 42 42 42 42          
</pre>

  <p>The next example shows how assign() can be used to copy one vector
  to another:</p>
  <pre class="example-code">
 vector&lt;int&gt; v1;
 for( int i = 0; i &lt; 10; i++ ) {
   v1.push_back( i );
 }              

 vector&lt;int&gt; v2;
 v2.assign( v1.begin(), v1.end() );             

 for( int i = 0; i &lt; v2.size(); i++ ) {
   cout &lt;&lt; v2[i] &lt;&lt; &quot; &quot;;
 }
 cout &lt;&lt; endl;            
</pre>

  <p>When run, the above code displays the following output:</p>
  <pre class="example-code">
 0 1 2 3 4 5 6 7 8 9            
</pre>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    (C++ Strings) <a href="assign1.html" tppabs="http://www.cppreference.com/cppstring/assign1.html">assign</a><br>
    <a href="insert-1.html" tppabs="http://www.cppreference.com/cppvector/insert.html">insert</a><br>
    <a href="push_back-1.html" tppabs="http://www.cppreference.com/cppvector/push_back.html">push_back</a><br>
    (C++ Lists) <a href="push_front-1.html" tppabs="http://www.cppreference.com/cpplist/push_front.html">push_front</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    back
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  <a href="containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; back();
  const <a href="containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; back() const;
</pre>

  <p>The back() function returns a reference to the last element in the
  vector.</p>

  <p>For example:</p>
  <pre class="example-code">
 vector&lt;int&gt; v;
 for( int i = 0; i &lt; 5; i++ ) {
   v.push_back(i);
 }
 cout &lt;&lt; &quot;The first element is &quot; &lt;&lt; v.front()
      &lt;&lt; &quot; and the last element is &quot; &lt;&lt; v.back() &lt;&lt; endl;           
</pre>

  <p>This code produces the following output:</p>
  <pre class="example-code">
 The first element is 0 and the last element is 4               
</pre>

  <p>The back() function runs in <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant
  time</a>.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="front.html" tppabs="http://www.cppreference.com/cppvector/front.html">front</a><br>
    <a href="pop_back.html" tppabs="http://www.cppreference.com/cppvector/pop_back.html">pop_back</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    at
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  <a href=
"containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; at( <strong>size_type</strong> loc );
  const <a href=
"containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; at( <strong>size_type</strong> loc ) const;
</pre>

  <p>The at() function returns a reference to the element in the vector
  at index <em>loc</em>. The at() function is safer than the []
  operator, because it won&#39;t let you reference items outside the
  bounds of the vector.</p>

  <p>For example, consider the following code:</p>
  <pre class="example-code">
 vector&lt;int&gt; v( 5, 1 );
 for( int i = 0; i &lt; 10; i++ ) {
   cout &lt;&lt; &quot;Element &quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; v[i] &lt;&lt; endl;
 }              
</pre>

  <p>This code overrunns the end of the vector, producing potentially
  dangerous results. The following code would be much safer:</p>
  <pre class="example-code">
 vector&lt;int&gt; v( 5, 1 );
 for( int i = 0; i &lt; 10; i++ ) {
   cout &lt;&lt; &quot;Element &quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; v.at(i) &lt;&lt; endl;
 }              
</pre>

  <p>Instead of attempting to read garbage values from memory, the at()
  function will realize that it is about to overrun the vector and will
  throw an exception.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="vector_operators.html" tppabs="http://www.cppreference.com/cppvector/vector_operators.html">Vector operators</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    capacity
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  <strong>size_type</strong> capacity() const;
</pre>

  <p>The capacity() function returns the number of elements that the
  vector can hold before it will need to allocate more space.</p>

  <p>For example, the following code uses two different methods to set
  the capacity of two vectors. One method passes an argument to the
  constructor that suggests an initial size, the other method calls the
  reserve function to achieve a similar goal:</p>
  <pre class="example-code">
 vector&lt;int&gt; v1(10);
 cout &lt;&lt; &quot;The capacity of v1 is &quot; &lt;&lt; v1.capacity() &lt;&lt; endl;
 vector&lt;int&gt; v2;
 v2.reserve(20);
 cout &lt;&lt; &quot;The capacity of v2 is &quot; &lt;&lt; v2.capacity() &lt;&lt; endl;         
</pre>

  <p>When run, the above code produces the following output:</p>
  <pre class="example-code">
 The capacity of v1 is 10
 The capacity of v2 is 20               
</pre>

  <p>C++ containers are designed to grow in size dynamically. This
  frees the programmer from having to worry about storing an arbitrary
  number of elements in a container. However, sometimes the programmer
  can improve the performance of her program by giving hints to the
  compiler about the size of the containers that the program will use.
  These hints come in the form of the <a href=
  "reserve-1.html" tppabs="http://www.cppreference.com/cppvector/reserve.html">reserve</a>() function and the constructor used in the
  above example, which tell the compiler how large the container is
  expected to get.</p>

  <p>The capacity() function runs in <a href=
  "complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant time</a>.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="reserve-1.html" tppabs="http://www.cppreference.com/cppvector/reserve.html">reserve</a><br>
    <a href="resize-1.html" tppabs="http://www.cppreference.com/cppvector/resize.html">resize</a><br>
    <a href="size-1.html" tppabs="http://www.cppreference.com/cppvector/size.html">size</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    begin
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  iterator begin();
  const_iterator begin() const;
</pre>

  <p>The function begin() returns an iterator to the first element of
  the vector. begin() should run in <a href=
  "complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant time</a>.</p>

  <p>For example, the following code uses begin() to initialize an
  iterator that is used to traverse a list:</p>
  <pre class="example-code">
   // Create a list of characters
   list&lt;char&gt; charList;
   for( int i=0; i &lt; 10; i++ ) {
     charList.push_front( i + 65 );
   }
   // Display the list
   list&lt;char&gt;::iterator theIterator;
   for( theIterator = charList.begin(); theIterator != charList.end(); theIterator++ ) {
     cout &lt;&lt; *theIterator;
   }            
</pre>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="end-1.html" tppabs="http://www.cppreference.com/cppvector/end.html">end</a><br>
    <a href="rbegin-1.html" tppabs="http://www.cppreference.com/cppvector/rbegin.html">rbegin</a><br>
    <a href="rend-1.html" tppabs="http://www.cppreference.com/cppvector/rend.html">rend</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    max_size
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  <strong>size_type</strong> max_size() const;
</pre>

  <p>The max_size() function returns the maximum number of elements
  that the vector can hold. The max_size() function should not be
  confused with the <a href="size-1.html" tppabs="http://www.cppreference.com/cppvector/size.html">size</a>() or <a href=
  "capacity-1.html" tppabs="http://www.cppreference.com/cppvector/capacity.html">capacity</a>() functions, which return the number of
  elements currently in the vector and the the number of elements that
  the vector will be able to hold before more memory will have to be
  allocated, respectively.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="size-1.html" tppabs="http://www.cppreference.com/cppvector/size.html">size</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    clear
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  void clear();
</pre>

  <p>The function clear() deletes all of the elements in the vector.
  clear() runs in <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">linear time</a>.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="erase-1.html" tppabs="http://www.cppreference.com/cppvector/erase.html">erase</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    empty
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  bool empty() const;
</pre>

  <p>The empty() function returns true if the vector has no elements,
  false otherwise.</p>

  <p>For example, the following code uses empty() as the stopping
  condition on a (C/C++ Keywords) <a href=
  "while.html" tppabs="http://www.cppreference.com/keywords/while.html">while</a> loop to clear a vector and display
  its contents in reverse order:</p>
  <pre class="example-code">
 vector&lt;int&gt; v;
 for( int i = 0; i &lt; 5; i++ ) {
   v.push_back(i);
 }
 while( !v.empty() ) {
   cout &lt;&lt; v.back() &lt;&lt; endl;
   v.pop_back();
 }              
</pre>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="size-1.html" tppabs="http://www.cppreference.com/cppvector/size.html">size</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    end
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  iterator end();
  const_iterator end() const;
</pre>

  <p>The end() function returns an iterator just past the end of the
  vector.</p>

  <p>Note that before you can access the last element of the vector
  using an iterator that you get from a call to end(), you&#39;ll have
  to decrement the iterator first.  This is because end() doesn't
  point to the end of the vector; it points <strong>just past the end
  of the vector</strong>.</p>  

  <p>For example, in the following code, the first "cout" statement
  will display garbage, whereas the second statement will actually
  display the last element of the vector:</p>

  <pre class="example-code">
  vector&lt;int&gt; v1;
  v1.push_back( 0 );
  v1.push_back( 1 );
  v1.push_back( 2 );
  v1.push_back( 3 );

  int bad_val = *(v1.end());
  cout &lt;&lt; "bad_val is " &lt;&lt; bad_val &lt;&lt; endl;

  int good_val = *(v1.end() - 1);
  cout &lt;&lt; "good_val is " &lt;&lt; good_val &lt;&lt; endl;
</pre>

  <p>The next example shows how <a href= "begin-1.html" tppabs="http://www.cppreference.com/cppvector/begin.html">begin</a>() and
  end() can be used to iterate through all of the members of a
  vector:</p> <pre class="example-code"> vector&lt;int&gt; v1( 5, 789
  ); vector&lt;int&gt;::iterator it; for( it = v1.begin(); it !=
  v1.end(); it++ ) { cout &lt;&lt; *it &lt;&lt; endl; } </pre>

  <p>The iterator is initialized with a call to <a href=
  "begin-1.html" tppabs="http://www.cppreference.com/cppvector/begin.html">begin</a>(). After the body of the loop has been
  executed, the iterator is incremented and tested to see if it is
  equal to the result of calling end(). Since end() returns an iterator
  pointing to an element just after the last element of the vector, the
  loop will only stop once all of the elements of the vector have been
  displayed.</p>

  <p>end() runs in <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant time</a>.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="begin-1.html" tppabs="http://www.cppreference.com/cppvector/begin.html">begin</a><br>
    <a href="rbegin-1.html" tppabs="http://www.cppreference.com/cppvector/rbegin.html">rbegin</a><br>
    <a href="rend-1.html" tppabs="http://www.cppreference.com/cppvector/rend.html">rend</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    erase
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  iterator erase( iterator loc );
  iterator erase( iterator start, iterator end );
</pre>

  <p>The erase() function either deletes the element at location
  <em>loc</em>, or deletes the elements between <em>start</em> and
  <em>end</em> (including <em>start</em> but not including
  <em>end</em>). The return value is the element after the last element
  erased.</p>

  <p>The first version of erase (the version that deletes a single
  element at location <em>loc</em>) runs in <a href=
  "complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant time</a> for lists and <a href=
  "complexity.html" tppabs="http://www.cppreference.com/complexity.html">linear time</a> for vectors, dequeues, and
  strings. The multiple-element version of erase always takes <a href=
  "complexity.html" tppabs="http://www.cppreference.com/complexity.html">linear time</a>.</p>

  <p>For example:</p>
  <pre class="example-code">
 // Create a vector, load it with the first ten characters of the alphabet
 vector&lt;char&gt; alphaVector;
 for( int i=0; i &lt; 10; i++ ) {
   alphaVector.push_back( i + 65 );
 }
 int size = alphaVector.size();
 vector&lt;char&gt;::iterator startIterator;
 vector&lt;char&gt;::iterator tempIterator;
 for( int i=0; i &lt; size; i++ ) {
   startIterator = alphaVector.begin();
   alphaVector.erase( startIterator );
   // Display the vector
   for( tempIterator = alphaVector.begin(); tempIterator != alphaVector.end(); tempIterator++ ) {
     cout &lt;&lt; *tempIterator;
   }
   cout &lt;&lt; endl;
 }              
</pre>

  <p>That code would display the following output:</p>
  <pre class="example-code">
 BCDEFGHIJ
 CDEFGHIJ
 DEFGHIJ
 EFGHIJ
 FGHIJ
 GHIJ
 HIJ
 IJ
 J              
</pre>

  <p>In the next example, erase() is called with two iterators to
  delete a range of elements from a vector:</p>
  <pre class="example-code">
 // create a vector, load it with the first ten characters of the alphabet
 vector&lt;char&gt; alphaVector;
 for( int i=0; i &lt; 10; i++ ) {
   alphaVector.push_back( i + 65 );
 }
 // display the complete vector
 for( int i = 0; i &lt; alphaVector.size(); i++ ) {
   cout &lt;&lt; alphaVector[i];
 }
 cout &lt;&lt; endl;            

 // use erase to remove all but the first two and last three elements
 // of the vector
 alphaVector.erase( alphaVector.begin()+2, alphaVector.end()-3 );
 // display the modified vector
 for( int i = 0; i &lt; alphaVector.size(); i++ ) {
   cout &lt;&lt; alphaVector[i];
 }
 cout &lt;&lt; endl;            
</pre>

  <p>When run, the above code displays:</p>
  <pre class="example-code">
 ABCDEFGHIJ
 ABHIJ          
</pre>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="clear-2.html" tppabs="http://www.cppreference.com/cppvector/clear.html">clear</a><br>
    <a href="insert-1.html" tppabs="http://www.cppreference.com/cppvector/insert.html">insert</a><br>
    <a href="pop_back.html" tppabs="http://www.cppreference.com/cppvector/pop_back.html">pop_back</a><br>
    (C++ Lists) <a href="pop_front-1.html" tppabs="http://www.cppreference.com/cpplist/pop_front.html">pop_front</a><br>
    (C++ Lists) <a href="remove-2.html" tppabs="http://www.cppreference.com/cpplist/remove.html">remove</a><br>
    (C++ Lists) <a href="remove_if-1.html" tppabs="http://www.cppreference.com/cpplist/remove_if.html">remove_if</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    front
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  <a href="containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; front();
  const <a href="containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; front() const;
</pre>

  <p>The front() function returns a reference to the first element of
  the vector, and runs in <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant
  time</a>.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="back.html" tppabs="http://www.cppreference.com/cppvector/back.html">back</a><br>
    (C++ Lists) <a href="pop_front-1.html" tppabs="http://www.cppreference.com/cpplist/pop_front.html">pop_front</a><br>
    (C++ Lists) <a href="push_front-1.html" tppabs="http://www.cppreference.com/cpplist/push_front.html">push_front</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    insert
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  iterator insert( iterator loc, const <a href=
"containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; val );
  void insert( iterator loc, <strong>size_type</strong> num, const <a href="containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; val );
  template&lt;<a href=
"containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&gt; void insert( iterator loc, <a href=
"iterators.html" tppabs="http://www.cppreference.com/iterators.html">input_iterator</a> start, <a href=
"iterators.html" tppabs="http://www.cppreference.com/iterators.html">input_iterator</a> end );
</pre>

  <p>The insert() function either:</p>

  <ul>
    <li>inserts <em>val</em> before <em>loc</em>, returning an iterator
    to the element inserted,</li>

    <li>inserts <em>num</em> copies of <em>val</em> before
    <em>loc</em>, or</li>

    <li>inserts the elements from <em>start</em> to <em>end</em> before
    <em>loc</em>.</li>
  </ul>

  <p>Note that inserting elements into a vector can be relatively
  time-intensive, since the underlying data structure for a vector is
  an array.  In order to insert data into an array, you might need to
  displace a lot of the elements of that array, and this can take <a
  href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">linear time</a>.  If you are planning on
  doing a lot of insertions into your vector and you care about speed,
  you might be better off using a container that has a linked list as
  its underlying data structure (such as a <a
  href="index-16.html" tppabs="http://www.cppreference.com/cpplist/index.html">List</a> or a
  <a
  href="index-15.html" tppabs="http://www.cppreference.com/cppdeque/index.html">Deque</a>).</p>

  <p>For example, the following code uses the insert() function to
  splice four copies of the character 'C' into a vector of
  characters:</p>

  <pre class="example-code">
 // Create a vector, load it with the first 10 characters of the alphabet
 vector&lt;char&gt; alphaVector;
 for( int i=0; i &lt; 10; i++ ) {
   alphaVector.push_back( i + 65 );
 }              

 // Insert four C&#39;s into the vector
 vector&lt;char&gt;::iterator theIterator = alphaVector.begin();
 alphaVector.insert( theIterator, 4, &#39;C&#39; );             

 // Display the vector
 for( theIterator = alphaVector.begin(); theIterator != alphaVector.end(); theIterator++ )    {
   cout &lt;&lt; *theIterator;
 }              
</pre>

  <p>This code would display:</p>
  <pre class="example-code">
 CCCCABCDEFGHIJ         
</pre>

  <p>Here is another example of the insert() function.  In this code,
  insert() is used to append the contents of one vector onto the end
  of another:</p>

  <pre class="example-code">
  vector&lt;int&gt; v1;
  v1.push_back( 0 );
  v1.push_back( 1 );
  v1.push_back( 2 );
  v1.push_back( 3 );

  vector&lt;int&gt; v2;
  v2.push_back( 5 );
  v2.push_back( 6 );
  v2.push_back( 7 );
  v2.push_back( 8 );

  cout &lt;&lt; "Before, v2 is: ";
  for( int i = 0; i &lt; v2.size(); i++ ) {
    cout &lt;&lt; v2[i] &lt;&lt; " ";
  }
  cout &lt;&lt; endl;

  v2.insert( v2.end(), v1.begin(), v1.end() );

  cout &lt;&lt; "After, v2 is: ";
  for( int i = 0; i &lt; v2.size(); i++ ) {
    cout &lt;&lt; v2[i] &lt;&lt; " ";
  }
  cout &lt;&lt; endl;
</pre>

  <p>When run, this code displays:</p>

  <pre class="example-code">
  Before, v2 is: 5 6 7 8
  After, v2 is: 5 6 7 8 0 1 2 3
</pre>


  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="assign.html" tppabs="http://www.cppreference.com/cppvector/assign.html">assign</a><br>
    <a href="erase-1.html" tppabs="http://www.cppreference.com/cppvector/erase.html">erase</a><br>
    <a href="push_back-1.html" tppabs="http://www.cppreference.com/cppvector/push_back.html">push_back</a><br>
    (C++ Lists) <a href="merge-1.html" tppabs="http://www.cppreference.com/cpplist/merge.html">merge</a><br>
    (C++ Lists) <a href="push_front-1.html" tppabs="http://www.cppreference.com/cpplist/push_front.html">push_front</a><br>
    (C++ Lists) <a href="splice.html" tppabs="http://www.cppreference.com/cpplist/splice.html">splice</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    Vector constructors
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  vector();
  vector( const vector&amp; c );
  vector( <strong>size_type</strong> num, const <a href=
"containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; val = <a href=
"containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>() );
  vector( <a href=
"iterators.html" tppabs="http://www.cppreference.com/iterators.html">input_iterator</a> start, <a href=
"iterators.html" tppabs="http://www.cppreference.com/iterators.html">input_iterator</a> end );
  ~vector();
</pre>

  <p>The default vector constructor takes no arguments, creates a new
  instance of that vector.</p>

  <p>The second constructor is a default copy constructor that can be
  used to create a new vector that is a copy of the given vector
  <em>c</em>.</p>

  <p>The third constructor creates a vector with space for <em>num</em>
  objects. If <em>val</em> is specified, each of those objects will be
  given that value. For example, the following code creates a vector
  consisting of five copies of the integer 42:</p>
  <pre class="example-code">
 vector&lt;int&gt; v1( 5, 42 );         
</pre>

  <p>The last constructor creates a vector that is initialized to
  contain the elements between <em>start</em> and <em>end</em>. For
  example:</p>
  <pre class="example-code">
 // create a vector of random integers
 cout &lt;&lt; &quot;original vector: &quot;;
 vector&lt;int&gt; v;
 for( int i = 0; i &lt; 10; i++ ) {
   int num = (int) rand() % 10;
   cout &lt;&lt; num &lt;&lt; &quot; &quot;;
   v.push_back( num );
 }
 cout &lt;&lt; endl;            

 // find the first element of v that is even
 vector&lt;int&gt;::iterator iter1 = v.begin();
 while( iter1 != v.end() &amp;&amp; *iter1 % 2 != 0 ) {
   iter1++;
 }              

 // find the last element of v that is even
 vector&lt;int&gt;::iterator iter2 = v.end();
 do {
   iter2--;
 } while( iter2 != v.begin() &amp;&amp; *iter2 % 2 != 0 );              

 cout &lt;&lt; &quot;first even number: &quot; &lt;&lt; *iter1 &lt;&lt; &quot;, last even number: &quot; &lt;&lt; *iter2 &lt;&lt; endl;         

 cout &lt;&lt; &quot;new vector: &quot;;
 vector&lt;int&gt; v2( iter1, iter2 );
 for( int i = 0; i &lt; v2.size(); i++ ) {
   cout &lt;&lt; v2[i] &lt;&lt; &quot; &quot;;
 }
 cout &lt;&lt; endl;            
</pre>

  <p>When run, this code displays the following output:</p>
  <pre class="example-code">
 original vector: 1 9 7 9 2 7 2 1 9 8
 first even number: 2, last even number: 8
 new vector: 2 7 2 1 9          
</pre>

  <p>All of these constructors run in <a href=
  "complexity.html" tppabs="http://www.cppreference.com/complexity.html">linear time</a> except the first, which runs in
  <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant time</a>.</p>

  <p>The default destructor is called when the vector should be
  destroyed.</p>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    pop_back
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  void pop_back();
</pre>

  <p>The pop_back() function removes the last element of the
  vector.</p>

  <p>pop_back() runs in <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant
  time</a>.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="back.html" tppabs="http://www.cppreference.com/cppvector/back.html">back</a><br>
    <a href="erase-1.html" tppabs="http://www.cppreference.com/cppvector/erase.html">erase</a><br>
    (C++ Lists) <a href="pop_front-1.html" tppabs="http://www.cppreference.com/cpplist/pop_front.html">pop_front</a><br>
    <a href="push_back-1.html" tppabs="http://www.cppreference.com/cppvector/push_back.html">push_back</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    push_back
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  void push_back( const <a href=
"containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; val );
</pre>

  <p>The push_back() function appends <em>val</em> to the end of the
  vector.</p>

  <p>For example, the following code puts 10 integers into a list:</p>
  <pre class="example-code">
   list&lt;int&gt; the_list;
   for( int i = 0; i &lt; 10; i++ )
     the_list.push_back( i );           
</pre>

  <p>When displayed, the resulting list would look like this:</p>
  <pre class="example-code">
 0 1 2 3 4 5 6 7 8 9            
</pre>

  <p>push_back() runs in <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant
  time</a>.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="assign.html" tppabs="http://www.cppreference.com/cppvector/assign.html">assign</a><br>
    <a href="insert-1.html" tppabs="http://www.cppreference.com/cppvector/insert.html">insert</a><br>
    <a href="pop_back.html" tppabs="http://www.cppreference.com/cppvector/pop_back.html">pop_back</a><br>
    (C++ Lists) <a href="push_front-1.html" tppabs="http://www.cppreference.com/cpplist/push_front.html">push_front</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    rbegin
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  <a href="iterators.html" tppabs="http://www.cppreference.com/iterators.html">reverse_iterator</a> rbegin();
  const_<a href=
"iterators.html" tppabs="http://www.cppreference.com/iterators.html">reverse_iterator</a> rbegin() const;
</pre>

  <p>The rbegin() function returns a <a href=
  "iterators.html" tppabs="http://www.cppreference.com/iterators.html">reverse_iterator</a> to the end of the current
  vector.</p>

  <p>rbegin() runs in <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant
  time</a>.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="begin-1.html" tppabs="http://www.cppreference.com/cppvector/begin.html">begin</a><br>
    <a href="end-1.html" tppabs="http://www.cppreference.com/cppvector/end.html">end</a><br>
    <a href="rend-1.html" tppabs="http://www.cppreference.com/cppvector/rend.html">rend</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    rend
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  <a href="iterators.html" tppabs="http://www.cppreference.com/iterators.html">reverse_iterator</a> rend();
  const_<a href="iterators.html" tppabs="http://www.cppreference.com/iterators.html">reverse_iterator</a> rend() const;
</pre>

  <p>The function rend() returns a <a href=
  "iterators.html" tppabs="http://www.cppreference.com/iterators.html">reverse_iterator</a> to the beginning of the
  current vector.</p>

  <p>rend() runs in <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant time</a>.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="begin-1.html" tppabs="http://www.cppreference.com/cppvector/begin.html">begin</a><br>
    <a href="end-1.html" tppabs="http://www.cppreference.com/cppvector/end.html">end</a><br>
    <a href="rbegin-1.html" tppabs="http://www.cppreference.com/cppvector/rbegin.html">rbegin</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    reserve
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  void reserve( <strong>size_type</strong> size );
</pre>

  <p>The reserve() function sets the capacity of the vector to at least
  <em>size</em>.</p>

  <p>reserve() runs in <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">linear
  time</a>.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="capacity-1.html" tppabs="http://www.cppreference.com/cppvector/capacity.html">capacity</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    resize
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  void resize( <strong>size_type</strong> num, const <a href=
"containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; val = <a href=
"containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>() );
</pre>

  <p>The function resize() changes the size of the vector to
  <em>size</em>. If <em>val</em> is specified then any newly-created
  elements will be initialized to have a value of <em>val</em>.</p>

  <p>This function runs in <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">linear
  time</a>.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href=
    "vector_constructors.html" tppabs="http://www.cppreference.com/cppvector/vector_constructors.html">Vector constructors
    &amp; destructors</a><br>
    <a href="capacity-1.html" tppabs="http://www.cppreference.com/cppvector/capacity.html">capacity</a><br>
    <a href="size-1.html" tppabs="http://www.cppreference.com/cppvector/size.html">size</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    size
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  <strong>size_type</strong> size() const;
</pre>

  <p>The size() function returns the number of elements in the current
  vector.</p>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="capacity-1.html" tppabs="http://www.cppreference.com/cppvector/capacity.html">capacity</a><br>
    <a href="empty-1.html" tppabs="http://www.cppreference.com/cppvector/empty.html">empty</a><br>
    (C++ Strings) <a href="length.html" tppabs="http://www.cppreference.com/cppstring/length.html">length</a><br>
    <a href="max_size-1.html" tppabs="http://www.cppreference.com/cppvector/max_size.html">max_size</a><br>
    <a href="resize-1.html" tppabs="http://www.cppreference.com/cppvector/resize.html">resize</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    swap
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  void swap( const container&amp; from );
</pre>

  <p>The swap() function exchanges the elements of the current vector
  with those of <em>from</em>. This function operates in <a href=
  "complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant time</a>.</p>

  <p>For example, the following code uses the swap() function to
  exchange the values of two strings:</p>
  <pre class="example-code">
   string first( &quot;This comes first&quot; );
   string second( &quot;And this is second&quot; );
   first.swap( second );
   cout &lt;&lt; first &lt;&lt; endl;
   cout &lt;&lt; second &lt;&lt; endl;          
</pre>

  <p>The above code displays:</p>
  <pre class="example-code">
   And this is second
   This comes first             
</pre>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    (C++ Lists) <a href="splice.html" tppabs="http://www.cppreference.com/cpplist/splice.html">splice</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>

  <div class="name-format">
    Vector operators
  </div>

  <div class="syntax-name-format">
    Syntax:
  </div>
  <pre class="syntax-box">
  #include &lt;vector&gt;
  <a href=
"containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; operator[]( <strong>size_type</strong> index );
  const <a href=
"containers.html" tppabs="http://www.cppreference.com/containers.html">TYPE</a>&amp; operator[]( <strong>size_type</strong> index ) const;
  vector operator=(const vector&amp; c2);
  bool operator==(const vector&amp; c1, const vector&amp; c2);
  bool operator!=(const vector&amp; c1, const vector&amp; c2);
  bool operator&lt;(const vector&amp; c1, const vector&amp; c2);
  bool operator&gt;(const vector&amp; c1, const vector&amp; c2);
  bool operator&lt;=(const vector&amp; c1, const vector&amp; c2);
  bool operator&gt;=(const vector&amp; c1, const vector&amp; c2);
</pre>

  <p>All of the C++ containers can be compared and assigned with the
  standard comparison operators: ==, !=, &lt;=, &gt;=, &lt;, &gt;, and
  =. Individual elements of a vector can be examined with the []
  operator.</p>

  <p>Performing a comparison or assigning one vector to another takes
  <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">linear time</a>. The [] operator runs in
  <a href="complexity.html" tppabs="http://www.cppreference.com/complexity.html">constant time</a>.</p>

  <p>Two vectors are equal if:</p>

  <ol>
    <li>Their size is the same, and</li>

    <li>Each member in location i in one vector is equal to the the
    member in location i in the other vector.</li>
  </ol>

  <p>Comparisons among vectors are done lexicographically.</p>

  <p>For example, the following code uses the [] operator to access all
  of the elements of a vector:</p>
  <pre class="example-code">
 vector&lt;int&gt; v( 5, 1 );
 for( int i = 0; i &lt; v.size(); i++ ) {
   cout &lt;&lt; &quot;Element &quot; &lt;&lt; i &lt;&lt; &quot; is &quot; &lt;&lt; v[i] &lt;&lt; endl;
 }              
</pre>

  <div class="related-name-format">
    Related topics:
  </div>

  <div class="related-content">
    <a href="at-1.html" tppabs="http://www.cppreference.com/cppvector/at.html">at</a>
  </div>
  </div>
  </td>
  


  </tr>
  </table>
</body></html>
<hr>
</body></html>